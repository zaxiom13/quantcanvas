
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Q for Mortals - Complete Book</title>
    <meta name="description" content="Complete Q for Mortals book compiled from code.kx.com">
    <meta name="author" content="Jeffry Borror">
    
    <link rel="stylesheet" href="https://code.kx.com/stylesheets/2021.css">
    <link rel="stylesheet" href="https://code.kx.com/stylesheets/prism.css">
    <link rel="stylesheet" href="https://code.kx.com/stylesheets/extra.css">
    
    <style>
        :root {
            --primary-color: #007acc;
            --secondary-color: #f8f9fa;
            --error-color: #d32f2f;
            --border-color: #e0e0e0;
            --text-color: #333;
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #fff;
            color: var(--text-color);
        }
        
        .main-header {
            text-align: center;
            padding: 40px 0;
            border-bottom: 3px solid var(--primary-color);
            margin-bottom: 40px;
        }
        
        .main-header h1 {
            color: var(--primary-color);
            font-size: 2.5em;
            margin: 0;
        }
        
        .stats {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            padding: 20px;
            background: var(--secondary-color);
            border-radius: 8px;
            font-size: 0.9em;
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: var(--primary-color);
        }
        
        .chapter {
            margin-bottom: 60px;
            padding-bottom: 40px;
            border-bottom: 2px solid var(--border-color);
        }
        
        .chapter:last-child {
            border-bottom: none;
        }
        
        .chapter-header {
            background: var(--secondary-color);
            padding: 20px;
            margin-bottom: 30px;
            border-left: 4px solid var(--primary-color);
            border-radius: 4px;
        }
        
        .chapter-title {
            margin: 0;
            color: var(--primary-color);
            font-size: 1.8em;
        }
        
        .chapter-meta {
            color: #666;
            font-size: 0.9em;
            margin-top: 10px;
            display: flex;
            gap: 20px;
        }
        
        .table-of-contents {
            background: var(--secondary-color);
            padding: 30px;
            margin: 40px 0;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .table-of-contents h2 {
            margin-top: 0;
            color: var(--primary-color);
            text-align: center;
        }
        
        .toc-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }
        
        .toc-item {
            padding: 10px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .toc-item:hover {
            background: white;
        }
        
        .toc-item a {
            text-decoration: none;
            color: var(--primary-color);
            font-weight: 500;
            display: block;
        }
        
        .toc-item a:hover {
            text-decoration: underline;
        }
        
        .word-count {
            color: #666;
            font-size: 0.8em;
        }
        
        .error {
            color: var(--error-color);
            background: #ffebee;
            padding: 20px;
            border-radius: 4px;
            margin: 20px 0;
            border-left: 4px solid var(--error-color);
        }
        
        .error h3 {
            margin-top: 0;
        }
        
        .chapter-content {
            position: relative;
        }
        
        .chapter-content h1,
        .chapter-content h2,
        .chapter-content h3 {
            margin-top: 2em;
            margin-bottom: 1em;
        }
        
        .chapter-content h1:first-child,
        .chapter-content h2:first-child,
        .chapter-content h3:first-child {
            margin-top: 0;
        }
        
        .chapter-content pre {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            border-left: 4px solid var(--primary-color);
        }
        
        .chapter-content code {
            background: #f5f5f5;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', monospace;
        }
        
        .chapter-content blockquote {
            border-left: 4px solid var(--primary-color);
            margin: 20px 0;
            padding-left: 20px;
            color: #666;
        }
        
        .chapter-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        .chapter-content th,
        .chapter-content td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        
        .chapter-content th {
            background: var(--secondary-color);
            font-weight: bold;
        }
        
        @media print {
            .chapter {
                page-break-before: always;
            }
            
            .chapter:first-child {
                page-break-before: avoid;
            }
            
            .main-header,
            .table-of-contents {
                page-break-after: always;
            }
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .stats {
                flex-direction: column;
                gap: 10px;
            }
            
            .chapter-meta {
                flex-direction: column;
                gap: 5px;
            }
            
            .toc-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <header class="main-header">
        <h1>Q for Mortals</h1>
        <p>Complete book compiled from <a href="https://code.kx.com/q4m3/">code.kx.com/q4m3/</a></p>
        <div class="stats">
            <div class="stat">
                <div class="stat-value">20</div>
                <div>Total Chapters</div>
            </div>
            <div class="stat">
                <div class="stat-value">20</div>
                <div>Successfully Downloaded</div>
            </div>
            <div class="stat">
                <div class="stat-value">122,966</div>
                <div>Total Words</div>
            </div>
            <div class="stat">
                <div class="stat-value">13/07/2025</div>
                <div>Downloaded On</div>
            </div>
        </div>
    </header>
    
    <nav class="table-of-contents">
        <h2>Table of Contents</h2>
        <div class="toc-grid">
            
                <div class="toc-item">
                    <a href="#chapter-0">
                        0. Overview¬∂
                        <span class="word-count">(3500 words)</span>
                    </a>
                </div>
            
                <div class="toc-item">
                    <a href="#chapter-1">
                        1. Q Shock and Awe¬∂
                        <span class="word-count">(11577 words)</span>
                    </a>
                </div>
            
                <div class="toc-item">
                    <a href="#chapter-2">
                        10. Execution Control¬∂
                        <span class="word-count">(3481 words)</span>
                    </a>
                </div>
            
                <div class="toc-item">
                    <a href="#chapter-3">
                        11. I/O¬∂
                        <span class="word-count">(8212 words)</span>
                    </a>
                </div>
            
                <div class="toc-item">
                    <a href="#chapter-4">
                        12. Workspace Organization¬∂
                        <span class="word-count">(2588 words)</span>
                    </a>
                </div>
            
                <div class="toc-item">
                    <a href="#chapter-5">
                        13. Commands and System Variables¬∂
                        <span class="word-count">(6788 words)</span>
                    </a>
                </div>
            
                <div class="toc-item">
                    <a href="#chapter-6">
                        14. Introduction to Kdb+¬∂
                        <span class="word-count">(17492 words)</span>
                    </a>
                </div>
            
                <div class="toc-item">
                    <a href="#chapter-7">
                        2. Basic Data Types: Atoms¬∂
                        <span class="word-count">(4190 words)</span>
                    </a>
                </div>
            
                <div class="toc-item">
                    <a href="#chapter-8">
                        3. Lists¬∂
                        <span class="word-count">(6172 words)</span>
                    </a>
                </div>
            
                <div class="toc-item">
                    <a href="#chapter-9">
                        4. Operators¬∂
                        <span class="word-count">(5157 words)</span>
                    </a>
                </div>
            
                <div class="toc-item">
                    <a href="#chapter-10">
                        5. Dictionaries¬∂
                        <span class="word-count">(3237 words)</span>
                    </a>
                </div>
            
                <div class="toc-item">
                    <a href="#chapter-11">
                        6. Functions¬∂
                        <span class="word-count">(10311 words)</span>
                    </a>
                </div>
            
                <div class="toc-item">
                    <a href="#chapter-12">
                        7. Transforming Data¬∂
                        <span class="word-count">(4006 words)</span>
                    </a>
                </div>
            
                <div class="toc-item">
                    <a href="#chapter-13">
                        8. Tables¬∂
                        <span class="word-count">(8187 words)</span>
                    </a>
                </div>
            
                <div class="toc-item">
                    <a href="#chapter-14">
                        9. Queries: q-sql¬∂
                        <span class="word-count">(14490 words)</span>
                    </a>
                </div>
            
                <div class="toc-item">
                    <a href="#chapter-15">
                        A. Built-in Functions¬∂
                        <span class="word-count">(12284 words)</span>
                    </a>
                </div>
            
                <div class="toc-item">
                    <a href="#chapter-16">
                        B. Error Messages¬∂
                        <span class="word-count">(350 words)</span>
                    </a>
                </div>
            
                <div class="toc-item">
                    <a href="#chapter-17">
                        Q for Mortals v3.1¬∂
                        <span class="word-count">(130 words)</span>
                    </a>
                </div>
            
                <div class="toc-item">
                    <a href="#chapter-18">
                        Preface¬∂
                        <span class="word-count">(407 words)</span>
                    </a>
                </div>
            
                <div class="toc-item">
                    <a href="#chapter-19">
                        Preface¬∂
                        <span class="word-count">(407 words)</span>
                    </a>
                </div>
            
        </div>
    </nav>
    
    <main>
        
            <section class="chapter" id="chapter-0">
                <div class="chapter-header">
                    <h1 class="chapter-title">0. Overview¬∂</h1>
                    <div class="chapter-meta">
                        <span>üìñ Source: <a href="https://code.kx.com/q4m3/0_Overview/">https://code.kx.com/q4m3/0_Overview/</a></span>
                        <span>üìù 3500 words</span>
                        
                    </div>
                </div>
                <div class="chapter-content">
                    
        <div class="md-main__inner md-grid">
          
            
              
              
            
            
              
              
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                
                <h1 id="0-overview">0. Overview</h1>
<h2 id="00-the-evolution-of-q">0.0 The Evolution of Q</h2>
<p>Arthur Whitney developed the q programming language and its database kdb+. Released by Kx Systems, Inc. in 2003, the primary design objectives of q are expressiveness, speed and efficiency. In these, it is beyond compare. The design trade-off is a terseness that can be disconcerting to programmers coming from verbose traditional database programming environments ‚Äì e.g., C++, Java, C# or Python ‚Äì and a relational DBMS. Whereas the q programming gods revel in programs resembling an ASCII core dump, this manual is for the rest of us.</p>
<p>Q evolved from <a href="https://en.wikipedia.org/wiki/APL_(programming_language)">APL</a> (A Programming Language), which was first invented as a mathematical notation by <a href="https://en.wikipedia.org/wiki/Kenneth_E._Iverson">Kenneth Iverson</a> at Harvard University in the 1950s. APL was introduced in the 1960s by IBM as a vector programming language, meaning that it processes a list of numbers in a single operation. It was successful in finance and other industries that required heavy number crunching.</p>
<p>The mitochondrial DNA of q traces from APL to A to <a href="http://www.aplusdev.org/">A+</a> and to k. All were well suited to performing complex calculations quickly on vectors. What's new in q/kdb+ is that it processes large volumes of time-series data very efficiently in the relational paradigm. Its syntax allows "select" expressions that are similar to SQL 92, and its collection of built-in functions provides a complete and powerful stored procedure language.</p>
<p>There is also some <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a> in q's genes: the fundamental data construct of q is a list. Although the notation and terminology are different, symbols are drawn from their counterparts in Scheme.</p>
<p>The APL lineage of q also shows the influence of functional programming. In his 1977 Turing Award lecture that introduced purely functional programming, <a href="https://en.wikipedia.org/wiki/John_Backus">Backus</a> acknowledged inspiration from APL. While q is not purely functional, it is strongly functional in that even its basic data structures, list and dictionary, are viewed as mathematical mappings.</p>
<h2 id="01-philosophy">0.1 Philosophy</h2>
<p>A proficient q developer thinks differently than in conventional programming environments such as C++, Java, C# or Python, henceforth referred to as "traditional programming." In order to get you into the correct mindset, we summarize some of the potential discontinuities for the q newbie ‚Äì henceforth known as qbie.</p>
<p>Recall some of the data-related issues in traditional database programming:</p>
<ul>
<li>In-memory representation ‚Äì e.g., collections of objects ‚Äì must be mapped to a different representation ‚Äì i.e., tables ‚Äì for persistence. It takes considerable effort to get the object-relational correspondence correct.</li>
<li>Objects must be mapped to another representation for transport, usually some binary or XML form that flattens reference chains.</li>
<li>Data manipulation ‚Äì e.g., selection, grouping and aggregation ‚Äì on large data sets is best done in stored procedures on the database server. Demanding numeric calculations are best done apart from the database on an application server.</li>
<li>Data transformation for GUI display is best done in a separate layer ‚Äì e.g., to HTML5 and JavaScript in a browser.</li>
</ul>
<p>Much of traditional programming design is spent getting the various representations correct, requiring many lines of code to marshal resources and synchronize the different representations. These are remarkably simple in q/kdb+.</p>
<p><strong>Interpreted</strong> Q is interpreted, not compiled. During execution, data and functions live in an in-memory workspace. Iterations of the development cycle tend to be quick because all run-time information needed to test and debug is immediately available in the workspace. Q programs are stored and executed as simple text files called scripts. The interpreter's <code>eval</code> and <code>parse</code> routines are exposed so that you can dynamically generate code in a controlled manner.</p>
<p><strong>Types</strong> Q is a dynamically typed language, in which type checking is mostly unobtrusive. Each variable has the type of its currently assigned value and type promotion is automatic for most numeric operations. Types are checked on operations to homogenous lists.</p>
<p><strong>Evaluation Order</strong> While q is entered left-to-right, expressions are evaluated right-to-left or, as the q gods prefer, left of right ‚Äì meaning that a function is applied to the argument on its right. There is no operator precedence and function application can be written without brackets. Punctuation noise is significantly reduced.</p>
<p><strong>Null and Infinity Values</strong> In classical SQL, the value <code>NULL</code> represents missing data for a field of any type and takes no storage space. In q, null values are typed and take the same space as non-nulls. Numeric types also have infinity values. Infinite and null values can participate in arithmetic and other operations with (mostly) predictable results.</p>
<p><strong>Integrated I/O</strong> I/O is done through function handles that act as windows to the outside world. Once such a handle is initialized, passing a value to the handle is a write.</p>
<p><strong>Table Oriented</strong> Give up objects, ye who enter here. In contrast to traditional languages, you'll find no classes, objects, inheritance and virtual methods in q. Instead, q has tables as first class entities. The lack of objects is not as severe as might first appear. Objects are essentially glorified records (i.e., entities with named fields), which are modeled by q dictionaries. A table can be viewed as a list of record dictionaries.</p>
<p><strong>Ordered Lists</strong> Because classical SQL is the algebra of sets ‚Äì which are unordered with no duplicates ‚Äì row order and column order are not defined, making time series processing cumbersome and slow. In q, data structures are based on ordered lists, so time series maintain the order in which they are created. Moreover, simple lists occupy contiguous storage, so processing big data is fast. Very fast.</p>
<p><strong>Column Oriented</strong> SQL tables are organized as rows distributed across storage and operations apply to fields within a row. Q tables are column lists in contiguous storage and operations apply on entire columns.</p>
<p><strong>In-Memory Database</strong> One can think of kdb+ as an in-memory database with persistent backing. Since data manipulation is performed with q, there is no separate stored procedure language. In fact, kdb+ comprises serialized q column lists written to the file system and then mapped into memory.</p>
<h2 id="02-mathematics-refresher">0.2 Mathematics Refresher</h2>
<p>In order to understand q, it is important to have a clear grasp of the basic concepts and terminology of mathematical functions. In fact, the basic constructs of q can all be interpreted as function mappings. The following refresher is intended to help those who are rusty with mathematics.</p>
<h3 id="021-variables">0.2.1 Variables</h3>
<p>In mathematics, a variable represents an unknown whose potential values can be drawn from a specified domain. The power of the concept is that a property or formula that can be demonstrated to hold for a variable is then known to hold for every particular value of its domain.</p>
<p>A variable has a symbolic representation ‚Äì i.e., a name. The names of variables occur in syntactically well-formed expressions. In such a context, a variable is given meaning by substitution ‚Äì i.e., all occurrences of the variable are replaced by a specific value. Once substitution is performed, the variable no longer is an unknown; it has the substituted value from that point onward. In the colloquial, a variable is substituted once in its lifetime.</p>
<p>Imperative programming languages, including q, abuse the concept of a variable. They use the term "variable" to mean a name associated with storage that can hold a value of a specific domain. This should be called an "assignable". The act of associating a name and a value, called <em>assignment</em>, is achieved by placing the value into the storage referenced by the name. Assignment is <strong>not</strong> substitution: the assignment can subsequently be changed and the variable will then have <strong>that</strong> value. Shared assignable variables are the source of great evil in concurrent and distributed computing.</p>
<h3 id="022-functions">0.2.2 Functions</h3>
<p>In mathematics, a function associates a unique output value to each input value. The collection of all input values is the <em>domain</em> of the function and the collection from which the output values are chosen is the <em>codomain</em> (or <em>range</em>). A function is also called a <em>map</em> (or <em>mapping</em>) from its domain to its codomain.</p>
<p>The output value that a function f associates to an input value x is read "f of x" or "f at x" or "f on x" More verbosely, we apply (or evaluate) f at an argument to obtain the corresponding result. In mathematics and many programming languages, the output value of a function is represented with the function name to the left of its argument(s), which are enclosed in matched parentheses or brackets. Some functions can take multiple inputs, which are separated by commas or semicolons.</p>
<p>There are two basic ways to define a function: an algorithm or a graph. An algorithm is a sequence of operations on the input value(s) to arrive at the corresponding output value. For example, we define the squaring function, over the domain and codomain of real numbers, to assign as output value the input value times itself. Alternatively, you can define a function by explicitly listing its input-output associations. The collection of associated input-output pairs is the graph of the function.</p>
<p>As you will no doubt recall from many bucolic hours in high-school math class, a function defined by algorithm can be converted to a graph by feeding in input values, cranking out the associated outputs, and collecting the pairs into a table. In general, there is no explicit formula to calculate the values for an arbitrary input-output graph. If it is possible to define a function via a formula, this is usually the preferred way to specify it since it is compact, but there is no guarantee that the formula will be easy or quick to compute.</p>
<p>Here are the two forms for the squaring function over the domain of natural numbers 0 through 3, as you might recall them from school.</p>
<p><em>f(x) = x<sup>2</sup></em> </p>
<pre class="highlight"><code class="language-txt">I   O
------
0   0
1   1
2   4
3   9</code></pre>
When graphing a function, we normally think of the I/O table as a list of <em>(x,y)</em> pairs in the Cartesian plane.
<pre class="highlight"><code class="language-txt">0, 0
1, 1
2, 4</code></pre>
<p>Alternately, we can view this as a pair of columns having positional correspondence.</p>
<pre class="highlight"><code class="language-txt">0 |-&gt; 0
1 |‚Äì&gt; 1
2 |‚Äì&gt; 4</code></pre>
<p>This perspective will prove useful.</p>
<p>The number of inputs to a function is called its <em>valence</em>. Lower valences have their own terminology. A function of valence 1 (i.e., defined by a formula that has one parameter) is said to be <em>unary</em>. For example, <code>neg(x)</code> takes a number and returns the result of reversing the sign. A function of valence 2 (i.e., two parameters) is said to be <em>binary</em>. For example, <code>sum(x, y)</code> takes two numbers and adds them to get the result. A function with no parameters is <em>Nullary</em>. For example, a constant function with no parameters that returns 42.</p>
<p>Given functions <em>f</em> and <em>g</em> for which the codomain of <em>g</em> is the domain of <em>f</em>, the <em>composite</em>, denoted <em>f¬∑g</em>, is the function obtained by chaining the output of <em>g</em> into <em>f</em>. That is, the composite assigns to an input <em>x</em> the output value <em>f(g(x))</em>. Observe the usual mathematical convention in which the order of the functions in the composite matches their order in the nested evaluation.</p>
<p>Pictorially, we can see that the composite chains the output of <em>g</em> into the input of <em>f</em>,</p>
<pre class="highlight"><code class="language-txt">  g        f
x |‚Äì&gt; g(x) |‚Äì&gt; f(g(x))</code></pre>
<p>The domain of the composite is the domain of <em>g</em> and its codomain is the codomain of <em>f</em>.</p>
<div class="admonition convention">
<p class="admonition-title">Convention</p>
<p>In the body of this document, we shall use the term <em>map</em>, or <em>mapping</em>, as shorthand for "mathematical function" and will mean a q function when we write "function" without a modifier.</p>
</div>
<h3 id="023-natural-numbers">0.2.3 Natural Numbers</h3>
<p>The natural numbers are the basis of computing. It is instructive to derive the natural numbers from the primitive notion of counting.</p>
<ul>
<li>Start with no items.</li>
<li>For any number of counted items, we can count one more, called the <em>successor</em> of that number</li>
</ul>
<p>We all did this on our fingers as children.</p>
<p>Mathematicians prefer symbols.</p>
<ul>
<li>Start with no items, written 0.</li>
<li>For any number of counted items <em>n</em> we can count one more, called the <em>successor</em> of the number and written <em>s(n)</em></li>
</ul>
<p>Thus the natural numbers are built by iteration of counting "one more."</p>
<pre class="highlight"><code class="language-txt">0 s(n) s(s(n)) s(s(s(n))) ‚Ä¶</code></pre>
<p>Writing all those successors can be cumbersome so we give them symbolic names.</p>
<p>0 1 2 3 ‚Ä¶</p>
<p>How do we guarantee that these are the <strong>only</strong> things in our collection? Without such assurance, a forger could add spurious items such as infinity or -1 and pass off the forged collection as the natural numbers.</p>
<h3 id="024-mathematical-induction-and-recursion">0.2.4 Mathematical Induction and Recursion</h3>
<p>The <em>principle of mathematical induction</em> says that the natural numbers comprise the minimal collection satisfying the following rules.</p>
<ul>
<li>The collection contains 0</li>
<li>Whenever <em>n</em> is in the collection so is <em>s(n)</em></li>
</ul>
<p>For those who care, the formal expression of minimality is that given <strong>any</strong> collection satisfying these two properties, there is a unique map from our collection to that collection. The minimality requirement provides the guarantee that any collection satisfying these rules is essentially the same as our naturals ‚Äì no more, no less.</p>
<p>Perhaps you are more familiar with the following equivalent way of stating the principle of mathematical induction: to prove that a property holds for all natural numbers, show that the collection of numbers for which it holds satisfies the above two rules.</p>
<p>Let‚Äôs take stock. As defined above, a natural number has one of two forms:</p>
<ul>
<li>It is 0</li>
<li>Or it is s(n) where n is a natural number previously defined.</li>
</ul>
<p>Thus to define anything on all natural numbers, we must:</p>
<ul>
<li>Define it on 0</li>
<li>For any natural number n on which it is defined, define it on s(n)</li>
</ul>
<p>This is <em>inductive</em> definition. To define a function <em>f</em> on the natural numbers, we follow this prescription.</p>
<ul>
<li>Define the result of <em>f</em> at 0</li>
<li>Assuming <em>f</em> is defined on a natural number n, define it on s(n)</li>
</ul>
<p>An example of such a function is right in front of us: the successor s.</p>
<ul>
<li>s on 0 is s(0)</li>
<li>s on n is s(n)</li>
</ul>
<p>Now we look at a special case of this general inductive style of function definition with an added requirement (in bold).</p>
<ul>
<li>Define the value of <em>f</em> at 0</li>
<li>Assuming <em>f</em> is defined on a natural number n, define it on s(n) <strong>in terms of its value on n</strong>.</li>
</ul>
<p>A function defined in this manner is <em>recursive</em>. At first glance it seems that recursive definition might seriously limit the functions that we can define, but that is not the case.</p>
<h3 id="025-addition">0.2.5 Addition</h3>
<p>What is addition? The key insight is that adding is merely counting "one mores" ‚Äì i.e., counting applications of the successor <em>s</em>. Expressed inductively,</p>
<ul>
<li>Adding 0 applies <em>s</em> no times ‚Äì i.e., returns the original number</li>
<li>Provided we know how to add <em>n</em>, adding <em>s(n)</em> is one more application <em>of s</em></li>
</ul>
<p>Let‚Äôs make addition so described into a recursive function. For an arbitrary natural number <em>m,</em> we define a recursive function <em>add_to_m</em> that counts applications of the successor to <em>m</em>.</p>
<ul>
<li><em>add_to_m</em> on 0 is <em>m</em> ‚Äì i.e., apply <em>s</em> no times</li>
<li><em>add_to_m</em> on <em>s</em>(<em>n</em>) is <em>s</em>(<em>add_to_m</em>(<em>n</em>)) ‚Äì i.e., apply <em>s</em> once more</li>
</ul>
<p>Once you experience the Zen, you will see that we can <strong>define</strong> the customary notation for addition using <em>add_to_m</em><em>.</em>**</p>
<pre class="highlight"><code class="language-txt">   def
m+n = add_to_m(n)</code></pre>
<p>It is an instructive exercise to prove the usual properties of addition. For example, show commutativity ‚Äì which is not immediately obvious.</p>
<pre class="highlight"><code class="language-txt">    ?
n+m = m+n</code></pre>
<p>The proof uses mathematical induction (of course).</p>
<h3 id="026-recursion-restated">0.2.6 Recursion Restated</h3>
<p>As a special case of addition, we observe that <em>n</em> + 1 is <em>s</em>(<em>n</em>). Now we can restate the notion of recursive function definition in the more familiar form.</p>
<ul>
<li>Define <em>f</em> for the base case 0</li>
<li>Express <em>f</em>(<em>n</em>+1) in terms of <em>f</em>(<em>n</em>)</li>
</ul>
<p>It is an interesting exercise left to the reader to prove that this is equivalent to the seemingly more powerful form:</p>
<ul>
<li>Define <em>f</em> for the base case 0</li>
<li>Express <em>f</em>(<em>n</em>+1) in terms of <em>f</em>(0), ‚Ä¶, <em>f</em>(<em>n</em>)</li>
</ul>
<p>This is the form of recursive definition we shall assume in following chapters. We note that the second portion of this prescription ‚Äì i.e., the inductive step ‚Äì gives recursive functions their identifying characteristic. For a non-base input value, the function output involves applications of itself on "lesser" values. Consequently, evaluation involves unwrapping a nested series of such applications until the base case is reached.</p>
<h3 id="027-multiplication">0.2.7 Multiplication</h3>
<p>Having defined addition recursively as counting how many times to apply the successor, we can do the same thing by counting how many times to apply addition. This is multiplication. In words,</p>
<ul>
<li>Multiplying by 0 performs no additions</li>
<li>Provided we know how to multiply by <em>n</em>, multiplying by <em>s(n)</em> is one more addition of <em>n</em></li>
</ul>
<p>We translate this into a recursive function <em>times_m</em>.</p>
<ul>
<li><em>times_m</em> on 0 is the identity for addition-i.e., 0</li>
<li><em>times_m</em> on <em>n</em>+1 is <em>n+times_m(n)</em></li>
</ul>
<p>Incidentally, the fact that multiplication counts how many times to add is why we call multiplication "times" in English and is how the "times" tables we all memorized in elementary school are derived. Again we <strong>define</strong> the customary notation for multiplication using <em>times_m</em>.</p>
<pre class="highlight"><code class="language-txt">    def
m*n = times_m(n)</code></pre>
<h3 id="028-exponentiation">0.2.8 Exponentiation</h3>
<p>Having defined multiplication recursively as counting how many times to apply addition, we repeat the same technique to define exponentiation. Namely, exponentiation counts how many times to apply multiplication. In words,</p>
<ul>
<li>Raising to the power 0 multiplies no times</li>
<li>If we know how to raise to the power <em>n</em>, then raising to the power <em>s(n)</em> is one more multiplication</li>
</ul>
<p>We define the recursive function <em>m_power_of</em> as follows.</p>
<ul>
<li><em>m_power_of</em> on 0 is the identity for multiplication ‚Äì i.e., 1</li>
<li><em>m_power_of</em> on <em>n</em>+1 is <em>m*m_power_of(n)</em></li>
</ul>
<p>Again we <strong>define</strong> the customary notation in terms of the recursive <em>m_power_of.</em></p>
<pre class="highlight"><code class="language-txt">   def
m^n = m_power_of(n)</code></pre>
In summary, we have defined basic arithmetic using only recursion, 0 and "one more." The economy of induction is impressive.
<h3 id="029-lists">0.2.9 Lists</h3>
<p>Lists can also be defined inductively, starting with the empty list and the notion of adding one item to the list.</p>
<ul>
<li>The empty list, written (), is the list with no items</li>
<li>Given a list L of items of some domain together with a value x of that domain, we obtain a new list by appending the value x to the end of the list, written L,x</li>
</ul>
<p>The list constructed by successively appending x<sub>1</sub>, x<sub>2</sub>, ‚Ä¶, x<sub>n</sub> to the empty list is written</p>
<p>(x<sub>1</sub>; x<sub>2</sub>; ‚Ä¶; x<sub>n</sub>)</p>
<p>Since lists are inductively defined, operations on lists can be defined recursively. For example, the <em>count</em> (i.e., length) of a list is defined as follows.</p>
<ul>
<li>The count of the empty list () is 0</li>
<li>Given a list L of count n and an atom x, the count of L,x is 1+count L, which is 1+n</li>
</ul>
<p>As an exercise you can extend the notion of appending a single value to appending one list to another and then prove ‚Äì inductively of course ‚Äì that for two lists L and M,</p>
<p>count(L,M) = count(L) + count(M)</p>
<h3 id="0210-rationals-and-reals">0.2.10 Rationals and Reals</h3>
<p>In everyday usage of mathematics, we implicitly identify things that aren't actually the same. Most common is identifying a natural number ‚Äì e.g. 42 ‚Äì as a rational number or as a real number. But a natural number isn‚Äôt actually a real number; it just plays one on TV.</p>
<p>Indeed, we have seen that natural numbers are obtained by counting "one more" starting from 0. Ignoring signs for the moment, a rational number is an equivalence class of formal quotients <em>a</em>/<em>b</em> of naturals, In plain speak, <em>a</em>/<em>b</em> and <em>c</em>/<em>d</em> are considered the same just when <em>ad</em> = <em>bc</em>. So 2/1 and 4/2 and 6/3, etc. are all considered to be the same. The naturals have a faithful embedding into the rationals in which <em>n</em> is mapped to <em>n</em>/1. This allows us to identify <em>n</em> with (the class of rationals equivalent to) <em>n</em>/1, but they are clearly different mathematical entities.</p>
<p>Similarly, a real number is (in the formulation most of us use) an infinite decimal ‚Äì i.e., an infinite sequence of natural numbers representing place values in powers of 10. Long division converts a rational to its repeating decimal expansion, so there is an embedding of rationals into the reals, but <em>a</em>/<em>b</em> is manifestly <strong>not</strong> an infinite decimal.</p>
<p>The identification of naturals and rationals as reals is normally done without thinking. In fact, some argue vehemently that a natural number <strong>is</strong> a real number. It is not but it can be identified with one.</p>
<p>Another interesting fact of programming life is that normal data types can only represent an insignificant set of real numbers. Typically reals are represented by single or double precision floating point values. Since these are limited to at most 16 decimal digits, they are clearly rationals, and a pretty limited set of rationals at that. Even "unlimited" decimal values are still rational, as any computer has finite storage. The way to represent a real properly is with a lazy sequence that presents digits "on demand."</p>
<p>The moral of the story is that we can normally go about our programming day without worrying about these distinctions. But there are situations where they matter.</p>
                


                
              
              
                


              
            </article>
            
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))for(var set of document.querySelectorAll("[data-tabs]")){var labels=set.querySelectorAll(":scope > label");e:for(var tab of tabs)for(var label of labels)if(label.innerText.trim()===tab){var input=label.previousElementSibling;input.checked=!0;break e}}</script>

          </div>
        </div>
        
          
        
      
                </div>
            </section>
        
            <section class="chapter" id="chapter-1">
                <div class="chapter-header">
                    <h1 class="chapter-title">1. Q Shock and Awe¬∂</h1>
                    <div class="chapter-meta">
                        <span>üìñ Source: <a href="https://code.kx.com/q4m3/1_Q_Shock_and_Awe/">https://code.kx.com/q4m3/1_Q_Shock_and_Awe/</a></span>
                        <span>üìù 11577 words</span>
                        
                    </div>
                </div>
                <div class="chapter-content">
                    
        <div class="md-main__inner md-grid">
          
            
              
              
            
            
              
              
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                
                <h1 id="1-q-shock-and-awe">1. Q Shock and Awe</h1>
<p>The purpose of this chapter is to provide a whirlwind tour of some highpoints of q. We don't expect everyone to follow everything the first time through but we do expect that you will be impressed by the power and economy of q. The examples here should motivate careful reading of the following chapters. Once you complete the main text, come back to this chapter and you'll breeze through it.</p>
<h2 id="11-starting-q">1.1 Starting q</h2>
<p>Your installation of q should have placed the q executable in <code>$HOME/q</code> (or <code>$QHOME</code>) on Unix-based systems, or in the <code>q</code> directory on the <code>C:</code> drive on Windows.</p>
<p>For Windows, start a q session by typing <code>q</code> on the command line; for Linux-based systems use <code>rlwrap q</code> so that you will have command line recall. You should see a new q session with the Kx Systems copyright notice followed by the q prompt indicated by a leading <code>q)</code> on the command line. This is the <em>q console</em>. Type <code>6*7</code> and press Enter or Return to see the result.</p>
<pre class="highlight"><code class="language-q">q)6*7
42
q)‚òê</code></pre>
<p>Here the ‚òê represents the cursor awaiting your next input.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In this document, sample q console sessions will always be displayed in fixed-pitch type with shaded background. As a pedagogical device, in many q snippets we suppress the console response to an entered q expression, replacing it with an underscore. This means that you, the serious student, are expected to enter this expression into your own q session and see the result.</p>
</div>
<pre class="highlight"><code class="language-q">q)"c"$0x57656c6c20646f6e6521
_</code></pre>
<p>You did do this, didn‚Äôt you? <mark>This <strong>is</strong> a tutorial</mark>.</p>
<h2 id="12-variables">1.2 Variables</h2>
<p>In q, as in most languages that allow mutable state, a "variable" should properly be called an "assignable". (See Mathematical Refresher above for a discussion). Nevertheless, a <em>variable</em> in q is a name together with associated storage that holds whatever value has been most recently assigned to the variable. As a consolation, at least q does not misuse <code>=</code> for assignment, as do many languages; in q <code>=</code> actually means "test for equality."</p>
<p>Declaring a variable and assigning its value are done in a single step with the operator <code>:</code> which is called <em>amend</em> and is read "is assigned" or "gets." Here is how to create and assign variable <code>a</code> with integer value 42.</p>
<pre class="highlight"><code class="language-q">q)a:42
q)_</code></pre>
<p>When you entered this in your q session, you noted that nothing is echoed to the console. In order to see that <code>a</code> has indeed been assigned, simply enter the variable.</p>
<pre class="highlight"><code class="language-q">q)a
42</code></pre>
<p>A variable name must start with an alphabetic character, which can be followed by alpha, numeric or underscore.</p>
<p><strong>Naming Style Recommendations</strong></p>
<ol>
<li>
<p>Choose a name long enough to make the purpose of the entity evident, but no longer. The purpose of a name is to communicate to a reader of the code at another time ‚Äì perhaps even you. Long names may not make code easier to read. For example, <code>checkDisk</code> is clearer than <code>cd</code> or <code>chk</code> but is no less clear than <code>checkDiskForFileConsistency</code>.</p>
</li>
<li>
<p>Use verbs for function names; use nouns for data.</p>
</li>
<li>
<p>Be consistent in your use of abbreviations. Be mindful that even "obvious" abbreviations may be opaque to readers whose native language is different than yours.</p>
</li>
<li>
<p>Be consistent in your use of capitalization, such as initial caps, camel casing, etc. Pick a style and stick to it.</p>
</li>
<li>
<p>Use contexts for name spacing functions.</p>
</li>
<li>
<p>Do not use names such as <code>int</code>, <code>float</code> or other words that have meaning in q. While not reserved, they carry special meaning when used as arguments for certain q operators.</p>
</li>
<li>
<p>Accomplished q programmers avoid using the underscore character in q names. If you insist on using underscore in names, do not use it as the last character. Expressions involving the built-in <code>_</code> operator and names with underscore will be difficult to read.</p>
</li>
</ol>
<h2 id="13-whitespace">1.3 Whitespace</h2>
<p>In general, q permits, but does not require, whitespace around operators, separators, brackets, braces, etc. You could also write the above expression as</p>
<pre class="highlight"><code class="language-q">a : 42</code></pre>
<p>or,</p>
<pre class="highlight"><code class="language-q">a: 42</code></pre>
<div class="admonition tip">
<p class="admonition-title">Accomplished q programmers view whitespace around operators as training wheels on a bicycle.</p>
</div>
<p>Because the q gods prefer compact code, you will see programs with no superfluous whitespace‚Ä¶ none, zilch, zip, nada. In order to help you get accustomed to this terseness, we use whitespace only in juxtaposition and after semi-colon and comma separators. You should feel free to add whitespace for readability where it is permitted, but be consistent in its use or omission. We will point out where whitespace is required or forbidden.</p>
<h2 id="14-the-q-console">1.4 The Q Console</h2>
<p>The q console evaluates a q expression that you enter and echoes the result on the following line. An exception to this is the assignment operation ‚Äì as noted above ‚Äì that has a return value, even though the console does not echo it. You may wonder why. This is simply a q console design choice to avoid cluttering the display.</p>
<div class="admonition note">
<p class="admonition-title">To obtain official console display of any q value, apply the built-in function <code>show</code> to it.</p>
<pre><code class="language-q">
q)show a:42
42
</code></pre>
</div>
<h2 id="15-comments">1.5 Comments</h2>
<p>The forward-slash character <code>/</code> indicates the beginning of a comment. Actually, it instructs the interpreter to ignore everything from it to the end of the line.</p>
<div class="admonition tip">
<p class="admonition-title">At least one whitespace character must separate <code>/</code> intended to begin a comment from any text to the left of it on a line.</p>
</div>
<p>In the following example, no definition of <code>c</code> is seen by the interpreter, so an error occurs.</p>
<pre class="highlight"><code class="language-q">q)b:1+a:42 / nothing here counts c:6*7
q)c
'c</code></pre>
<p>Notice the succinct (ahem) format of q errors: a single vertical quote (called "tick" in q-speak) followed by a terse error message. In this case, the error should be interpreted as "Error: c is not recognized."</p>
<p>The following generates an even more succinct error.</p>
<pre class="highlight"><code class="language-q">q)a:42/ intended to be a comment
'</code></pre>
<div class="admonition tip">
<p class="admonition-title">Coding Style</p>
<p>The q gods have no need for explanatory error messages or comments since their q code is perfect and self-documenting. Even experienced mortals spend hours poring over cryptic q error messages such as the ones above. Moreover, many mortals eschew comments in misanthropic coding macho. Don‚Äôt.</p>
</div>
<div class="admonition note">
<p class="admonition-title">V3.5 introduced debugging and more informative error displays. <em>[Ed.]</em></p>
</div>
<h2 id="16-assignment">1.6 Assignment</h2>
<p>A variable is not explicitly declared or typed. Instead, its assigned value determines the variable type. In our example, the expression to the right of the assignment is syntactically an integer value, so the name <code>a</code> is associated with a value of type long integer. It is permissible to reassign a variable with a value of different type. Once this is done, the name will reflect the type of its newly assigned value. Much more about types in Chapter 2.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Dynamic typing combined with mutable variables is flexible but also dangerous. You can unintentionally change the type of a variable with a wayward assignment that might crash your program much later. Or you can inadvertently reuse a variable name and wipe out any data in the variable. An undetected typo can result in data being sent to a black hole. Be careful to enter variable names correctly.</p>
</div>
<p>Many traditional languages permit only a variable name to the left of an assignment. In q an assignment carries the value being assigned and can be used as part of a larger expression. So we find,</p>
<pre class="highlight"><code class="language-q">q)1+a:42
43</code></pre>
<p>In the following example, the variable <code>a</code> is <strong>not</strong> referenced after it is assigned. Instead, the value of the assignment is propagated onward ‚Äì i.e., to the left.</p>
<pre class="highlight"><code class="language-q">q)b:1+a:42
q)b
43</code></pre>
<h2 id="17-order-of-evaluation">1.7 Order of Evaluation</h2>
<p>The interpreter evaluates the above specification of <code>b</code> from right-to-left (more on this in Chapter 4). If it were verbose, the interpreter might say:</p>
<blockquote>
<p>The integer 42 is assigned to a variable named <code>a</code>, then the result of the assignment, namely 42, is added to the integer 1, then this result is assigned to a variable named <code>b</code>. </p>
</blockquote>
<p>Because the interpreter always evaluates expressions right-to-left, programmers can safely read q expressions left-to-right,</p>
<blockquote>
<p>The variable <code>b</code> gets the value of the integer 1 plus the value assigned to the variable <code>a</code>, which gets the integer 42. </p>
</blockquote>
<p>This is exactly as in mathematics where we would read <em>f(g(x))</em> as "f of g of x" even though <em>g</em> is evaluated first and the result passed into <em>f</em>. We just dispense with the parentheses.</p>
<p><strong>Recommendations on Assignment Style</strong></p>
<ul>
<li>The ability to chain evaluation of expressions permits a single line of q code to perform the work of an entire verbose program. In general this is acceptable (even good) q style when not taken to the extreme with extremely long wrapped lines or nested sub expressions.</li>
<li>Intra-line assignments, as above, can simplify code provided they are few and are referenced only within the line of creation.</li>
<li>It is not bad form to make one assignment per line, provided you don't end up with one operation per line.</li>
<li>Wannabe q gods carry terseness to the extreme, which quickly leads to write-only code.</li>
</ul>
<h2 id="18-data-types-101">1.8 Data Types 101</h2>
<p>There are q data types to cover nearly all needs but a few basic types are used most frequently. In q3.0 and above, the basic integer type, called <em>long</em>, is a 64-bit signed integer. If you write a literal integer as in the snippets above, q creates a 64-bit signed integer value.</p>
<pre class="highlight"><code class="language-q">q)42
_</code></pre>
<p>The basic floating point type in q is called <em>float</em>, often known as a "double" in many languages. This is an 8-byte value conforming to the IEEE floating-point specification.</p>
<pre class="highlight"><code class="language-q">q)98.6
_</code></pre>
<p>Arithmetic operations on integer and float values are pretty much as expected except for division, which is written as <code>%</code> since <code>/</code> has been preempted for comments (as well as other uses). Sorry, that's just the way it is. Also note that division <strong>always</strong> results in a float.</p>
<pre class="highlight"><code class="language-q">q)2+3
5
q)2.2*3.0
6.6
q)4-2
2
q)4%2
2f</code></pre>
<p>Boolean values in q are stored in a single byte and are denoted as the binary values they really are with an explicit type suffix <code>b</code>. One way to generate boolean values is to test for equality.</p>
<pre class="highlight"><code class="language-q">q)42=40+2
1b
q)42=43
_</code></pre>
<p>The two most useful temporal types are <em>date</em> and <em>timespan</em>; both represent integral counts. Under the covers, a date is the number of days since the millennium, positive for post and negative for pre.</p>
<pre class="highlight"><code class="language-q">q)2000.01.01 / this is actually 0
_
q)2014.11.19 / this is actually 5436
_
q)1999.12.31 / this is actually -1
_</code></pre>
<p>Similarly, a time value is represented by a timespan, which is a (long) integer count of the number of nanoseconds since midnight. It is denoted as,</p>
<pre class="highlight"><code class="language-q">q)12:00:00.000000000 / this is noon
_</code></pre>
<p>One interesting and useful feature of q temporal values is that, as integral values under the covers, they naturally participate in arithmetic. For example, to advance a date five days, add 5.</p>
<pre class="highlight"><code class="language-q">q)2000.01.01+5
_</code></pre>
<p>Or to advance a time by one microsecond (i.e., 1000 nanoseconds) add 1000.</p>
<pre class="highlight"><code class="language-q">q)12:00:00.000000000+1000
_</code></pre>
<p>Or to verify that temporal values are indeed their underlying values, test for equality.</p>
<pre class="highlight"><code class="language-q">q)2000.01.01=0
_
q)12:00:00.000000000=12*60*60*1000000000
_</code></pre>
<p>The treatment of textual data in q is a bit complicated in order to provide optimum flexibility and performance. For now, we will focus on symbols, which derive from their namesake in Scheme and are akin to <code>VARCHAR</code> in SQL or strings in other languages. They are <strong>not</strong> what q calls strings!</p>
<p>Think of symbols as wannabe names: all q names are symbols but not all symbols are names. A symbol is atomic, meaning that it is viewed as an indivisible entity (although we shall see later how to expose the characters inside it).</p>
<p>Symbols are denoted by a leading back-quote (called "back tick" in q-speak) followed by characters. Symbols without embedded blanks or other special characters can be entered literally into the console.</p>
<pre class="highlight"><code class="language-q">q)`aapl
_
q)`jab
_
q)`thisisareallylongsymbol
_</code></pre>
<p>Since symbols are atoms, any two can be tested for equality.</p>
<pre class="highlight"><code class="language-q">q)`aapl=`apl
_</code></pre>
<h2 id="19-lists-101">1.9 Lists 101</h2>
<p>The fundamental q data structure is a list, which is an ordered collection of items sequenced from left to right. The notation for a general list encloses items with <code>(</code> and <code>)</code> and uses <code>;</code> as separator. Spaces after the semi-colons are optional but can improve readability.</p>
<pre class="highlight"><code class="language-q">q)(1; 1.2; `one)
_</code></pre>
<p>A few observations on lists.</p>
<ul>
<li>A list can contain items of different type; this usually requires wrapping the values in a variant type in other languages. That being said, it is best to avoid mixed types in lists, as their processing is slower than homogenous lists of atoms.</li>
<li>Assuming you entered the above snippet, you have noticed that the console echoes the items of a general list one item per line.</li>
<li>In contrast to most functional languages, lists need not be built up by "cons"-ing one item at a time, although they can be. Nor are they stored as singly-linked lists under the covers.</li>
</ul>
<p>In the case of a homogenous list of atoms, called a <em>simple list</em>, q adopts a simplified format for both storage and display. The parentheses and semicolons are dropped. For example, a list of underlying numeric type separates its items with a space.</p>
<pre class="highlight"><code class="language-q">q)(1; 2; 3)
1 2 3
q)(1.2; 2.2; 3.3)
-
q)(2000.01.01; 2000.01.02; 2001.01.03)
-</code></pre>
<p>A simple list of booleans is juxtaposed with no spaces and has a trailing <code>b</code> type indicator.</p>
<pre class="highlight"><code class="language-q">q)(1b; 0b; 1b)
101b</code></pre>
<p>A simple list of symbols is displayed with no separating spaces.</p>
<pre class="highlight"><code class="language-q">q)(`one; `two; `three)
`one`two`three</code></pre>
<p>Homogenous lists of atoms can be entered in either general or simplified form. Regardless of how they are created, q recognizes a list of homogenous atoms dynamically and converts it to a simple list.</p>
<p>Next we explore some basic operations to construct and manipulate lists. The most fundamental is <code>til</code>, which takes a non-negative integer <em>n</em> and returns the first <em>n</em> integers starting at 0 (<em>n</em> itself is <strong>not</strong> included in the result).</p>
<pre class="highlight"><code class="language-q">q)til 10
0 1 2 3 4 5 6 7 8 9</code></pre>
<p>We obtain the first 10 integers starting at 1 by adding 1 to the previous result. Be mindful that q always evaluates expressions from right to left and that operations work on vectors whenever possible.</p>
<pre class="highlight"><code class="language-q">q)1+til 10
1 2 3 4 5 6 7 8 9 10</code></pre>
<p>Similarly, we obtain the first 10 even numbers and the first ten odd numbers.</p>
<pre class="highlight"><code class="language-q">q)2*til 10
_
q)1+2*til 10
_</code></pre>
<p>Finally, we obtain the first 10 even numbers starting at 42.</p>
<pre class="highlight"><code class="language-q">q)42+2*til 10
_</code></pre>
<p>Another frequently used list primitive is Join <code>,</code> that returns the list obtained by concatenating its right operand to its left operand.</p>
<pre class="highlight"><code class="language-q">q)1 2 3,4 5
1 2 3 4 5
q)1 2 3,100
_
q)0,1 2 3
_</code></pre>
<p>To extract items from the front or back of a list, use the Take operator <code>#</code>. Positive argument means take from the front, negative from the back.</p>
<pre class="highlight"><code class="language-q">q)2#til 10
0 1
q)-2#til 10
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Applying <code>#</code> always results in a list.</p>
<p>In particular, the idiom <code>0#</code> returns an empty list of the same type as the first item in its argument. Using an atom argument is a succinct way to create a typed empty list of the type of the atom.</p>
<pre><code class="language-q">
q)0#1 2 3
`long$()
q)0#0
`long$()
q)0#`
`symbol$()
</code></pre>
</div>
<p>Should you extract more items than there are in the list, <code>#</code> restarts at the beginning and continues extracting. It does this until the specified number of items is reached.</p>
<pre class="highlight"><code class="language-q">q)5#1 2 3
1 2 3 1 2</code></pre>
<p>In particular, if you apply <code>#</code> to an atom, it will continue drawing that single atom until it has the specified number of copies. This is a succinct idiom to replicate an atom to a list of specified length.</p>
<pre class="highlight"><code class="language-q">q)5#42
42 42 42 42 42</code></pre>
<p>As with atoms, a list can be assigned to a variable.</p>
<pre class="highlight"><code class="language-q">q)L:10 20 30</code></pre>
<p>The items of a list can be accessed via indexing, which uses square brackets and is relative to 0.</p>
<pre class="highlight"><code class="language-q">q)L[0]
10
q)L[1]
_
q)L[2]
_</code></pre>
<h2 id="110-functions-101">1.10 Functions 101</h2>
<p>All built-in q operators and keywords are functions. The main differences between q‚Äôs functions and the ones we mortals can write are:</p>
<ul>
<li>The built-ins are written and optimized in one of the underlying languages k or C.</li>
<li>Binary q functions can be used with infix notation ‚Äì i.e., as operators ‚Äì whereas ours must be used in prefix form. <!-- FIXME All q OPERATORS can be used with infix notation ‚Äì¬†but not all inbuilt functions, eg max, avg --></li>
</ul>
<p>Functions in q correspond to ‚Äúlambda expressions‚Äù or ‚Äúanonymous functions‚Äù in other languages. This means that a function is a first-class value just like a long or float value ‚Äì i.e., it acquires a name only once it is assigned to a variable.</p>
<p>Conceptually, a q function is a sequence of steps that produces an output result from an input value. Since q is not purely functional, these rules can interact with the world by reaching outside the context of the function. Such actions are called <em>side effects</em> and should be carefully controlled.</p>
<p>Function definition is delimited by matching curly braces <code>{</code> and <code>}</code>. Immediately after the opening brace, the <em>formal parameters</em> are names enclosed in square brackets <code>[</code> and <code>]</code> and separated by semi-colons. These parameters presumably appear in the <em>body</em> of the function, which follows the formal parameters and is a succession of expressions sequenced by semi-colons.</p>
<p>Following is a simple function that returns the square of its input. On the next line we assign the same function to the variable <code>sq</code>. The whitespace is optional.</p>
<pre class="highlight"><code class="language-q">q){[x] x*x}
_
q)sq:{[x] x*x}
_</code></pre>
<p>Here is a function that takes two input values and returns the sum of their squares.</p>
<pre class="highlight"><code class="language-q">q){[x;y] a:x*x; b:y*y; a+b}
_
q)pyth:{[x;y] a:x*x; b:y*y; a+b}
_</code></pre>
<p>To apply a function to arguments, follow it (or its name, if it has been assigned to a variable) by a list of values enclosed in square brackets and separated by semi-colons. This causes the argument expression to be evaluated first, then the expressions in the body of the function to be evaluated sequentially by substituting each resulting argument for every occurrence of the corresponding formal parameter. Normally the value of the final expression is returned as the output value of the function.</p>
<p>Here are the previous functions applied to arguments.</p>
<pre class="highlight"><code class="language-q">q){[x] x*x}[5]
25
q)sq[5]
_
q){[x;y] a:x*x; b:y*y; a+b}[3;4]
25
q)pyth[3;4]
_</code></pre>
<p>The variables <code>a</code> and <code>b</code> appearing in the body of the last function above are <em>local</em> ‚Äì i.e., they are created and exist only for the duration of an application.</p>
<p>It is common in mathematics to use function parameters <em>x</em>, <em>y</em>, or <em>z</em>. If you are content with these names (in the belief that descriptive names provide no useful information to the poor soul reading your code), you can omit their declaration and q will understand that you mean the implicit parameters <em>x</em>, <em>y</em>, and <em>z</em> <strong>in that order</strong>.</p>
<pre class="highlight"><code class="language-q">q){x*x}[5]
25
q){a:x*x; b:y*y; a+b}[3;4]
25</code></pre>
<p>This is about as pithy as it gets for function definition and application. Well, not quite. In q, as in most functional languages, we don't need no stinkin‚Äô brackets for application of a unary function ‚Äì i.e., with one parameter. Simply separate the function from its argument by whitespace. This is called function <em>prefix syntax</em>.</p>
<pre class="highlight"><code class="language-q">q){x*x} 5
_
q)f:{x*x}
q)f 5
_</code></pre>
<p>If you are new to functional programming this may take some getting used to, but the reduction of punctuation ‚Äúnoise‚Äù in your code is worth it.</p>
<h2 id="111-functions-on-lists-101">1.11 Functions on Lists 101</h2>
<p>Because q is a vector language, most of the built-in operators work on lists out of the box. In q-speak, such functions are <em>atomic</em>, meaning they recursively burrow into a complex data structure until arriving at atoms and then perform their operation. In particular, an atomic function operates on lists by application to the individual items. For example, plain addition adds an atom to a list, a list to an atom or two lists of the same length.</p>
<pre class="highlight"><code class="language-q">q)42+100 200 300
142 242 342
q)100 200 300+42
_
q)100 200 300+1 2 3
_</code></pre>
<p>Perhaps surprisingly, this is also true of equality and comparison operators. (Recall the notation for simple boolean lists).</p>
<pre class="highlight"><code class="language-q">q)100=99 100 101
010b
q)100 100 100=100 101 102
_
q)100&lt;99 100 101
_</code></pre>
<p>Suppose that instead of adding things pair-wise, we want to add all the items across a list. The way this is done in functional languages is with <em>higher order functions</em>, or as they are called in q, <a href="https://code.kx.com/q/ref/iterators/"><em>iterators</em></a>. Regardless of the terminology, the idea is to take the operation of a function and produce a closely related function having the same ‚Äúessence‚Äù but applied in a different manner.</p>
<p>You met the concept of higher-order functions in elementary calculus, perhaps without being properly introduced. The derivative and integral are actually higher-order functions that take a function and produce a related function. Behind all the delta-epsilon mumbo-jumbo, the derivative of a given function is a function that represents the instantaneous behavior of the original. The (indefinite) integral is the anti-derivative ‚Äì i.e., a function whose instantaneous behavior is that of the given function.</p>
<p>In the case of adding the values in a list, we need a higher-order function that takes addition and turns it into a function that works across the list. In functional programming this is called a <em>fold</em> ; in q it is <a href="https://code.kx.com/q/ref/accumulators/">Over</a>. The technique is to accumulate the result across the list recursively. (See <a href="https://code.kx.com/q4m3/0_Overview/#02-mathematics-refresher">¬ß0.2 Mathematical Refresher</a> for more on recursion). Specifically, begin with an initial value in the accumulator and then sequentially add each list item into the previous value of the accumulator until the end the list. Upon completion, the accumulator holds the desired result.</p>
<p>If you are new to functional programming this may seem more complicated than just creating a <em>for</em> loop but that‚Äôs only because you have been brainwashed to think that constructing a for loop is ‚Äúreal‚Äù programming. Watch how easy it is to do in q. In words, we tell q to start with the initial value of 0 in the accumulator and then modify <code>+</code> with the iterator <code>/</code> so that it adds across the list.</p>
<pre class="highlight"><code class="language-q">q)0 +/ 1 2 3 4 5
15
q)0 +/ 1+til 100
_</code></pre>
<p>There is nothing special about built-in operator <code>+</code> ‚Äì we can use any operator or even our own function.</p>
<pre class="highlight"><code class="language-q">q)0 {x+y}/ 1 2 3 4 5
_
q)0 {x+y}/ 1+til 100
_</code></pre>
<p>In this situation we don't really need the flexibility to specify the initial value of the accumulator. It suffices to start with the first item of the list and proceed across the rest of the list. There is an even simpler form for this case.</p>
<pre class="highlight"><code class="language-q">q)(+/) 1 2 3 4 5
_
q)(+/) 1+til 100
_</code></pre>
<p>If you are new to functional programming, you may think, ‚ÄúBig deal, I write <em>for</em> loops in my sleep.‚Äù Granted. But the advantage of the higher-order function approach is that there is no chance of being off by one in the loop counter or accidentally running off the end of a data structure. More importantly, you can focus on <em>what</em> you want done without the irrelevant scaffolding of <em>how</em> to set up control structures. This is called <em>declarative programming</em>.</p>
<p>What else can we do with our newfound iterator? Change addition to multiplication for factorial.</p>
<pre class="highlight"><code class="language-q">q)(*/) 1+til 10
3628800</code></pre>
<p>The fun isn‚Äôt limited to arithmetic primitives. We introduce <code>|</code>, which returns the larger of its operands and <code>&amp;</code>, which returns the smaller of its operands.</p>
<pre class="highlight"><code class="language-q">q)42|98
98
q)42&amp;98
_</code></pre>
<p>Use <code>|</code> or <code>&amp;</code> with Over and you have <em>maximum</em> or <em>minimum</em>.</p>
<pre class="highlight"><code class="language-q">q)(|/) 20 10 40 30
40
q)(&amp;/) 20 10 40 30
_</code></pre>
<p>Some applications of <code>/</code> are so common that they have their own names.</p>
<pre class="highlight"><code class="language-q">q)sum 1+til 10 / this is +/
55
q)prd 1+til 10 / this is */ -- note missing "o"
_
q)max 20 10 40 30 / this is |/
_
q)min 20 10 40 30 / this is &amp;/
_</code></pre>
<p>At this point the <code>/</code> pattern should be clear: it takes a given function and produces a new function that accumulates across the original list, producing a single result. In particular, <code>/</code> converts a binary function to a unary <em>aggregate</em> function ‚Äì i.e., one that collapses a list to an atom.</p>
<p>We record one more example of <code>/</code> for later reference. Recall from the previous section that applying the operator <code>#</code> to an atom produces a list of copies. Composing this with <code>*/</code> we get a multiplicative implementation of raising to a power without resorting to floating-point exponential.</p>
<pre class="highlight"><code class="language-q">q)(*/) 2#1.4142135623730949
1.9999999999999996
q)n:5
q)(*/) n#10
100000</code></pre>
<p>The higher-order function sibling to Over is Scan, written <code>\</code>. The process of Scan is the same as that of Over with one difference: instead of returning only the final result of the accumulation, it returns all intermediate values.</p>
<pre class="highlight"><code class="language-q">q)(+\) 1+til 10
1 3 6 10 15 21 28 36 45 55
q)(*\) 1+til 10
_
q)(|\) 20 10 40 30
20 20 40 40
q)(&amp;\) 20 10 40 30
_</code></pre>
<p>Scan converts a binary function to a unary <em>uniform function</em> ‚Äì i.e., one that returns a list of the same length as the input.</p>
<p>As with Over, common applications of Scan have their own names.</p>
<pre class="highlight"><code class="language-q">q)sums 1+til 10 / this is +\
_
q)prds 1+til 10 / this is *\ / note missing 'o'
_
q)maxs 20 10 40 30 / this is |\
_
q)mins 20 10 40 30 / this is &amp;\
_</code></pre>
<h2 id="112-example-fibonacci-numbers">1.12 Example: Fibonacci Numbers</h2>
<p>We define the Fibonacci numbers recursively.</p>
<ul>
<li>Base case: the initial sequence is the list <code>1 1</code></li>
<li>Inductive step: given a list of Fibonacci numbers, the next value of the sequence appends the sum of its two last items.</li>
</ul>
<p>We have the basic ingredients to express this in q. Start with the base case <code>F0</code>.</p>
<pre class="highlight"><code class="language-q">q)F0:1 1
q)-2#F0
_
q)sum -2#F0
_
q)F0,sum -2#F0
_</code></pre>
<p>Notice that read from right-to-left, the last expression exactly restates the definition of the Fibonacci term: ‚Äútake the last two elements of the sequence, sum them and append the result to the sequence.‚Äù This is declarative programming ‚Äì say ‚Äúwhat‚Äù to do not ‚Äúhow‚Äù to implement it.</p>
<p>We abstract this expression into a function that appends the next item at an arbitrary point in the sequence.</p>
<pre class="highlight"><code class="language-q">q){x,sum -2#x}
_</code></pre>
<p>Let‚Äôs take it for a test drive on the first few terms.</p>
<pre class="highlight"><code class="language-q">q){x,sum -2#x}[1 1]
_
q){x,sum -2#x}[1 1 2]
_</code></pre>
<p>Wouldn‚Äôt it be nice if q had a higher-order function that applies a recursive function a specified number of times, starting with the base case? Conveniently, there is an <a href="https://code.kx.com/q/ref/accumulators/#do">overload of our friend <code>/</code></a> that does exactly this. Specify the base case and the number of times to iterate the recursion and it‚Äôs done.</p>
<pre class="highlight"><code class="language-q">q)10 {x,sum -2#x}/ 1 1
1 1 2 3 5 8 13 21 34 55 89 144</code></pre>
<h2 id="113-example-newtons-method-for-nth-roots">1.13 Example: Newton‚Äôs Method for n<sup>th</sup> Roots</h2>
<p>You may recall from elementary calculus the simple and powerful technique for computing roots of functions, called the Newton-Raphson method. (It actually bears little superficial resemblance to what Newton himself originally developed). The idea is to start with an initial guess that is not too far from the actual root. Then determine the tangent to the graph over that point and project the tangent line to the x-axis to obtain the next approximation. Repeat this process until the result converges within the desired tolerance.</p>
<p>We formulate this as a recursive algorithm for successive approximation.</p>
<ul>
<li>Base case: a reasonable initial value</li>
<li>Inductive step: Given <em>x<sub>n</sub></em>, the n+1<sup>st</sup> approximation is: <em>x<sub>n</sub> ‚Äì f(x<sub>n</sub>) / f'(x<sub>n</sub>)</em></li>
</ul>
<p>Let‚Äôs use this procedure to compute the square root of 2. The function whose zero we need to find is <em>f(x) = x<sup>2</sup> - 2</em>. The formula for successive approximation involves the derivative of <em>f</em>, which is <em>f'(x) = 2*x</em>.</p>
<p>Given that we know that there is a square root of 2 between 1 and 2 due to the sign change of <em>f</em>, we start with 1.0 as the base case x0. Then the first approximation is,</p>
<pre class="highlight"><code class="language-q">q)x0:1.0
q)x0-((x0*x0)-2)%2*x0
1.5</code></pre>
<p>We abstract this expression to a function that computes the n+1<sup>st</sup> approximation in terms of xn</p>
<pre class="highlight"><code class="language-q">q){[xn] xn-((xn*xn)-2)%2*xn}
_</code></pre>
<p>Now use it to run the first two iterations.</p>
<pre class="highlight"><code class="language-q">q){[xn] xn-((xn*xn)-2)%2*xn}[1.0]
_
q){[xn] xn-((xn*xn)-2)%2*xn}[1.5]
_</code></pre>
<p>Observe in your console session that this looks promising for convergence to the correct answer.</p>
<p>Wouldn't it be nice of q had a higher-order function to apply a function recursively, starting at the base case, until the output converges? You won't be surprised that there is <a href="https://code.kx.com/q/ref/accumulators/#converge">another overload of our friend Over</a> that does exactly this. Just specify the base case and q iterates until the result converges within the system comparison tolerance (as of this writing ‚Äì Sep 2015 ‚Äì that tolerance is 10<sup>-14</sup>)</p>
<pre class="highlight"><code class="language-q">q){[xn] xn-((xn*xn)-2)%2*xn}/[1.5]
1.414214</code></pre>
<p>To witness the convergence, do two things. First, set the floating point display to maximum.</p>
<pre class="highlight"><code class="language-q">q)\P 0 / note upper case P</code></pre>
<div class="admonition tip">
<p class="admonition-title">This displays all digits of the underlying binary representation, including the 17<sup>th</sup> digit, which is usually schmutz.</p>
</div>
<p>Second, switch the iterator from Over to Scan so that we can see the intermediate results.</p>
<pre class="highlight"><code class="language-q">q){[xn] xn-((xn*xn)-2)%2*xn}\[1.0]
_</code></pre>
<p>As your console display shows, that is pretty fast convergence.</p>
<p>Why limit ourselves to the square root of 2? Abstracting the constant 2 into a parameter <em>c</em> in the function <em>f</em>, the successive approximation function becomes,</p>
<pre class="highlight"><code class="language-q">q){[c; xn] xn-((xn*xn)-c)%2*xn}
_</code></pre>
<p>At this point we use a feature, related to <em>currying</em> in functional programming, called <em>projection</em> in q, in which we only partially supply arguments to a function. The result is a function of the remaining, un-specified parameters. We indicate partial application by omitting the unspecified arguments. In our case, we specify the constant c as 2.0, leaving a unary function of the remaining variable <code>xn</code>.</p>
<pre class="highlight"><code class="language-q">q){[c; xn] xn-((xn*xn)-c)%2*xn}[2.0;]
_</code></pre>
<p>Since this is solely a function of <code>xn</code>, we can apply it recursively to the base case until it converges to obtain the same result as the original square root function.</p>
<pre class="highlight"><code class="language-q">q){[c; xn] xn-((xn*xn)-c)%2*xn}[2.0;]/[1.0]
_</code></pre>
<p>But now we are free to choose any (reasonable) value for <em>c</em>. For example, to calculate the square root of 3.0.</p>
<pre class="highlight"><code class="language-q">q){[c; xn] xn-((xn*xn)-c)%2*xn}[3.0;]/[1.0]
_</code></pre>
<p>Intoxicated with the power of function abstraction and recursion, why restrict ourselves to square roots? We abstract once more, turning the power into a parameter <em>p</em>. The new expression for the successive approximation has a p<sup>th</sup> power in the numerator and an p-1<sup>st</sup> power in the denominator, but we already know how to calculate these.</p>
<pre class="highlight"><code class="language-q">q){[p; c; xn] xn-(((*/)p#xn)-c)%p*(*/)(p-1)#xn}
_</code></pre>
<p>Supplying <em>p</em> and <em>c</em> (only) leaves a function solely of <code>xn</code>, which we can once again iterate on the base case until convergence. We reproduce the previous case of the square root of 3.0; then we calculate the fifth root of 7.</p>
<pre class="highlight"><code class="language-q">q){[p; c; xn] xn-(((*/)p#xn)-c)%p*(*/)(p-1)#xn}[2; 3.0;]/[1.0]
_
q){[p; c; xn] xn-(((*/)p#xn)-c)%p*(*/)(p-1)#xn}[5; 7.0;]/[1.0]
_</code></pre>
<p>It is amazing what can be done in a single line of code when you strip out unnecessary programming frou-frou. Perhaps this is intimidating to the qbie, but now that you have taken the blue pill, you will feel right as rain.</p>
<h2 id="114-example-fifo-allocation">1.14 Example: FIFO Allocation</h2>
<p>In the finance industry, one needs to fill a sell order from a list of matching buys in a FIFO (first in, first out) fashion. Although we state this scenario in terms of buys and sells, it applies equally to general FIFO allocation. We begin with the buys represented as a (time-ordered) list of floats, and a single float sell.</p>
<pre class="highlight"><code class="language-q">q)buys:2 1 4 3 5 4f
q)sell:12f</code></pre>
<p>The objective is to draw successively from the buys until we have exactly filled the sell, then stop. In our case the result we are seeking is,</p>
<pre class="highlight"><code class="language-q">q)allocation
2 1 4 3 2 0</code></pre>
<p>The insight is to realize that the cumulative sum of the allocations reaches the sell amount and then levels off: this is an equivalent statement of what it means to do FIFO allocation.</p>
<pre class="highlight"><code class="language-q">q)sums allocation
2 3 7 10 12 12</code></pre>
<p>We realize that the cumulative sum of buys is the total amount available for allocation at each step.</p>
<pre class="highlight"><code class="language-q">q)sums buys
2 3 7 10 15 19f</code></pre>
<p>To make this sequence level off at the sell amount, simply use <code>&amp;</code>.</p>
<pre class="highlight"><code class="language-q">q)sell&amp;sums buys
2 3 7 10 12 12f</code></pre>
<p>Now that we have the cumulative allocation amounts, we need to unwind this to get the step-wise allocations. This entails subtracting successive items in the allocations list.</p>
<p>Wouldn't it be nice if q had a built-in function that returned the successive differences of a numeric list? There is one: <a href="https://code.kx.com/q/ref/deltas/"><code>deltas</code></a> and ‚Äì no surprise ‚Äì it involves an iterator (called Each Prior ‚Äì more about that in Chapter 5).</p>
<pre class="highlight"><code class="language-q">q)deltas 1 2 3 4 5
1 1 1 1 1
q)deltas 10 15 20
_</code></pre>
<p>Observe in your console display that <code>deltas</code> returns the initial item untouched. This is just what we need.</p>
<p>Returning to our example of FIFO allocation, we apply <code>deltas</code> to the cumulative allocation list and we‚Äôre done.</p>
<pre class="highlight"><code class="language-q">q)deltas sell&amp;sums buys
_</code></pre>
<p>Look ma, no loops!</p>
<p>Now fasten your seatbelts as we switch on warp drive. In real-world FIFO allocation problems, we actually want to allocate buys FIFO not just to a single sell, but to a sequence of sells. You say, surely this must require a loop. Please don't call me Shirley. And no loopy code.</p>
<p>We take <code>buys</code> as before but now we have a list <code>sells</code>, which are to be allocated FIFO from <code>buys</code>.</p>
<pre class="highlight"><code class="language-q">q)buys:2 1 4 3 5 4f
q)sells:2 4 3 2
q)allocations
2 0 0 0 0 0
0 1 3 0 0 0
0 0 1 2 0 0
0 0 0 1 1 0</code></pre>
<p>The idea is to extend the allocation of buys across multiple sells by considering both the cumulative amounts to be allocated as well as the cumulative amounts available for allocation.</p>
<pre class="highlight"><code class="language-q">q)sums[buys]
2 3 7 10 15 19f
q)sums[sells]
2 6 9 11</code></pre>
<p>The insight is to cap the cumulative buys with each cumulative sell.</p>
<pre class="highlight"><code class="language-q">q)2&amp;sums[buys]
2 2 2 2 2 2f
q)6&amp;sums[buys]
2 3 6 6 6 6f
q)9&amp;sums[buys]
2 3 7 9 9 9f
q)11&amp;sums[buys]
2 3 7 10 11 11f</code></pre>
<p>Contemplate this koan and you will realize that each line includes the allocations to all the buys preceding it. From this we can unwrap cumulatively along both the buy and sell axes to get the incremental allocations.</p>
<p>Our first task is to produce the above result as a list of lists.</p>
<pre class="highlight"><code class="language-q">2 2 2 2  2  2
2 3 6 6  6  6
2 3 7 9  9  9
2 3 7 10 11 11</code></pre>
<p>Iterators to the rescue! Our first task requires an iterator that applies a binary function and a given right operand to each item of a list on the left. That iterator is called <a href="https://code.kx.com/q/ref/maps/#each-left-and-each-right">Each Left</a> and it has the funky notation <code>\:</code>. We use it to accomplish in a single operation the four individual <code>&amp;</code> operations above.</p>
<pre class="highlight"><code class="language-q">q)sums[sells] &amp;\: sums[buys]
2 2 2 2  2  2
2 3 6 6  6  6
2 3 7 9  9  9
2 3 7 10 11 11</code></pre>
<p>Now we apply <code>deltas</code> to unwind the allocation in the vertical direction.</p>
<pre class="highlight"><code class="language-q">q)deltas sums[sells]&amp;\:sums[buys]
2 2 2 2 2 2
0 1 4 4 4 4
0 0 1 3 3 3
0 0 0 1 2 2</code></pre>
<p>For the final step, we need to unwind the allocation across the rows.</p>
<p>The iterator we need is called <a href="https://code.kx.com/q/ref/each/"><code>each</code></a>. As a higher-order function, it applies a given function to each item of a list (hence its name). For a simple example, the following nested list has count 2, since it has two items. Using <code>count each</code> gives the count of each item in the list.</p>
<pre class="highlight"><code class="language-q">q)(1 2 3; 10 20)
_
q)count (1 2 3; 10 20)
_
q)count each (1 2 3; 10 20)
3 2</code></pre>
<p>In the context of our allocation problem, we realize that <code>deltas each</code> is just the ticket to unwind the remaining cumulative allocation within each row.</p>
<pre class="highlight"><code class="language-q">q)deltas each deltas sums[sells] &amp;\: sums[buys]
2 0 0 0 0 0
0 1 3 0 0 0
0 0 1 2 0 0
0 0 0 1 1 0</code></pre>
<p><em>Voil√†!</em> The solution to our allocation problem in a single line of q. The power of higher-order functions (iterators) is breathtaking.</p>
<h2 id="115-dictionaries-and-tables-101">1.15 Dictionaries and Tables 101</h2>
<p>After lists, the second basic data structure of q is the <em>dictionary</em>, which models key-value association. A dictionary is constructed from two lists of the same length using the <code>!</code> operator. The left operand is the list of (presumably unique, though unenforced) <em>keys</em> and the right operand is the list of <em>values</em>. A dictionary is a first-class value, just like an integer or list and can be assigned to a variable.</p>
<pre class="highlight"><code class="language-q">q)`a`b`c!10 20 30
a| 10
b| 20
c| 30
q)d:`a`b`c!10 20 30</code></pre>
<p>Observe that dictionary console display looks like the I/O table of a mathematical mapping. No coincidence.</p>
<p>Given a key, we retrieve the associated value with the same square-bracket notation as list indexing.</p>
<pre class="highlight"><code class="language-q">q)d[`a]
_</code></pre>
<p>A useful class of dictionary has as keys a simple list of symbols and as values a list of lists of uniform length. We think of such a dictionary as a named collection of columns and call it a <em>column dictionary</em>.</p>
<pre class="highlight"><code class="language-q">q)`c1`c2!(10 20 30; 1.1 2.2 3.3)
c1| 10 20 30
c2| 1.1 2.2 3.3
q)dc:`c1`c2!(10 20 30; 1.1 2.2 3.3)</code></pre>
<p>Retrieving by key yields the associated column, which is itself a list and so can be indexed.</p>
<pre class="highlight"><code class="language-q">q)dc[`c1]
10 20 30
q)dc[`c1][0]
10
q)dc[`c2][1]
_</code></pre>
<p>Whenever such iterated indexing of nested entities arises in q, there is an equivalent syntactic form, called <em>indexing at depth</em>, to make things a bit more readable.</p>
<pre class="highlight"><code class="language-q">q)dc[`c1][0]
10
q)dc[`c1; 0]
10
q)dc[`c1; 1]
_
q)dc[`c1; 2]
_</code></pre>
<p>Indexing-at-depth notation suggests thinking of <code>dc</code> as a two-dimensional entity; this is reasonable in view of its display above. Let‚Äôs pursue this. Whenever an index is elided in q, the result is as if every legitimate value had been specified in the omitted index position. For a column dictionary, this yields the associated column when the second slot is omitted.</p>
<pre class="highlight"><code class="language-q">q)dc[`c1;]
10 20 30
q)dc[`c2;]
_</code></pre>
<p>Things are more interesting when the index in the first slot is elided. The result is a dictionary comprising a section of the original columns in just the specified position.</p>
<pre class="highlight"><code class="language-q">q)dc[;0]
c1| 10
c2| 1.1
q)dc[;1]
_
q)dc[;2]
_</code></pre>
<p>To summarize, we have an entity that retrieves columns in the first slot and section dictionaries in the second slot. The issue is that columns are conventionally accessed in the second slot of two-dimensional things. No problem. We apply the built-in operator<a href="https://code.kx.com/q/ref/flip/"> <code>flip</code></a> (better called ‚Äútranspose‚Äù) to reverse the order of indexing. We still have the same column dictionary but slot retrieval is reversed: columns are accessed in the second slot and section dictionaries are retrieved from the first slot.</p>
<pre class="highlight"><code class="language-q">q)t:flip `c1`c2!(10 20 30; 1.1 2.2 3.3)
q)t[0; `c1]
10
q)t[1; `c1]
_
q)t[2; `c1]
_
q)t[0; `c2]
_
q)t[; `c1]
10 20 30
q)t[0;]
c1| 10
c2| 1.1</code></pre>
<p>We emphasize that the data is still stored as a column dictionary under the covers; only the indexing slots are affected.</p>
<p>Observe that the console display of a flipped column dictionary is indeed the transpose of the column dictionary display and in fact looks like ‚Ä¶ a table.</p>
<pre class="highlight"><code class="language-q">q)flip `c1`c2!(10 20 30; 1.1 2.2 3.3)
c1 c2
------
10 1.1
20 2.2
30 3.3</code></pre>
<p>A flipped column dictionary, called a <em>table</em>, is a first-class entity in q.</p>
<p>In the table setting, the section dictionaries are called <em>records</em> of the table. They correspond to the rows of SQL tables. To see why, observe that the record at index 0 is effectively the horizontal slice of the table in ‚Äúrow‚Äù 0. Let‚Äôs re-examine record retrieval, this time omitting the optional trailing semicolon from the elided second index.</p>
<pre class="highlight"><code class="language-q">q)t[0]
c1| 10
c2| 1.1
q)t[1]
_
q)t[2]
_</code></pre>
<p>Looking at this syntactically, we might conclude that <code>t</code> is a list of record dictionaries. In fact it is, at least logically; physically a table is always stored as a collection of named columns.</p>
<p>Thus we have arrived at:</p>
<ul>
<li>A table is a flipped column dictionary.</li>
<li>It is also a list of record dictionaries.</li>
</ul>
<p>While we can always construct a table as a flipped column dictionary, there is a convenient syntax that puts the names together with the columns. The notation looks a bit odd at first but it will seem more reasonable when we encounter keyed tables later.</p>
<pre class="highlight"><code class="language-q">q)([] c1:10 20 30; c2:1.1 2.2 3.3)
c1 c2
------
10 1.1
20 2.2
30 3.3</code></pre>
<p>A few notes.</p>
<ul>
<li>The square brackets are necessary to differentiate a table from a list</li>
<li>The occurrence of <code>:</code> is <strong>not</strong> assignment. It is merely a syntactic marker separating the name from the column values</li>
<li>The column names in table definition are <strong>not</strong> symbols, although they are converted to symbols under the covers.</li>
</ul>
<h2 id="116-q-sql-101">1.16 q-sql 101</h2>
<p>There are multiple ways to operate on tables. First, you can treat a table as the column dictionary that it is and perform basic dictionary operations on it. Qbies who are familiar with SQL may find it easier to use q‚Äôs version of SQL-like syntax, called <em>q-sql</em>. In this section we explore basic q-sql features.</p>
<p>The fundamental q-sql operation is the <code>select</code> template, We say ‚Äòtemplate‚Äô because, unlike other q primitives, it is <strong>not</strong> evaluated right-to-left. Rather, it is syntactic sugar designed to mimic SQL <code>SELECT</code>. That said, we emphasize that although <code>select</code> does act like SQL <code>SELECT</code> in some respects, there is one fundamental difference. Whereas SQL <code>SELECT</code> operates on fields on a row-by-row basis, <code>select</code> performs vector operations on column lists. Insisting on thinking in rows with q tables will end in tears.</p>
<p>We construct a simple table for our examples.</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:1000+til 6; c2:`a`b`c`a`b`a; c3:10*1+til 6)
q)t
_</code></pre>
<p>The simplest form of <code>select</code> retrieves all the records and columns of the table by leaving unspecified which rows or columns ‚Äì there is no need for the wildcard <code>*</code> of SQL. The <code>select</code> and <code>from</code> <strong>must</strong> occur together.</p>
<pre class="highlight"><code class="language-q">q)select from t
_</code></pre>
<p>The next example shows how to specify which columns to return and optional names to associate with them.</p>
<pre class="highlight"><code class="language-q">q)select c1, val:2*c3 from t
_</code></pre>
<p>We make several observations</p>
<ul>
<li>Result columns are separated by <code>,</code> and are sequenced left-to-right.</li>
<li>Any q expressions inside <code>select</code> are evaluated right-to-left, as usual.</li>
<li>As was the case with table definition syntax, instances of <code>:</code> are <strong>not</strong> assignment; rather, they are syntactic markers separating a column name to its left from the q expression to its right, which computes the column.</li>
<li>Arbitrary q expressions can be used to produce result columns, provided all column lengths are the same.</li>
<li>There are optional <code>by</code> and <code>where</code> phrases for grouping and constraints.</li>
</ul>
<p>The next example demonstrates using the <code>by</code> phrase of <code>select</code> to perform grouping. The basic usage is similar to <code>GROUP BY</code> in SQL, in which the column expressions involve aggregate functions. All records having common values in the <code>by</code> column(s) are grouped together and then aggregation is performed within each group.</p>
<pre class="highlight"><code class="language-q">q)select count c1, sum c3 by c2 from t
c2| c1 c3
--| ------
a | 3 110
b | 2 70
c | 1 30</code></pre>
<p>An advantage of q-sql <code>by</code> is that you can group on a computed column.</p>
<pre class="highlight"><code class="language-q">q)select count c2 by ovrund:c3&lt;=40 from t
ovrund| c2
------| --
0     | 2
1     | 4</code></pre>
<p>Closely related to <code>select</code> is the <code>update</code> template. It has the same syntax as <code>select</code> but semantically the names to the left of <code>:</code> are interpreted as columns to modify (or add, if not present). As with <code>select</code>, you can specify an optional <code>where</code> phrase, which limits the action to just those records satisfying specified constraint(s). Here is how to scale the <code>c3</code> column of <code>t</code> just in the positions having <code>c2</code> equal to <code>`a</code>.</p>
<pre class="highlight"><code class="language-q">q)update c3:10*c3 from t where c2=`a
c1   c2 c3
-----------
1000 a  100
1001 b  20
1002 c  30
1003 a  400
1004 b  50
1005 a  600</code></pre>
<p>We emphasize that the operations in <code>update</code> are vector operations on columns, not row-by-row.</p>
<p>Not all of q-sql is included in the templates. For example, to sort a table ascending by column(s), use <a href="https://code.kx.com/q/ref/xasc/"><code>xasc</code></a> with left operand the symbol column name(s) in major-to-minor order.</p>
<pre class="highlight"><code class="language-q">q)`c2 xasc t
_</code></pre>
<h2 id="117-example-trades-table">1.17 Example: Trades Table</h2>
<p>In this section we construct a toy trades table to demonstrate the power of q-sql.</p>
<p>A useful operator for constructing lists of test data is <a href="https://code.kx.com/q/ref/deal/" title="Roll"><code>?</code></a>, which generates pseudo-random data. We can generate 10 numbers randomly selected, with replacement, from the first 20 integers starting at 0 (i.e., not including 20).</p>
<pre class="highlight"><code class="language-q">q)10?20 / ymmv
4 13 9 2 7 0 17 14 9 18
q)10?20
_
q)10?20
_</code></pre>
<p>We can similarly generate 10 random floats between 0.0 and 100.0 (not including 100.0).</p>
<pre class="highlight"><code class="language-q">q) 10?100.0
_</code></pre>
<p>We can make 10 random selections from the items in a list</p>
<pre class="highlight"><code class="language-q">q)10?`aapl`ibm
_</code></pre>
<p>Now to our trades table. Since a table is a collection of columns, we first build the columns. We apologize for using excessively short names so that things fit easily on the printed page.</p>
<p>First we construct a list of 1,000,000 random dates in the month of January 2015.</p>
<pre class="highlight"><code class="language-q">q)dts:2015.01.01+1000000?31</code></pre>
<p>Next a list of 1,000,000 timespans.</p>
<pre class="highlight"><code class="language-q">q)tms:1000000?24:00:00.000000000</code></pre>
<p>Next a list of 1,000,000 tickers chosen from AAPL, GOOG and IBM. It is customary to make these lower-case symbols.</p>
<pre class="highlight"><code class="language-q">q)syms:1000000?`aapl`goog`ibm</code></pre>
<p>Next a list of 1,000,000 volumes given as positive lots of 10.</p>
<pre class="highlight"><code class="language-q">q)vols:10*1+1000000?1000</code></pre>
<p>As an initial cut, we construct a list of 1,000,000 prices in cents uniformly distributed within 10% of 100.0. We will adjust this later.</p>
<pre class="highlight"><code class="language-q">q)pxs:90.0+(1000000?2001)%100</code></pre>
<p>Now collect these into a table and inspect the first 5 records. Remember, a table is a list of records so <code>#</code> applies.</p>
<pre class="highlight"><code class="language-q">q)trades:([] dt:dts; tm:tms; sym:syms; vol:vols; px:pxs)
q)5#trades
_</code></pre>
<p>The first thing you observe in your console display is that the trades are not in temporal order. We fix this by sorting on time within date using <code>xasc</code>.</p>
<pre class="highlight"><code class="language-q">q)trades:`dt`tm xasc trades
q)5#trades
_</code></pre>
<p>Now we adjust the prices. At the time of this writing (Sep 2015) AAPL was trading around 100, so we leave it alone. But we adjust GOOG and IBM to their approximate trading ranges by scaling.</p>
<pre class="highlight"><code class="language-q">q)trades:update px:6*px from trades where sym=`goog
q)trades:update px:2*px from trades where sym=`ibm
q)5#trades
dt tm sym vol px
------------------------------------------------
2014.01.01 0D00:00:04.117137193 goog 6140 582.24
2014.01.01 0D00:00:06.227586418 ibm 7030 196.66
2014.01.01 0D00:00:07.611505687 ibm 7740 185.14
2014.01.01 0D00:00:11.415991187 goog 4130 605.34
2014.01.01 0D00:00:12.739158421 goog 8810 579.36</code></pre>
<p>This looks a bit more like real trades. Let‚Äôs perform some basic queries as sanity checks. Given that both price and volume are uniformly distributed, we expect their averages to approximate the mean. Using the built-in average function <code>avg</code> we see that they do.</p>
<pre class="highlight"><code class="language-q">q)select avg px, avg vol by sym from trades
_</code></pre>
<p>Similarly, we expect the minimum and maximum price for each symbol to be the endpoints of the uniform range.</p>
<pre class="highlight"><code class="language-q">q)select min px, max px by sym from trades
_</code></pre>
<p>Our first non-trivial query computes the 100-millisecond bucketed volume-weighted average price (VWAP). This uses the built-in binary function <a href="https://code.kx.com/q/ref/xbar/"><code>xbar</code></a>. The left operand of <code>xbar</code> is an interval width, and the right operand is a list of numeric values. The effect of <code>xbar</code> is to shove each input to the left-hand end point of the interval of specified width in which it falls. For example,</p>
<pre class="highlight"><code class="language-q">q)5 xbar til 15
0 0 0 0 0 5 5 5 5 5 10 10 10 10 10</code></pre>
<p>This is useful for grouping since it effectively buckets all the values within each interval to the left end-point of that interval. Recalling that a timespan is actually an integral count of nanoseconds since midnight, to compute 100-millisecond buckets we will use <code>xbar</code> with an interval of 100,000,000.</p>
<p>We also require <a href="https://code.kx.com/q/ref/wavg/"><code>wavg</code></a>, a binary function that computes the average of the numeric values in its right operand weighted by the values of its left operand.</p>
<pre class="highlight"><code class="language-q">q)1 2 3 wavg 50 60 70
_</code></pre>
<p>Now we put things together in a single query. For convenience of display, we group by bucketed time within symbol.</p>
<pre class="highlight"><code class="language-q">q)select vwap:vol wavg px by sym,bkt:100000000 xbar tm from trades
_</code></pre>
<p>That‚Äôs all there is to it!</p>
<p>Our final query involves the maximum profit (or analogously, maximum drawdown) realizable over the trading period. To understand the concept, imagine that you have a DeLorean with flux capacitor and are able to travel into the future and record historical trade results. Upon returning to the present, you are given $1,000,000 to invest with the stipulation that you can make one buy and one sell for AAPL and you are not allowed to short the stock. As a good capitalist your goal is to maximize your profit.</p>
<p>Restating the problem, we wish to determine the optimum time to buy and sell for the largest (positive) difference in price, where the buy precedes the sell. We state the solution as a q koan, which you should contemplate until enlightenment.</p>
<pre class="highlight"><code class="language-q">q)select max px-mins px from trades where sym=`aapl
_</code></pre>
<p>Two hints if Zen enlightenment is slow to dawn.</p>
<ul>
<li>Take the perspective of looking back from a potential optimum sell</li>
<li>The optimum buy must happen at a cumulative local minimum; otherwise, you could back up to an earlier, lower price and make a larger profit.</li>
</ul>
<h2 id="118-file-io-101">1.18 File I/O 101</h2>
<p>For this section we need to introduce the other q primitive text data type, called <em>char</em>. A single ASCII character is represented as that character in double quotes. Here are some examples.</p>
<pre class="highlight"><code class="language-q">q)"a"
_
q)" "
_
q)"_"
_</code></pre>
<p>The char <code>"a"</code> is an atom but is <strong>not</strong> the same as its symbol cousin <code>`a</code>.</p>
<p>Things get sticky with a simple list of char. Enter such a list in general form and observe the simplified display echoed on the console.</p>
<pre class="highlight"><code class="language-q">q)("s";"t"; "r"; "i"; "n"; "g")
"string"</code></pre>
<p>A simple list of char looks like a string from traditional languages and is even called a <em>string</em> in q. But this string is <strong>not</strong> an atom or even a first class entity in q; it is a list having count 6. And it should <strong>not</strong> be confused with its symbol cousin <code>`string</code>, which is an atom having count 1.</p>
<pre class="highlight"><code class="language-q">q)count "string"
_
q)count `string
_</code></pre>
<p>With these preliminaries out of the way, we proceed to I/O. The way q handles I/O is Spartan. No instantiation of readers, writers, serializers and the like. We admit that the notation is funky, but you will grow to appreciate its conciseness just as a serious driver prefers a manual transmission.</p>
<p>File I/O begins with symbolic handles. A <em>symbolic file handle</em> is a symbol of a particular form that represents the name of a resource on the file system. The leading <code>:</code> distinguishes the symbol as a handle. For example,</p>
<pre class="highlight"><code class="language-q">`:path/filename</code></pre>
<p>We use the following simple table in our demonstration.</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:`a`b`c; c2:1.1 2.2 3.3)
q)t
_</code></pre>
<p>Pick a destination to write your files. This being a tutorial, the examples here will use</p>
<p><code>/q4m/examples</code></p>
<p>You should replace this with your chosen directory in what follows.</p>
<p>To save the table <code>t</code> in a serialized binary data file, use the built-in function <code>set</code> with symbolic file handle as left operand and the source data as the right operand.</p>
<pre class="highlight"><code class="language-q">q)`:/q4m/examples/t set t
`:/q4m/examples/t</code></pre>
<p>Observe that the console echoes the symbolic file handle in case of success. To read the stored data and deserialize it back into the session, use <a href="https://code.kx.com/q/ref/get/"><code>get</code></a> with the symbolic file handle.</p>
<pre class="highlight"><code class="language-q">q)get `:/q4m/examples/t
_</code></pre>
<p>Presto! It's out and back.</p>
<p>To write text data to a file we use one of the overloads of the infelicitously named <a href="https://code.kx.com/q/ref/file-text/" title="File Text"><code>0:</code></a> operator. The key idea is that q considers a text file to correspond to a list of strings, one string per file record. We supply <code>0:</code> with a symbolic file handle as its left operand and a list of strings (i.e., a list of lists of char) in the right operand.</p>
<pre class="highlight"><code class="language-q">q)`:/q4m/examples/life.txt 0: ("Meaning";"of";"life")
_</code></pre>
<p>To read a text file as a list of strings, use <a href="https://code.kx.com/q/ref/read0/"><code>read0</code></a> with the symbolic handle.</p>
<pre class="highlight"><code class="language-q">q)read0 `:/q4m/examples/life.txt
_</code></pre>
<p>And now, what everyone is waiting for: writing and reading CSV files. Hold on to your hats, as this uses three different overloads of <code>0:</code>. One to prepare the tables as text; the one we already met to write text files; and one to read formatted text files. Certainly a regrettable naming convention.</p>
<p>Preparing a table as CSV text is simple; q handles the quoting and escaping of special characters. Apply <code>0:</code> with the defined constant <code>csv</code> as left operand and the table in the right operand.</p>
<pre class="highlight"><code class="language-q">q)csv 0: t
_</code></pre>
<p>Your console display shows the table properly prepared as strings. Now compose this result with the previous overload of <code>0:</code> and write it out. As a check, we use <code>read0</code> to read back the text file.</p>
<pre class="highlight"><code class="language-q">q)`:/q4m/examples/t.csv 0: csv 0: t
_
q)read0 `:/q4m/examples/t.csv
_</code></pre>
<p>Finally, we demonstrate the third overload of <code>0:</code> to parse the formatted CSV file into the q session as a table. The right operand is a symbolic file handle. The left operand is a control list with two items. The first is a string of upper-case characters indicating the types of each field within the text row.</p>
<p>The second item of the control list is the field separation character ‚Äì in our case this is <code>,</code>. This separator char should be enlisted if there are column headers in the first row of the file, as in our case. These headers are used as table column names. For our example we have,</p>
<pre class="highlight"><code class="language-q">q)("SF"; enlist ",") 0: `:/q4m/examples/t.csv
_</code></pre>
<p>Here <code>"S"</code> and <code>"F"</code> indicate that there are two fields, having types symbol and float. The separator is an enlisted <code>","</code>.</p>
<p>Yes, the naming and notation is obscure. But you have to admit that file I/O can't get much simpler.</p>
<h2 id="119-interprocess-communication-101">1.19 Interprocess Communication 101</h2>
<p>For this section, you will need two open q sessions, best done on the same machine. We recommend that this machine be one that is not encumbered with enterprise security. Chose one session to be your ‚Äúserver‚Äù and open a port with the <a href="https://code.kx.com/q/basics/syscmds/#p-listening-port">command <code>\p</code></a> (note lower case) followed by the port number. To verify that the port is open, execute the naked command <code>\p</code> and check that it echoes a 32-bit int of the port you opened.</p>
<pre class="highlight"><code class="language-q">q)\p 5042 / on server
q)\p
5042i</code></pre>
<p>The syntax of Interprocess Communication (IPC) is similar to that of File I/O. A <em>symbolic network handle</em> is a symbol of a particular form that identifies the name of a resource on the network. For our purposes, it suffices to consider a network handle of the simplest form.</p>
<pre class="highlight"><code class="language-q">`:localhost:5042</code></pre>
<p>The leading <code>:</code> in the symbol identifies it as a symbolic handle. To the left of the second <code>:</code> is the name of the network resource ‚Äì in this case, the machine on which the q session is running. To the right of <code>:</code> is a (presumably open) port on the destination machine that will be used for TCP/IP communication.</p>
<p>To open a connection, use a symbolic handle as argument to <a href="https://code.kx.com/q/ref/hopen/"><code>hopen</code></a> and store the result in a variable, traditionally called <code>h</code>. Do that now in your ‚Äúclient‚Äù session after ensuring that the specified port is open in the ‚Äúserver‚Äù session.</p>
<pre class="highlight"><code class="language-q">q)h:hopen `:localhost:5042 / on client</code></pre>
<p>The variable <code>h</code> is called an <em>open handle</em>. It holds a function for sending a request to the server and receiving the result of that request. Now we‚Äôre ready to party.</p>
<p>There are three ways to send requests from the client to the server, only one of which is safe for production applications. For demonstration purpose (only), we show the simplest, which should only be used in development environments. When invoked with a string ‚Äì i.e., a list of chars ‚Äì argument, the handle function <code>h</code> synchronously sends that string to the server, where it is executed, and any result is returned from the application of <code>h</code>.</p>
<pre class="highlight"><code class="language-q">q)h "6*7" / on client
42</code></pre>
<p>Clearly this isn‚Äôt safe, as arbitrary text can be sent for nefarious purposes.</p>
<p>A safer way to make requests to the server is to invoke <code>h</code> with a list containing the name of a function that (presumably) exists on the server, followed by arguments to that function. When <code>h</code> is invoked with such a list argument, it (synchronously) causes the server to apply the named function to the transmitted arguments, and then returns any result from the server is its own output. This corresponds to call-by-name in a traditional remote-procedure call. It is safer since the server can inspect the symbolic function name and determine whether the requesting user is authorized to execute it. </p>
<p>On your server process, create a simple function of two arguments.</p>
<pre class="highlight"><code class="language-q">q)f:{x*y} / on server</code></pre>
<p>On your client process, invoke <code>h</code> with a list containing the symbolic name of the remote function followed by its two arguments.</p>
<pre class="highlight"><code class="language-q">q)h (`f; 6; 7) / on client
_</code></pre>
<p>Observe that nothing is displayed on the server console since the function application there returns its result to the client. To close the connection with the server, flush buffers and free resources, apply <a href="https://code.kx.com/q/ref/hclose/"><code>hclose</code></a> to the open handle.</p>
<pre class="highlight"><code class="language-q">q)hclose h / on client</code></pre>
<p>IPC doesn‚Äôt get any easier.</p>
<h2 id="120-example-asynchronous-callbacks">1.20 Example: Asynchronous Callbacks</h2>
<p>The IPC mechanism of q does not have callbacks built in but it is powerful enough that we can create callbacks ourselves. We assume that you have started separate client and server q sessions and have opened the connection from the client to the server, as in the previous section.</p>
<p>Heretofore, calls to the server were synchronous, meaning that at the point of the remote call, the client blocks until the requested work on the server completes and the result is returned. It is also possible to make the remote call asynchronous. In this case, the client does <strong>not</strong> block: the application of the open handle returns immediately.</p>
<p>In order to demonstrate this, we have to come clean about what is really in the open handle <code>h</code>. See for yourself by displaying the <code>h</code> from an open connection.</p>
<pre class="highlight"><code class="language-q">q)h:hopen `:localhost:5042
q)h
3i</code></pre>
<p>Your result will probably not match this but it <strong>will</strong> be an integer. Yes, an open handle is just a positive 32-bit integer. When this (positive) integer is applied as a function, the call is synchronous. To make an asynchronous call, negate the value in <code>h</code> ‚Äì i.e., <code>neg h</code> ‚Äì and use this with function application syntax. Seriously.</p>
<p>Since nothing will be displayed in the client session, it helps to display progress on the server as the request is performed. Create the function <code>echo</code> in the server session.</p>
<pre class="highlight"><code class="language-q">q)echo:{show x} / on server</code></pre>
<p>Now make an asynchronous remote call to <code>echo</code> from the client.</p>
<pre class="highlight"><code class="language-q">q)(neg h) (`echo; 42) / on client
_</code></pre>
<p>Observe on your q consoles that the client application returns immediately with no result and that the server displays the progress message.</p>
<p>Now to callbacks. We begin by instrumenting a function <code>rsvp</code> on the server that, when invoked remotely, will call back to the client. It will receive two parameters: its own argument and the symbolic name of the client function to call.</p>
<pre class="highlight"><code class="language-q">q)rsvp:{[arg;cb] ..} / on server</code></pre>
<p>We initially invoke the server‚Äôs <code>show</code> with the passed arg to indicate that we are hard at work on the transmitted data.</p>
<pre class="highlight"><code class="language-q">q)rsvp:{[arg;cb] show arg;}</code></pre>
<p>Now for the big moment. To make the return call from the server to the client, we need the open handle of the connection for the remote call we are processing. This is conveniently placed in the q system variable <a href="https://code.kx.com/q/ref/dotz/#zw-handle"><code>.z.w</code></a> (‚Äúwho‚Äù called) for the duration of each remote call. We use it to make an <strong>asynchronous</strong> remote call (hence the <code>neg</code>) over the caller‚Äôs handle, passing the provided callback name and our arduously computed result 43.</p>
<pre class="highlight"><code class="language-q">q)rsvp:{[arg;cb] show arg; (neg .z.w) (cb; 43);}</code></pre>
<p>In the final step, we display another progress message on the server console indicating the remote call has completed. Since this function returns its actual result remotely, we end its body with <code>;</code> to ensure that it returns nothing locally.</p>
<pre class="highlight"><code class="language-q">q)rsvp:{[arg;cb] show arg; (neg .z.w) (cb; 43); show `done;}</code></pre>
<p>We turn to the client side and create echo to serve as the function called back for this demonstration.</p>
<pre class="highlight"><code class="language-q">q)echo:{show x} / on client</code></pre>
<p>It remains to fire off the remote asynchronous call from the client. We pass the client open handle a list containing: the name of the remote function; the argument for the remote function; and the name of our own function to be called back during the remote computation. Be sure to do it asynchronously else you will get deadlocks.</p>
<pre class="highlight"><code class="language-q">q)(neg h) (`rsvp; 42; `echo) / on client</code></pre>
<p>Provided all went well, the server console will display:</p>
<pre class="highlight"><code class="language-q">q)42
`done</code></pre>
<p>The client console should display:</p>
<pre class="highlight"><code class="language-q">q)(neg h) (`rsvp; 42; `echo)
q)43</code></pre>
<p>And there you have it. Callbacks built from scratch in q using a few lines of code.</p>
<h2 id="121-websockets-101">1.21 Websockets 101</h2>
<p>In traditional web applications, the browser (as client) initiates requests and the server replies with the page or data requested using the HTTP protocol. The web server does the serious data manipulation. In recent years, browsers and JavaScript have evolved to levels of sophistication that permit quite powerful processing to be done safely on the client side ‚Äì for example, input editing and display formatting. Indeed, you can use WebSockets to put a browser front end on traditional applications, replacing both the web server and proprietary GUI packages in one fell swoop (phrase used with its original meaning).</p>
<p>The key idea of WebSockets is that the client makes an initial HTTP request to upgrade the protocol. Assuming the request is accepted, subsequent communication occurs over TCP/IP sockets protocol. In particular, once the WebSockets connection is made, either the client or server can initiate messaging.</p>
<p>We begin with a simple example that demonstrates how to connect a browser to a q process via WebSockets, request data and then display the result. We assume familiarity with basic HTML5 and JavaScript. Enter the script below in a text editor and save it as <code>sample1.html</code> in a location accessible to your browser.</p>
<div class="admonition note">
<p class="admonition-title"><code>c.js</code></p>
<p>This script uses the <code>c.js</code> script for serialization and deserialization between q and JavaScript, which you can download from <a href="https://github.com/KxSystems/kdb/blob/master/c/c.js">GitHub</a>. </p>
<p>For simplicity in this demo, we have placed a copy in the same directory as the <code>sample1.html</code> script so that it can be loaded with a (trivial) relative path. You should point this to the location of <code>c.js</code> in your q/kdb+ installation.</p>
</div>
<p>This script creates a minimal page with a field to display the result returned from the q server. After declaring some useful variables, we get to the interesting bits that create the WebSockets connection and handle the data from q. We create a WebSockets object and set its <code>binaryType</code> property to <code>"arraybuffer"</code>, which is necessary for the exchange of q serialized data.</p>
<p>We wire the behavior of the connection object by attaching handler functions for WebSockets events. Most important are the <code>onopen</code> and <code>onmessage</code> events. When the connection is opened, we serialize a JavaScript object containing a payload string and send it (asynchronously) to the q process; it will arrive there as a serialized dictionary. Conversely, when a serialized message is received from the q process, we deserialize it and invoke the <code>sayN</code> function on the content. The <code>sayN</code> function locates the display field on the page and copies its parameter there.</p>
<pre class="highlight"><code class="language-html">&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script src="c.js"&gt;&lt;/script&gt;
&lt;script&gt;
 var serverurl = "//localhost:5042/",
     c = connect(),
     ws;
  function connect() {
    if ("WebSocket" in window) {
      ws = new WebSocket("ws:" + serverurl);
      ws.binaryType="arraybuffer";
      ws.onopen=function(e){
        ws.send(serialize({ payload: "What is the meaning of life?" }));
      };
      ws.onclose=function(e){
      };
      ws.onmessage=function(e){
        sayN(deserialize(e.data));
      };
      ws.onerror=function(e) {window.alert("WS Error") };
    } else alert("WebSockets not supported on your browser.");
  }
  function sayN(n) {
    document.getElementById('answer').textContent = n;
  }
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;What is the meaning of life?&lt;/p&gt;
  &lt;p id="answer" style="font-size: 10em"&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>Now to the server side, where the q code is blissfully short. Start a fresh q session, open port 5042 and set the web socket handler <code>.z.ws</code> to a function that will be called on receipt of each message from the browser.</p>
<pre class="highlight"><code class="language-q">q)\p 5042
q).z.ws:{0N!-9!x; neg[.z.w] -8!42}</code></pre>
<p>The handler first displays its parameter, which we do for demonstration only as we have no further use for it in this example. Then it serializes the answer using <code>-8!</code> and sends it back (asynchronously) to the browser. That's it!</p>
<p>Now point your browser to <code>file://sample1.html</code> and you should see the answer displayed in a font large enough to be seen from the international space station. Notice that there is no web server here other than q itself.</p>
<p>Now that we‚Äôre warmed up, let's try a more interesting example. Here the browser will ask the q server to call out to the Yahoo Finance site and retrieve historical stock price and volume data for Apple. The browser will then use the publicly available High Charts package to display a spiffy stock history graph. In this example there will be a bit more JavaScript and q, but it's tolerable. And again, no web server other than q.</p>
<p>First let's tackle the browser side. Save the following text file as <code>ws101.html</code>.</p>
<pre class="highlight"><code class="language-html">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;script src=
    "http://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"&gt;
  &lt;/script&gt;
  &lt;script src="http://code.highcharts.com/stock/highstock.js"&gt;&lt;/script&gt;
  &lt;script src=
    "http://code.highcharts.com/stock/modules/exporting.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id="container" style="height: 500px; min-width: 500px"&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;script src="c.js"&gt;&lt;/script&gt;
&lt;script&gt;
  var serverurl = "//localhost:5042/",
    ws,
    c = connect(),
    ticker = "AAPL",
    startdt = "2008-01-01";

  function connect() {
    if ("WebSocket" in window) {
      ws=new WebSocket("ws:" + serverurl);
      ws.binaryType="arraybuffer";
      ws.onopen=function(e){
        toQ([ticker, startdt]);
      };
      ws.onclose=function(e){
      };
      ws.onmessage=function(e){
        return fromQ(e.data);
      };
      ws.onerror=function(e) {window.alert("WS Error") };
    } else alert("WebSockets not supported on your browser.");
  }

  function toQ(pl) {
    ws.send(serialize({ payload: pl }));
  }

  function fromQ(raw) {
    var data = deserialize(raw);
    return createChart(data);
  }

  function toUTC(x) {
    var y = new Date(x);
    y.setMinutes(y.getMinutes() + y.getTimezoneOffset());
    return y.getTime();
  }

  function createChart(data) {
    $('#container').highcharts('StockChart', {
      rangeSelector : {
        selected : 1
      },
      title : {
        text : ticker + ' Stock Price'
      },
      series : [{
        name : ticker,
        data : data.hist.map(function(x){return [toUTC(x.Date), x.Close]}),
        tooltip: {
          valueDecimals: 2
        }
      }]
    });
  }
&lt;/script&gt;
&lt;/html&gt;</code></pre>
<p>We provide a concise description of the highlights, assuming familiarity with basic HTML5 and JavaScript.</p>
<ul>
<li>Load external scripts from Google (for JQuery) and High Charts (for the actual graphical display).</li>
<li>Specify a simple HTML element to contain the actual graph.</li>
<li>Load the local KX file <code>c.js</code> for q serialization/deserialization.</li>
<li>Create the connection by calling <code>connect()</code>, which assigns a handler for <code>onopen</code> that calls <code>toQ</code> with the data variables.</li>
<li>Assign a handler to <code>onmessage</code> that passes the message to <code>fromQ</code>.</li>
<li>Initialize the variables that specify the historical data we will request from Yahoo Finance.</li>
<li>The <code>toQ</code> function wraps its parameter in a JavaScript object, serializes it and (asynchronously) sends it to the q process where it will manifest as a serialized dictionary.</li>
<li>The <code>fromQ</code> function deserializes a received q dictionary, which magically becomes a JavaScript object, and passes it to the <code>createChart</code> function.</li>
<li>The auxiliary function <code>toUTC</code> transforms q dates to a form suitable for High Stocks.</li>
<li>The <code>createChart</code> function instantiates a High Stocks stock price graph and populates the appropriate properties. Note the use of <code>map</code> to iterate over the individual time-series points; it is the functional programming equivalent of <code>each</code> in q. Also observe that we use the closing prices for the plot, as is customary.</li>
</ul>
<div class="admonition tip">
<p class="admonition-title">The alignment between JavaScript objects and q dictionaries, along with built-in serialization/deserialization, makes data transfer between the browser and q effortless.</p>
</div>
<p>Now to the q server side, which has fewer lines of code that do much work. Save the following text file as <code>ws101.q</code>.</p>
<!-- FIXME Yahoo Finance has discontinued the service used below.
`raw` gets set to an empty string. -->

<pre class="highlight"><code class="language-q">\p 5042

unixDate:{[dts] (prd 60 60 24)*dts-1970.01.01};

getHist:{[ticker; sdt; edt]
  tmpl:"https://query1.finance.yahoo.com/v7/finance/download/",
    "%tick?period1=%sdt&amp;period2=%edt&amp;interval=1d&amp;events=history";
  args:enlist[ticker],string unixDate sdt,edt;
  url:ssr/[tmpl; ("%tick";"%sdt";"%edt"); args];
  / raw:system "wget -q -O - ",url;
  raw:system "curl -s '",url,"'";
  t:("DFFFFJF"; enlist ",") 0: raw;
  `Date xasc `Date`Open`High`Low`Close`Volume`AdjClose xcol t}

getData:{[ticker; sdt] select Date,Close from getHist[ticker;"D"$sdt;.z.D]}

.z.ws:{
  args:(-9!x) `payload;
  neg[.z.w] -8!(enlist `hist)!enlist .[getData; args; `err]}</code></pre>
<p>Following is a description of the q code.</p>
<ul>
<li>Open port 5042</li>
<li>Define the <code>unixDate</code> function that converts dates to Unix timestamps.</li>
<li>Define the function <code>getHist</code> that does the real work.</li>
<li>Create a string template for the URL in which placeholders of the form <code>%arg</code> will be replaced with specific values.</li>
<li>Run the start-date and end-date parameters through the date adjustment, stringify the results and concatenate onto the ticker string to form a list of actual argument strings for the URL.</li>
<li>Use the Over operator <code>/</code> with <code>ssr</code> (string search and replace) and recursively replace each placeholder in the template with the corresponding stringified argument.</li>
<li>Instruct the OS to make a <code>curl</code> web call to the fully-specified Yahoo Finance URL. This returns raw time-series data as comma-separated string records with column headers in the first row.</li>
<li>Parse the text data into a table with the appropriate data types.</li>
<li>Rename the columns suitably for user display, sort by date (just in case) and return the result.</li>
</ul>
<p>The final entry in the q script sets the WebSockets handler. Here is its behavior.</p>
<ul>
<li>Deserialize the passed JavaScript object into a q dictionary and extract the payload field.</li>
<li>Perform protected evaluation of the multi-variate <code>getHist</code> function on the passed arguments.</li>
<li>Serialize the resulting timeseries table and <strong>asynchronously</strong> send it to the browser, where it appears as a serialized list of JavaScript objects, one for each day.</li>
</ul>
<div class="admonition info">
<p class="admonition-title">The Yahoo API changed in 2017. The code above has been revised and works as of 2020.06.28. <em>[Ed.]</em></p>
</div>
<p>To run this example, start a fresh q process and load the <code>ws101.q</code> script.</p>
<pre class="highlight"><code class="language-q">q) \l /pages/ws101.q</code></pre>
<p>Now point your browser at</p>
<p><code>file:///pages/ws101.html</code></p>
<p>Wait a few seconds (depending on the speed of your internet connection) and ‚Äì <em>voil√†!</em> ‚Äì you have a nifty graph of AAPL stock price.</p>
<p><img alt="AAPL stock price" src="https://code.kx.com/q4m3/img/qfm001.png"></p>
                


                
              
              
                


              
            </article>
            
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))for(var set of document.querySelectorAll("[data-tabs]")){var labels=set.querySelectorAll(":scope > label");e:for(var tab of tabs)for(var label of labels)if(label.innerText.trim()===tab){var input=label.previousElementSibling;input.checked=!0;break e}}</script>

          </div>
        </div>
        
          
        
      
                </div>
            </section>
        
            <section class="chapter" id="chapter-2">
                <div class="chapter-header">
                    <h1 class="chapter-title">10. Execution Control¬∂</h1>
                    <div class="chapter-meta">
                        <span>üìñ Source: <a href="https://code.kx.com/q4m3/10_Execution_Control/">https://code.kx.com/q4m3/10_Execution_Control/</a></span>
                        <span>üìù 3481 words</span>
                        
                    </div>
                </div>
                <div class="chapter-content">
                    
        <div class="md-main__inner md-grid">
          
            
              
              
            
            
              
              
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                
                <h1 id="10-execution-control">10. Execution Control</h1>
<h2 id="100-overview">10.0 Overview</h2>
<p>Basic function application in q provides sequential evaluation of a series of expressions. In this chapter we demonstrate how to achieve non-sequential execution in q.</p>
<h2 id="101-control-flow">10.1 Control Flow</h2>
<p>When writing vector operations in q, the cleanest code and best performance is obtained by avoiding loops and conditional execution. For those times when you simply must write iffy or loopy code, q has versions of the usual constructs.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Control flow constructs in this section involve branching in the byte code generated by the q interpreter. The offset of the branch destination is limited (currently to 255 byte codes), which means that the sequence of q expressions that can be contained in any part of <code>$</code>, <code>?</code>, <code>if</code>, <code>do</code>, or <code>while</code> must be short. At some point, insertion of one additional statement will break the camel‚Äôs back, resulting in a <code>'branch</code> error. This is q's way of rejecting bloated code. In this situation, factor code blocks into separate functions. Better yet, restructure your code.</p>
</div>
<h3 id="1011-basic-conditional-evaluation">10.1.1 Basic Conditional Evaluation</h3>
<p>Languages of C heritage have a form of in-line <em>if</em>, called conditional evaluation, of the form,</p>
<p><em>expr<sub>cond</sub></em> ? <em>expr<sub>true</sub></em> : <em>expr<sub>false</sub></em></p>
<p>where <em>expr<sub>cond</sub></em> is an expression that evaluates to a Boolean (or int in C and C++). The result of the expression is <em>expr<sub>true</sub></em> when <em>expr<sub>cond</sub></em> is true (or non-zero) and <em>expr<sub>false</sub></em> otherwise.</p>
<p>The same effect can be achieved in q using the <a href="https://code.kx.com/q/ref/cond/">ternary overload of <code>$</code></a>.</p>
<p><code>$[</code><em>expr<sub>cond</sub></em>; <em>expr<sub>true</sub></em>; <em>expr<sub>false</sub></em><code>]</code></p>
<p>Here <em>expr<sub>cond</sub></em> is an expression that evaluates to a boolean <strong>atom</strong>. Analogous to C, the result of <em>expr<sub>cond</sub></em> can be any type whose underlying value is an integer. The result of the conditional is the evaluation of <em>expr<sub>true</sub></em> when <em>expr<sub>cond</sub></em> is not zero and <em>expr<sub>false</sub></em> if it is zero.</p>
<pre class="highlight"><code class="language-q">q)$[1b;42;9*6]
42
q)$[0b;42;9*6]
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The conditional <code>$</code> is a function that always returns a value. It is good practice for expr<sub>true</sub> and expr<sub>false</sub> to have the same type. This is not enforced in q as it is in statically-typed functional languages.</p>
</div>
<p>The brackets in any q conditional do <strong>not</strong> create lexical scope. This means that variables created within the body exist in the same scope as the conditional. For example, in a fresh q session the variable <code>a</code> in the following is a global that persists outside the conditional.</p>
<pre class="highlight"><code class="language-q">q)a
'a
q)$[1b;a:42;a:43]
42
q)a
42</code></pre>
<p>Although evaluation of function arguments in q is <a href="https://en.wikipedia.org/wiki/Eager_evaluation">eager</a>, evaluation of the expressions in the conditional is short circuited, meaning that only the one selected for return is evaluated. Again in a fresh q session,</p>
<pre class="highlight"><code class="language-q">q)a
'a
q)b
'b
q)$[1b;a:42;b:43]
42
q)a
42
q)b
'b</code></pre>
<p>Observe that a test for zero in <em>expr<sub>cond</sub></em> is redundant: remove that test and reverse the order of the second and third arguments.</p>
<pre class="highlight"><code class="language-q">q)z:0
q)$[z=0;1.1;-1.1]
1.1
q)$[z;-1.1;1.1] / equivalent to previous
1.1</code></pre>
<p>In contrast with earlier versions of q, some null values are now acceptable for <em>expr<sub>cond</sub></em>. It is the same as testing for null with the keyword <a href="https://code.kx.com/q/ref/null/"><code>null</code></a>.</p>
<pre class="highlight"><code class="language-q">q)v:0N
q)$[v;`isnull;`notnull]
`isnull
q)$[null v;`isnull;`notnull]
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Float nulls do not work so the above is probably an accident and you should not count on it.</p>
</div>
<h3 id="1012-extended-conditional-evaluation">10.1.2 Extended Conditional Evaluation</h3>
<p>In languages of C heritage, the <em>if-else</em> statement has the form,
</p><pre class="highlight"><code class="language-c">if (expr_cond) {
    statement_true1;
    .
    .
    .
}

else {
    statement_false1;
    .
    .
    .
}</code></pre>
where <code>expr_cond</code> is an expression that evaluates to a boolean (or int in C and C++). If the expression <code>expr_cond</code> is true (i.e., non-zero) the first sequence of statements in braces is executed; otherwise, the second sequence of statements in braces is executed.
<p>A similar effect can be achieved in q using an extended form of conditional evaluation with <code>$</code>.</p>
<p><code>$[</code><em>expr<sub>cond</sub></em><code>; [</code><em>expr<sub>true1</sub></em><code>; ‚Ä¶]; [</code><em>expr<sub>false1</sub></em><code>; ‚Ä¶]]</code></p>
<p>where <em>expr<sub>cond</sub></em> is an expression as in the basic conditional. When <em>expr<sub>cond</sub></em> evaluates to non-zero, the first bracketed sequence of expressions is evaluated in left-to-right order; otherwise, the second bracketed sequence of expressions is evaluated.</p>
<pre class="highlight"><code class="language-q">q)v:42
q)$[v=42; [a:6;b:7;`Everything]; [a:`Life;b:`the;c:`Universe;a,b,c]]
`Everything
q)$[v=43; [a:6;b:7;`everything]; [a:`Life;b:`the;c:`Universe;a,b,c]]
`Life`the`Universe</code></pre>
<p>The extended forms of the conditional are still functions with return values. If you are using them strictly for side effects, you are writing imperative, non-vector code and should consider VBA as an alternative.</p>
<p>Languages of C heritage have a cascading form of if-else in which multiple tests can be made,
</p><pre class="highlight"><code class="language-c">if (expr_cond1) {
    statement_true11;
    .
    .
    .
}
else if (expr_condn) {
    statement_truen1;
    .
    .
    .
}
.
.
.
else {
    statement_false;
    .
    .
    .
}</code></pre>
<p>In this construction, the <code>expr_cond<em>n</em></code> are evaluated consecutively until one is true (non-zero), at which point the associated block of statements is executed and the statement is complete. If none of the expressions passes, the final block of statements, called the <em>default</em> case, is executed.</p>
<p>A similar effect can be achieved in q with another extended form of conditional execution.</p>
<p><code>$[</code><em>expr<sub>cond1</sub></em><code>;</code><em>expr<sub>true1</sub></em><code>; ‚Ä¶;</code><em>expr<sub>condn</sub></em><code>;</code><em>expr<sub>truen</sub></em><code>;</code><em>expr<sub>false</sub></em><code>]</code></p>
<p>In this form, the conditional expressions are evaluated consecutively until one is non-zero, at which point the associated <em>expr<sub>true</sub></em> is evaluated and its result is returned. If none of the conditional expressions evaluates to non-zero, <em>expr<sub>false</sub></em> is evaluated and its result is returned. Observe that <em>expr<sub>false</sub></em> is the only expression that is not part of a pair, as it has no guarding conditional expression.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Any condition other than the first is only evaluated if all those prior to it have evaluated to zero. Otherwise put, a condition evaluating to non-zero short-circuits the evaluation of subsequent ones.
</p><pre><code class="language-q">
q)a:0
q)$[a=0;`zero; a&gt;0;`pos; `neg]
`zero
q)a:42
q)$[a=0;`zero; a&gt;0;`pos; `neg]
_
q)a:-42
q)$[a=0;`zero; a&gt;0;`pos; `neg]
_ 
</code></pre>
</div>
<p>Finally, the previous extended form of conditional execution can be further extended by substituting a bracketed sequence of expressions for any <em>expr<sub>true</sub></em> or <em>expr<sub>false</sub></em>.
</p><pre class="highlight"><code class="language-q">$[expr_cond1;[expr_true11; ‚Ä¶]; ‚Ä¶;
    expr_condn;[expr_truen1; ‚Ä¶];
    [expr_false1; ‚Ä¶]]</code></pre>
If you use this, have the decency to align your code properly so that q coders can identify it as bogus q at a glance.
<div class="admonition tip">
<p class="admonition-title">After a brief Zen meditation, you realize that you can implement ‚Äúswitch‚Äù with a dictionary.</p>
</div>
<h3 id="1013-vector-conditional-evaluation">10.1.3 Vector Conditional Evaluation</h3>
<p>Ternary <a href="https://code.kx.com/q/ref/vector-conditional/">vector-conditional evaluation <code>?</code></a> has the form,</p>
<p><code>?[</code><em>v<sub>b</sub></em><code>;</code><em>expr<sub>true</sub></em><code>;</code><em>expr<sub>false</sub></em><code>]</code></p>
<p>where <em>v<sub>b</sub></em> is a simple boolean list and <em>expr<sub>true</sub></em> and <em>expr<sub>false</sub></em> are of the same type and are either atoms or vectors that conform to <em>v<sub>b</sub></em>. The result conforms to <em>v<sub>b</sub></em> and selects from <em>expr<sub>true</sub></em> in positions where <em>v<sub>b</sub></em> is 1b and <em>expr<sub>false</sub></em> in positions where <em>v<sub>b</sub></em> has 0b. All arguments of vector-conditional are fully executed. In other words, there is no short circuiting of evaluation.</p>
<p>The following example chooses 42 for items in a list that are multiples of 3.</p>
<pre class="highlight"><code class="language-q">q)L:til 10
q)?[0&lt;&gt;L mod 3; L; 42]
42 1 2 42 4 5 42 7 8 42</code></pre>
<p>Vector Conditional is especially useful with table columns.</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:1.1 2.2 3.3; c2:10 20 30; c3:100 200 300)
q)update mix:?[c1&gt;2.0; c3; c2] from t
_</code></pre>
<p>There are no extended forms of Vector Conditional. 
You can get a cascading effect by nesting vector conditional expressions. </p>
<!-- 
    per pierre@kx.com 2019.05.04: "?[;;] is a regular operator, no jumps involved"
but, like other conditionals, it is subject to the restriction that no internal code jump can exceed 255 byte codes. This limits the degree of nesting that can be used in practice. 
 -->
<p>With <code>t</code> as above,</p>
<pre class="highlight"><code class="language-q">q)update band:?[c2 within 5 15; 1; ?[c2 within 16 25; 2; 3]] from t
_</code></pre>
<h3 id="1014-if">10.1.4 <code>if</code></h3>
<p>The imperative <code>if</code> statement conditionally evaluates a sequence of expressions. It is not a function and does not return a value. It has the form,</p>
<p><code>if[</code><em>expr<sub>cond</sub></em><code>;</code><em>expr<sub>1</sub></em><code>; ‚Ä¶;</code><em>expr<sub>n</sub></em><code>]</code></p>
<p>The <em>expr<sub>cond</sub></em> is evaluated and if it is non-zero the expressions <em>expr<sub>1</sub></em> thru <em>expr<sub>n</sub></em> are evaluated in left-to-right order. As with other conditionals, the brackets do not create lexical scope, so variables defined in the body exist in the same scope as the <code>if</code>.</p>
<div class="admonition tip">
<p class="admonition-title">There is no ‚Äúelse‚Äù to go with <code>if</code>. Should you find that this cramps your coding style, please see the previous recommendation about VBA.</p>
</div>
<p>Here is an example that creates two global variables and modifies one.</p>
<pre class="highlight"><code class="language-q">q)a:42
q)b:98.6
q)if[a=42;x:6;y:7;b:a*b]
q)x
6
q)y
_
q)b
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Well-written q code rarely needs <code>if</code>. One example of legitimate use is pre-checking function arguments to abort execution for bad values.</p>
</div>
<h3 id="1015-do">10.1.5 <code>do</code></h3>
<p>The imperative <code>do</code> statement allows repeated execution of a block of statements. It has the form,</p>
<p><code>do[</code><em>expr<sub>count</sub></em><code>;</code><em>expr<sub>1</sub></em><code>; ‚Ä¶;</code><em>expr<sub>n</sub></em><code>]</code></p>
<p>where <em>expr<sub>count</sub></em> must evaluate to an non-negative integer. The expressions <em>expr<sub>1</sub></em> thru <em>expr<sub>n</sub></em> are evaluated <em>expr<sub>count</sub></em> times in left-to-right order. Note that <code>do</code> is a statement, not a function, and does not have an explicit result.</p>
<p>The following expression is a loopy computation of <em>n</em> factorial. It iterates <em>n</em> - 1 times, decrementing the factor <code>f</code> on each pass.</p>
<pre class="highlight"><code class="language-q">q)n:5
q)do[-1+f:r:n; r*:f-:1] / do not do this!
q)r</code></pre>
<div class="admonition tip">
<p class="admonition-title">The best recommendation about usage of <code>do</code> is: Don‚Äôt!</p>
</div>
<p>The only legitimate use of <code>do</code> that the author has encountered is to time the execution of a q expression that runs too quickly for the timer to get an accurate reading, but this has been obviated by the enhanced <code>\t</code> command.</p>
<pre class="highlight"><code class="language-q">q)\t v*v:til 1000000
15
q)\t do[100; v*v:til 1000000]
677
q)\t:100 v*v:til 1000000
_</code></pre>
<h3 id="1016-while">10.1.6 <code>while</code></h3>
<p>The imperative <code>while</code> statement is an iterator of the form,</p>
<p><code>while[</code><em>expr<sub>cond</sub></em><code>;</code><em>expr<sub>1</sub></em><code>; ‚Ä¶;</code><em>expr<sub>n</sub></em><code>]</code></p>
<p>where <em>expr<sub>cond</sub></em> is evaluated and the expressions <em>expr<sub>1</sub></em> thru <em>expr<sub>n</sub></em> are evaluated repeatedly in left-to-right order as long as <em>expr<sub>cond</sub></em> is non-zero. The <code>while</code> statement is not a function, does not have an explicit result and does not introduce lexical scope.</p>
<div class="admonition tip">
<p class="admonition-title">The author has never used <code>while</code> in actual code.</p>
</div>
<p>Here is loopy factorial redone with <code>while</code>.</p>
<pre class="highlight"><code class="language-q">q)f:r:n:5
q)while[f-:1;r*:f] / do not do this either!
q)r
120</code></pre>
<h3 id="1017-return-and-signal">10.1.7 Return and Signal</h3>
<p>Normal function application evaluates each expression in the function body in sequence and terminates after the last one. There are two mechanisms for ending the execution early: one indicates successful completion and the other signals abrupt termination.</p>
<p>To terminate function application immediately and return a normal value, use an empty assignment ‚Äì that is, <code>:</code> with the return value to its right and no variable to its left. For example, in the following instrumented function, application is terminated and the result is returned in the fourth expression. The final expression is never evaluated.</p>
<pre class="highlight"><code class="language-q">q)f:{0N!"Begin"; a:x; b:y; :a*b; "End"}
q)f[6;7]
"Begin"
42</code></pre>
<p>To abort function execution immediately with an exception, use <a href="https://code.kx.com/q/ref/signal/">Signal</a>, which is single-quote <code>'</code>, with an error message to its right. The error message can be provided as a symbol or string.</p>
<p>You too can return pithy error messages. For example, in the following function, execution will be aborted in the fourth expression. The final expression that assigns <code>c</code> is never evaluated.</p>
<pre class="highlight"><code class="language-q">q)g:{0N!"Begin"; a:x; b:y; '"End"; c:b}
q)g[6;7]
"Begin"
'End</code></pre>
<p>A function issuing a signal causes the calling routine to fail and this will ripple all the way up the call chain unless protected evaluation is used to trap the exception. See the next section for details on protected evaluation.</p>
<p>A legitimate use of the <code>if</code> statement is to terminate execution with an exception. The following snippet would typically reside inside a function body.</p>
<pre class="highlight"><code class="language-q">{
...
if[a&lt;50; '"Bad a"];
...
}</code></pre>
<h3 id="1018-protected-evaluation">10.1.8 Protected Evaluation</h3>
<p>Languages of C++ heritage have the concept of protected execution using try-catch. The idea is that an unexpected condition arising from any statement enclosed in the try portion does not abort the program. Instead, control transfers to the catch block, where the exception can be handled or passed up to the caller. This mechanism allows the call stack to be unwound gracefully.</p>
<p>Q provides a similar capability using ternary forms of <a href="https://code.kx.com/q/ref/apply/#trap"><code>Apply</code> and <code>Apply At</code></a>. Ternary <code>@</code> is used for unary functions and ternary <code>.</code> is used for multivalent functions. The syntax is the same for both.</p>
<p><code>@[</code><em>f<sub>mon</sub></em><code>;</code><em>a</em><code>;</code><em>expr<sub>fail</sub></em><code>]</code></p>
<p><code>.[</code><em>f<sub>mul</sub></em><code>;</code><em>L<sub>args</sub></em><code>;</code><em>expr<sub>fail</sub></em><code>]</code></p>
<p>Here <em>f<sub>mon</sub></em> is a unary function, <em>a</em> is single argument, <em>f<sub>mul</sub></em> is a multivalent function, <em>L<sub>args</sub></em> is a list of arguments, and <em>expr<sub>fail</sub></em> is an expression or function. In both forms, the function is applied to its argument(s). Upon successful application, protected evaluation returns the result of the application. Should an exception arise, <em>expr<sub>fail</sub></em> is applied to the resulting error string.</p>
<div class="admonition tip">
<p class="admonition-title">You can use protected evaluation to log error messages from exceptions that would otherwise crash your program.</p>
</div>
<div class="admonition important">
<p class="admonition-title">If the application of <em>expr<sub>fail</sub></em> results in an exception, the protected call itself will fail.</p>
</div>
<p>Here is a simple example of using protected evaluation. Suppose a user wishes to enter dynamic q expressions. You could place the expression in a string and pass it to <a href="https://code.kx.com/q/ref/value/"><code>value</code></a>, which is essentially the q interpreter. This is a huge security exposure and you should never do this in such a na√Øve fashion in a production system. Nonetheless, we could do it in a learning environment. The problem is that if the user types an invalid q expression, the generated exception will cause your application to halt. To avoid this, apply <code>value</code> with protected evaluation.</p>
<pre class="highlight"><code class="language-q">q)s:"6*7"
q)@[value; s; show]
42
q)s:"6*`7"
q)@[value; s; show]
"type"</code></pre>
<p>Ternary <code>.</code> provides similar protected evaluation for multi-valent functions.</p>
<pre class="highlight"><code class="language-q">q)prod:{x*y}
q).[prod; (6;7); show]
42
q).[prod; (6;`7); show]
"type"</code></pre>
<h2 id="102-debugging">10.2 Debugging</h2>
<p>Debugging in q harkens back to the bad old days, before the advent of debuggers and integrated development environments, when ‚Äúreal men‚Äù debugged by inserting <code>println</code> in their code. The q gods don‚Äôt give debugging much consideration because their code always runs correctly the first time. There is no debugger, nor any notion of break points or tracing execution. Things aren‚Äôt quite as bad as inserting print statements, but we mortals are certainly left to our own devices.</p>
<p>When expression evaluation fails, the console displays a backtick followed by a short and often cryptic error message. This is followed by a dump of the failed operation and the offending values. Many errors manifest as either <code>'type</code> or <code>'length</code>, indicating an incompatibility in function arguments somewhere in the bowels of q. The challenge is to discover the root cause of the error.</p>
<div class="admonition tip">
<p class="admonition-title">Update</p>
<p><a href="https://code.kx.com/q/basics/debug">Debugging</a> has become a bit easier since V3.5. <em>Ed.</em></p>
</div>
<p>Since q is interpreted, at any point in the execution of a program the entire runtime environment is accessible. If you think about it, an integrated debugger for a compiled language essentially simulates the interpreter environment. The debugger must go to great lengths to create the environment that is readily available in an interpreter.</p>
<p>Let‚Äôs get real. Say you want to set a breakpoint in your q program. Easy: just insert a line that you know will fail ‚Äì use an undefined name. For example, to pause execution before the last expression in the function <code>f</code> below, insert any undefined name there ‚Äì ‚Äúbreak‚Äù is commonly used.</p>
<pre class="highlight"><code class="language-q">q)f:{a:x*x; b:y*y; a+b}
q)f:{a:x*x; b:y*y; break; a+b}
q)f[3;4]
{a:x*x; b:y*y; break; a+b}
'break
q))</code></pre>
<div class="admonition tip">
<p class="admonition-title">Make sure the name you choose is not defined in local or global scope.</p>
</div>
<p>In a q session, you can tell that execution has been suspended by the extra parenthesis at the q prompt. At this point, you have the full power of the q console available to inspect the current state of your program.</p>
<pre class="highlight"><code class="language-q">q))x
3
q))y
4
q))a
_
q))b
_
q))a+b
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Once you have finished your inspection and debugging, you should either return from the function with a value or abort execution using <code>\</code>. In either case, the extra <code>)</code> at the q prompt will disappear.
</p><pre><code class="language-q">
q)):abs
25 
</code></pre>
</div>
<p>A slightly more sophisticated technique allows you to continue execution after the break. Here we cause the break one level lower. A forced return entered at the console completes the breakpoint execution and continues execution of <code>f</code>.</p>
<pre class="highlight"><code class="language-q">q)breakpoint:{break}
q)f:{a:x*x; b:y*y; breakpoint[]; a+b}
q)f[3;4]
{break}
'break
q)):0 / arbitrary value is not used
25</code></pre>
<p>You can accomplish single-step tracing after suspended execution by copy/paste of one line at a time into the console. Admittedly this is pretty primitive but if you write well-factored q code there shouldn‚Äôt be too many lines to copy. This works well enough in practice that it is not a hindrance to finding and correcting bugs.</p>
<div class="admonition tip">
<p class="admonition-title">You will spend much more time trying to figure out why your q code is not doing what you want than the time spent doing manual debugging.</p>
</div>
<p>In a technique passed on by Simon Garland, you can get a useful display of relevant information when a function is suspended. Define a function, say <code>zs</code>, as follows,</p>
<pre class="highlight"><code class="language-q">q)zs:{`d`P`L`G`D!(system"d"),v[1 2 3],enlist last v:value x}</code></pre>
<p>This function takes another function as its argument and returns a dictionary with entries for the current directory, function parameters, local variables referenced, global variables referenced and the function definition. We demonstrate with a trivial example.</p>
<pre class="highlight"><code class="language-q">q)b:7
q)f:{a:6; x+a*b}
q)f[`100] / this is an error
{a:6; x+a*b}
'type
+
`100
42
q))show zs f
d| `.
P| ,`x
L| ,`a
G| ``b
D| "{a:6; x+a*b}‚Äù</code></pre>
<p>This error dump is actually easy to read. The first line is the definition of the function that has failed. Following that is the error message <code>'type</code>. The operation that generated the error is <code>+</code> and the actual arguments follow. Then our <code>zs</code> gives a nice tabulation of the current context (the root namespace in this case), the parameters of <code>f</code>, the local variables of <code>f</code>, the global variables of <code>f</code> and finally its definition.</p>
<p>A good place to start with <code>zs</code> when you have suspended execution is with the system variable <code>.z.s</code> that holds the suspended function itself.</p>
<pre class="highlight"><code class="language-q">‚Ä¶
q))zs .z.s
_</code></pre>
<h2 id="103-scripts">10.3 Scripts</h2>
<p>A <em>script</em> is a q program stored in a text file with an extension of <code>.q</code> (or <code>.k</code> if you are writing k code). A script can contain any q expressions or commands. The contents of the script are parsed and evaluated sequentially from top to bottom. Global entities created during execution of the script exist in the workspace after the script is loaded and executed.</p>
<h3 id="1031-creating-and-loading-a-script">10.3.1 Creating and Loading a Script</h3>
<p>You can create a script in any text editor and save it with a <code>.q</code> extension. For example, enter the following script that creates the <code>trades</code> table from Chapter 9.</p>
<pre class="highlight"><code class="language-q">mktrades:{[tickers; sz]
  dt:2015.01.01+sz?31;
  tm:sz?24:00:00.000;
  sym:sz?tickers;
  qty:10*1+sz?1000;
  px:90.0+(sz?2001)%100;
  t:([] dt; tm; sym; qty; px);
  t:`dt`tm xasc t;
  t:update px:6*px from t where sym=`goog;
  t:update px:2*px from t where sym=`ibm;
  t}

trades:mktrades[`aapl`goog`ibm; 1000000]</code></pre>
<p>Now issue the following command to load and execute the script.</p>
<pre class="highlight"><code class="language-q">q)\l /q4m/trades.q</code></pre>
<p>Verify that the <code>trades</code> table has been created and the records have been inserted.</p>
<pre class="highlight"><code class="language-q">q)count trades
_</code></pre>
<p>A script can be loaded at any time during a session using the <code>\l</code> command, called <em>load</em>. The <a href="https://code.kx.com/q/basics/syscmds/#l-load-file-or-directory">load command</a> can be executed programmatically using <code>system</code>. See <a href="https://code.kx.com/q4m3/12_Workspace_Organization/">Chapter 12</a> for more on commands.</p>
<p>You can have q load a script on startup by placing its name after the call to the q executable on the operating system command line.</p>
<pre class="highlight"><code class="language-q">$q /q4m/trades.q
KDB+ 3.2 ‚Ä¶
q)
q)count trades
1000000</code></pre>
<h3 id="1032-blocks">10.3.2 Blocks</h3>
<p>You can comment out a block of code (i.e., multiple lines) in a script by surrounding it with matching <code>/</code> and <code>\</code> with each at the beginning of its own line. An unmatched <code>\</code> at the beginning of a line exits the script.</p>
<p>Here is a script that demonstrates block comments.</p>
<pre class="highlight"><code class="language-q">a:42
b:0
/
this is a block of
comment text
b:42
and b will not be changed
\
a:43 / this line will be executed
\
nothing from here on will be executed
b:44</code></pre>
<p>Immediately after this script is loaded, <code>a</code> will be 43 and <code>b</code> will be 0.</p>
<p>Multi-line expressions are permitted in a script but they have a special form.</p>
<ul>
<li>The first line must <strong>not</strong> be indented ‚Äì i.e., it begins at the left of the line with no initial whitespace.</li>
<li>Any continuation lines <strong>must</strong> be indented, meaning that there is at least one whitespace character at the beginning of the line.</li>
<li>In particular, if you put the closing brace to a function definition on its own line, it <strong>must</strong> be indented. Do <strong>not</strong> use the common C style of aligning the closing brace with the function name.</li>
<li>Empty lines and comment lines (beginning with <code>/</code>) are permitted anywhere.</li>
</ul>
<p>Table definition and function definition provide nice opportunities for splitting across multiple lines:</p>
<ul>
<li>A table can have line breaks after a closing square bracket <code>]</code> or after a semicolon separator <code>;</code></li>
<li>A function can have line breaks after a closing square bracket <code>]</code> or after a comma separator <code>,</code>.</li>
</ul>
<h3 id="1033-passing-parameters">10.3.3 Passing Parameters</h3>
<p>Parameters are passed to a q script at q startup similarly to <code>argv</code> command line parameters in C. Specifically, the system variable <a href="https://code.kx.com/q/ref/dotz/#zx-argv"><code>.z.x</code></a> comprises a list of strings, each containing the character representation of an argument present on the command line that invoked the script. For example, let‚Äôs modify our <code>trades.q</code> script to pass the number of records to be created as a command line parameter. Note that we parse the passed string to an integer.</p>
<pre class="highlight"><code class="language-q">mktrades:{[tickers; sz]
  dt:2015.01.01+sz?31;
  tm:sz?24:00:00.000;
  sym:sz?tickers;
  qty:10*1+sz?1000;
  px:90.0+(sz?2001)%100;
  t:([] dt; tm; sym; qty; px);
  t:`dt`tm xasc t;
  t:update px:6*px from t where sym=`goog;
  t:update px:2*px from t where sym=`ibm;
  t}

size:"I"$.z.x 0

trades:mktrades[`aapl`goog`ibm; size]</code></pre>
<p>Now we invoke the script with the parameter 2000000.</p>
<pre class="highlight"><code class="language-q">&gt;q /q4m/trades.q 2000000
KDB+ 3.2 ‚Ä¶
q)count trades
2000000</code></pre>
<p>As of this writing (Sep 2015), parameters can be passed when a script is loaded at q startup but <strong>not</strong> when a script is loaded with <code>\l</code> or system ‚Äúl‚Äù.</p>
<div class="admonition warning">
<p class="admonition-title">If you put any extra space immediately after <code>\l</code> you will get an error.</p>
</div>
                


                
              
              
                


              
            </article>
            
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))for(var set of document.querySelectorAll("[data-tabs]")){var labels=set.querySelectorAll(":scope > label");e:for(var tab of tabs)for(var label of labels)if(label.innerText.trim()===tab){var input=label.previousElementSibling;input.checked=!0;break e}}</script>

          </div>
        </div>
        
          
        
      
                </div>
            </section>
        
            <section class="chapter" id="chapter-3">
                <div class="chapter-header">
                    <h1 class="chapter-title">11. I/O¬∂</h1>
                    <div class="chapter-meta">
                        <span>üìñ Source: <a href="https://code.kx.com/q4m3/11_IO/">https://code.kx.com/q4m3/11_IO/</a></span>
                        <span>üìù 8212 words</span>
                        
                    </div>
                </div>
                <div class="chapter-content">
                    
        <div class="md-main__inner md-grid">
          
            
              
              
            
            
              
              
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                
                <h1 id="11-io">11. I/O</h1>
<h2 id="110-overview">11.0 Overview</h2>
<p>I/O in q is one of the most powerful and succinct features of the language. The names and behavior of the functions are idiosyncratic but the economy of expression is unrivaled.</p>
<p>I/O is realized via <em>handles</em>, which are symbolic names of resources such as files or machines on a network. One-and-done operations can be performed directly on the symbolic handle ‚Äì e.g., you can read a file into memory in a single operation. For continuing operations, you open the symbolic handle to obtain an <em>open handle</em>. The open handle is a function that is applied to perform operations. When you have completed the desired operations, you close the open handle to free any allocated resources.</p>
<h2 id="111-binary-data">11.1 Binary Data</h2>
<p>In q, files come in two flavors: text and binary. Routines to process text data have ‚Äò0‚Äô in their names, whereas routines to process binary data have ‚Äò1‚Äô. A text file is considered to be a list of strings ‚Äì i.e., a list of char lists ‚Äì and a binary file is a list of byte lists. While all text files can also be processed as binary data, not all binary data represents text. As mentioned above, file operations use handles.</p>
<h3 id="1111-file-handles">11.1.1 File Handles</h3>
<p>A <em>file handle</em> is a symbol that represents the name of a directory or file on persistent storage. A symbolic file handle starts with a colon <code>:</code> and has the form,</p>
<p><code>`:</code>[<em>path</em>]<em>name</em></p>
<p>where the bracketed expression represents an optional path and <em>name</em> is a file or directory name. The combination should be recognized as valid by the underlying operating system.</p>
<div class="admonition tip">
<p class="admonition-title">Some q operations require that you append a trailing slash <code>/</code> to indicate that you mean a directory. We will point these out.</p>
</div>
<p>It is generally easier to work with paths and names as strings so that blanks and other special characters can be handled easily. While <code>`$</code> converts a string to a symbol, it can be awkward to include the leading <code>:</code> required in the symbolic handle. The keyword <a href="https://code.kx.com/q/ref/hsym/"><code>hsym</code></a>, which inserts a leading colon into a symbol, serves this purpose.</p>
<pre class="highlight"><code class="language-q">q)hsym `$"/data/file name.csv"
`:/data/file name.csv</code></pre>
<p>Note that q always represents separators in paths by the forward slash <code>/</code>, even when running on Windows. If you run q on Windows, you can type either <code>/</code> or <code>\</code> but q will always display <code>/</code> in its response.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>To make life easier when you are generating paths dynamically, <code>hsym</code> is idempotent, meaning that it will accept its own output and pass it through.
</p><pre><code class="language-q">
q)hsym hsym `$"/data/file name.csv"
_
</code></pre>
</div>
<h3 id="1112-hcount-and-hdel">11.1.2 <code>hcount</code> and <code>hdel</code></h3>
<p>The first one-and-done operation that works directly on a symbolic file handle is <a href="https://code.kx.com/q/ref/hcount/"><code>hcount</code></a>, which returns a long representing the size of the file in bytes as reported by the OS.</p>
<pre class="highlight"><code class="language-q">q)hcount `:/data/solong.txt
35</code></pre>
<p>The next one-and-done is <a href="https://code.kx.com/q/ref/hdel/"><code>hdel</code></a>, which instructs the OS to remove the file specified by its symbolic handle operand.</p>
<pre class="highlight"><code class="language-q">q)hdel `:/data/solong.txt
`:/data/solong.txt</code></pre>
<p>Some notes.</p>
<ul>
<li>The return value of the symbolic file handle itself indicates that the deletion was successful. It should not be confused with an error message, which starts with a tick rather than a backtick.</li>
<li>You will get an error message if the file does not exist or if the delete cannot be performed.</li>
<li>You will not be prompted for confirmation. Back up any files that are important.</li>
</ul>
<h3 id="1113-serializing-and-deserializing-q-entities">11.1.3 Serializing and Deserializing q Entities</h3>
<p>Every q entity can be serialized and persisted to storage. Unlike traditional languages, where you must instantiate serializers and writers, things are simple and direct in q. This is because q data is self-describing, so that its internal representation can be written out as a sequence of bytes and then read directly back into memory. This is as close to the Star Trek transporter as we are likely to get.</p>
<p>The magic is done by (an overload of) the binary <a href="https://code.kx.com/q/ref/get/#set"><code>set</code></a>, whose left operand is a file handle and right operand is the entity to be written. The result is the symbolic handle of the written file. The file is automatically closed once the write is complete.</p>
<pre class="highlight"><code class="language-q">q)`:/data/a set 42
`:/data/a
q)`:/data/L set 10 20 30
_
q)`:/data/t set ([] c1:`a`b`c; c2:10 20 30)
_</code></pre>
<div class="admonition note">
<p class="admonition-title">The behavior of <code>set</code> is to create the file if it does not exist and overwrite it if it does. It will also create the directory path if it does not exist.</p>
</div>
<p>A serialized q data file can be read using (an overload of) the unary <code>get</code>, whose argument is a symbolic file handle and whose result is the q entity contained in the data file.</p>
<pre class="highlight"><code class="language-q">q)get `:/data/a
42
q)get `:/data/L
_
q)get `:/data/t
_</code></pre>
<p>An equivalent way to read a data file is with (an overload of) <a href="https://code.kx.com/q/ref/value/"><code>value</code></a>.</p>
<pre class="highlight"><code class="language-q">q)value `:/data/t
_</code></pre>
<p>Alternatively, you can use the command <code>\l</code> to load a data file into memory and assign it to a variable with the same name as the file. Here you do <strong>not</strong> use a file handle; rather, specify the path to the file without any decoration. In a fresh q session,</p>
<pre class="highlight"><code class="language-q">q)t
't
q)\l /data/t
`t
q)t
_</code></pre>
<h3 id="1114-binary-data-files">11.1.4 Binary Data Files</h3>
<p>As with traditional languages, for continuing operations on a q data file, you open the file, perform the operation(s) and then close it. Unlike traditional languages, opening a symbolic handle returns a function, called an open handle, that is used to perform operations.</p>
<p>As mentioned previously, q files come in two flavors, binary and text. Serialized q data persisted with <code>set</code> is written in binary form with a header at the beginning of the file. You can read it as raw binary data to inspect its internals.</p>
<p>Open a data file handle with <a href="https://code.kx.com/q/ref/hopen/"><code>hopen</code></a>, whose result is a function called the <em>open handle</em>. This function should be stored in a variable, traditionally <code>h</code>, which is functionally applied to data to write it to the file. We will explain the result of applying the open handle shortly. We begin with a file containing serialized q data and show how to append to it.</p>
<pre class="highlight"><code class="language-q">q)`:/data/L set 10 20 30
`:/data/L
q)h:hopen `:/data/L
q)h[42]
3i
q)h 100 200
3i</code></pre>
<div class="admonition tip">
<p class="admonition-title">Always apply <a href="https://code.kx.com/q/ref/hclose/"><code>hclose</code></a> to the open handle to close it and flush any data that might be buffered.</p>
<p>Failure to do so may cause your program to run out of file handles unnecessarily.</p>
</div>
<p>We verify that the appends have been made.</p>
<pre class="highlight"><code class="language-q">q)hclose h
q)get `:/data/L
10 20 30 42 100 200</code></pre>
<p>We can also create a new file and write raw binary data to it.</p>
<pre class="highlight"><code class="language-q">q)h:hopen `:/data/raw
q)h[42]
3i
q)h 10 20 30
3i
q)hclose h</code></pre>
<p>Now, what is the deal with the <code>3i</code> return value of applying the open handle?</p>
<pre class="highlight"><code class="language-q">q)h:hopen `:/data/raw
q)h 43
3i</code></pre>
<p>In fact, the return value is the value of the open handle itself.</p>
<pre class="highlight"><code class="language-q">q)h
3i</code></pre>
<p>Surely, you say, we can‚Äôt use an int as a function to write data. But you would be wrong.</p>
<pre class="highlight"><code class="language-q">q)h:hopen `:/data/new
q)h
3i
q)3i[100 200 300]
3i
q)hclose 3i
q)get `:/data/new
_</code></pre>
<blockquote>
<p>The last expression above signals an error. <code>get</code> requires a file to be initialized by <code>set</code>. But appending data to a file initialized by <code>set</code> is neither reliable nor recommended. <em>Ed.</em></p>
</blockquote>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Apparently q assigns an int to each open file and keeps track of which int values are valid handles. This accounts for the cryptic error message when you attempt to use variables with simple list notation.</p>
</div>
<pre class="highlight"><code class="language-q"> q)a:42
 q)b:43
 q)a b
 ': Bad file descriptor</code></pre>
<h3 id="1115-writing-and-reading-binary">11.1.5 Writing and Reading Binary</h3>
<p>Apply <code>read1</code> on a file handle to read <strong>any</strong> file into q as a list of bytes. For example, we can read the previously serialized value <code>L</code> as bytes.</p>
<pre class="highlight"><code class="language-q">q)read1 `:/data/L set 10 20 30
0xfe2007000000000003000000000000000a0000000000000014000000000000001e..</code></pre>
<p>This shows the internal representation of the serialized q entity. How cool is that?</p>
<p>If you want to write raw binary data, as opposed to the internal representation of a q entity containing the data, use the infelicitously named <a href="https://code.kx.com/q/ref/file-text" title="File Text"><code>1:</code></a>. It takes a symbolic file handle as its left argument and a simple byte list as its right argument. Bytes in the right operand are essentially streamed to the file.</p>
<pre class="highlight"><code class="language-q">q)`:/data/answer.bin 1: 0x06072a
`:/data/answer.bin
q)read1 `:/data/answer.bin
0x06072a</code></pre>
<h3 id="1116-using-apply-amend">11.1.6 Using Apply Amend</h3>
<p>Fundamentalists can use Apply Amend in place of <code>set</code> to serialize q entities to files. To write the file, or overwrite an existing file, use assign <code>:</code>.</p>
<pre class="highlight"><code class="language-q">q).[`:/data/raw; (); :; 1001 1002 1003]
`:/data/raw
q)get `:/data/raw
1001 1002 1003</code></pre>
<p>To append to an existing file use <code>,</code>.</p>
<pre class="highlight"><code class="language-q">q).[`:/data/raw; (); ,; 42]
`:/data/raw
q)get `:/data/raw
1001 1002 1003 42</code></pre>
<h2 id="112-save-and-load-on-tables">11.2 Save and Load on Tables</h2>
<p>We have already seen that it is easy to write and read tables to/from persistent storage.</p>
<pre class="highlight"><code class="language-q">q)`:/data/t set ([] c1:`a`b`c; c2:10 20 30; c3:1.1 2.2 3.3)
`:/data/t
q)get `:/data/t
_</code></pre>
<p>The <a href="https://code.kx.com/q/ref/save/"><code>save</code></a> and <a href="https://code.kx.com/q/ref/load/"><code>load</code></a> functions make this even easier.</p>
<p>In its simplest form, <code>save</code> serializes a table in a <strong>global</strong> variable to a binary file having the same name as the variable. It overwrites an existing file.</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:`a`b`c; c2:10 20 30; c3:1.1 2.2 3.3)
q)save `:/data/t
`:/data/t
q)get `:/data/t
_</code></pre>
<p>This is equivalent to using <code>set</code> above with the table name as file name.</p>
<p>As you might expect, <code>load</code> is the inverse of <code>save</code> meaning that it reads a serialized table from a file into a variable with the same name as the file. It creates the variable in the workspace or overwrites it if it already exists.</p>
<p>In a fresh q session after <code>t</code> has been saved as above,</p>
<pre class="highlight"><code class="language-q">q)t / t doesn't exist
't
q)load `:/data/t
`t
q)t / now it does
_</code></pre>
<p>You can also use <code>save</code> to write a table to a text file. You determine the format of the text with the file extension in the file handle.</p>
<div class="admonition tip">
<p class="admonition-title">All the following versions of <code>save</code> can also be performed with the more general <code>0:</code> ‚Äì see <a href="#115-parsing-records">¬ß11.5</a>.</p>
</div>
<p>Save the table with <code>.txt</code> extension to obtain tab-delimited records. There is no corresponding <code>load</code> but you can parse the text file ‚Äì see <a href="#1151-fixed-width-records">¬ß11.5.1</a>.</p>
<pre class="highlight"><code class="language-q">q)save `:data/t.txt
`:data/t.txt</code></pre>
<p>The resulting file is</p>
<pre class="highlight"><code class="language-text">c1\tc2\tc3
a\t10\t1.1
b\t20\t2.2
c\t30\t3.3</code></pre>
<p>Save the table with <code>.csv</code> extension to obtain comma-separated values. There is no corresponding <code>load</code> but you can parse the CSV file ‚Äì see <a href="#1152-variable-length-records">¬ß11.5.2</a>.</p>
<pre class="highlight"><code class="language-q">q)save `:data/t.csv
`:data/t.csv</code></pre>
<p>The resulting file is</p>
<pre class="highlight"><code class="language-csv">c1,c2,c3
a,10,1.1
b,20,2.2
c,30,3.3</code></pre>
<p>Save the table with <code>.xml</code> extension to obtain XML records. There is no direct way to read XML into q although libraries have been contributed ‚Äì see <a href="https://code.kx.com/q/github">code.kx.com</a>.</p>
<pre class="highlight"><code class="language-q">q)save `:data/t.xml
`:data/t.xml</code></pre>
<p>The resulting file is</p>
<pre class="highlight"><code class="language-html">&lt;R&gt;
&lt;r&gt;&lt;c1&gt;a&lt;/c1&gt;&lt;c2&gt;10&lt;/c2&gt;&lt;c3&gt;1.1&lt;/c3&gt;&lt;/r&gt;
&lt;r&gt;&lt;c1&gt;b&lt;/c1&gt;&lt;c2&gt;20&lt;/c2&gt;&lt;c3&gt;2.2&lt;/c3&gt;&lt;/r&gt;
&lt;r&gt;&lt;c1&gt;c&lt;/c1&gt;&lt;c2&gt;30&lt;/c2&gt;&lt;c3&gt;3.3&lt;/c3&gt;&lt;/r&gt;
&lt;/R&gt;</code></pre>
<p>Save the table with <code>.xls</code> extension obtain an Excel spreadsheet. This file can be loaded by Excel work-alikes.</p>
<pre class="highlight"><code class="language-q">q)save `:data/t.xls
`:data/t.xls</code></pre>
<h2 id="113-splayed-tables">11.3 Splayed Tables</h2>
<p>We have already seen how to persist a table to a file using <code>set</code>. There are no restrictions on the types of columns in the table or the file name in this scenario.</p>
<pre class="highlight"><code class="language-q">q)`:/data/t set ([] c1:`a`b`c; c2:10 20 30; c3:1.1 2.2 3.3)
`:/data/t
q)get `:/data/t
_</code></pre>
<p>This creates a single file, as the OS verifies.</p>
<pre class="highlight"><code class="language-q">&gt;ls -l /data/t
-rw-r--r-- 1 jeffry wheel 98 Mar 6 08:22 /data/t</code></pre>
<p>For larger tables that may not fit into memory on all machines, you can ask q to serialize each column of the table to its own file in a specified directory. A table persisted in this form is called a <em>splayed</em> table. The advantage is that when querying a <a href="https://code.kx.com/q/kb/splayed-tables/">splayed table</a>, only the columns referred to in the query will be loaded into memory. This is a substantial memory win for a table having many columns.</p>
<div class="admonition tip">
<p class="admonition-title">It is worthwhile looking up the origin of the English word ‚Äúsplay‚Äù. Also, please don‚Äôt spay your tables.</p>
</div>
<p>To splay a table, use <code>set</code> and specify a directory as the target location indicated by a trailing slash <code>/</code> in the left operand.</p>
<pre class="highlight"><code class="language-q">q)`:/data/tsplay/ set ([] c1:10 20 30; c2:1.1 2.2 3.3)
`:/data/tsplay/</code></pre>
<p>List the directory in the OS and you will see a directory <code>tsplay</code> that contains three files, one file for each column in the original table, as well as a hidden <code>.d</code> file.</p>
<pre class="highlight"><code class="language-q">&gt;ls -l -d /data/tsplay
drwxr-xr-x 5 jeffry wheel 170 Mar 6 08:36 /data/tsplay
&gt;ls -l -a /data/tsplay
total 24
drwxr-xr-x 5 jeffry wheel 170 Mar 6 08:36 .
drwxr-xr-x 9 jeffry wheel 306 Mar 6 08:36 ..
-rw-r--r-- 1 jeffry wheel 14 Mar 6 08:36 .d
-rw-r--r-- 1 jeffry wheel 40 Mar 6 08:36 c1
-rw-r--r-- 1 jeffry wheel 40 Mar 6 08:36 c2</code></pre>
<p>Nearly all the metadata regarding the splayed table can be read from the file system ‚Äì i.e., the name of table from directory and names of the columns from the files. The one missing bit is the order of the columns, which is stored as a serialized list in the hidden <code>.d</code> file.</p>
<pre class="highlight"><code class="language-q">q)get hsym `$"/data/tsplay/.d"
`c1`c2</code></pre>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>There are restrictions on tables that can be splayed.</p>
<ul>
<li>All columns must be simple or <em>compound</em> lists. The latter means a list of simple lists of uniform type. An arbitrary general list column cannot be splayed.</li>
<li>Symbol columns must be enumerated.</li>
</ul>
</div>
<p>Thus the following succeed.</p>
<pre class="highlight"><code class="language-q">q)`:/data/tok/ set ([] c1:2000.01.01+til 3; c2:1 2 3)
`:/data/tok/
q)`:/data/tok/ set ([] c1:1 2 3; c2:(1.1 2.2; enlist 3.3; 4.4 5.5))
`:/data/tok/</code></pre>
<p>And the following fail.</p>
<pre class="highlight"><code class="language-q">q)`:/data/toops/ set ([] c1:1 2 3; c2:(1;`1;"a"))
k){$[@x;.[x;();:;y];-19!((,y),x)]}
'type
q)`:/data/toops/ set ([] c1:`a`b`c; c2:10 20 30)
k){$[@x;.[x;();:;y];-19!((,y),x)]}
'type</code></pre>
<div class="admonition note">
<p class="admonition-title">The first <code>set</code> above works in later versions of kdb+. <em>[Ed.]</em></p>
</div>
<p>The convention for enumerating symbols in splayed tables is to enumerate all symbol columns in all tables over the domain <code>sym</code> and store the resulting sym list in the root directory ‚Äì i.e., one level above the directory holding the splayed table. You can do this manually but practically no one does.</p>
<pre class="highlight"><code class="language-q">q)`:/db/tsplay/ set ([] `sym?c1:`a`b`c; c2:10 20 30)
`:/db/tsplay/
q)sym
`a`b`c
q)`:/db/sym set sym
`:/db/sym</code></pre>
<p>Normally folks use one of the <code>.Q</code> utilities, in spite of the official KX admonition not to use them. For example, here we use <code>.Q.en</code>.</p>
<pre class="highlight"><code class="language-q">q)`:/db/tsplay/ set .Q.en[`:/db; ([] c1:`a`b`c; c2:10 20 30)]
`:/db/tsplay/</code></pre>
<p>Only unofficially documented, <code>.Q.en</code> prepares a qualified table for splaying by enumerating all its symbol columns. The first argument is the symbolic file handle of the root directory for the persistent residence of the enumeration domain <code>sym</code> (no choice in the name). The second argument is a table. See <a href="https://code.kx.com/q4m3/14_Introduction_to_Kdb%2B/#1452-qen">¬ß14.5.2</a> for more detail on its behavior.</p>
<div class="admonition tip">
<p class="admonition-title">Update: <code>.Q</code> is now documented at <a href="https://code.kx.com/q/ref/dotq">code.kx.com</a>. <em>Ed.</em></p>
</div>
<h2 id="114-text-data">11.4 Text Data</h2>
<p>We have seen that q views a record in a binary data file as a list of bytes. Similarly, a record in a text file is viewed as a list of char ‚Äì i.e., a string. Thus reading a text file results in a list of strings and you pass a list of strings to write to a text file.</p>
<h3 id="1141-reading-and-writing-text-files">11.4.1 Reading and Writing Text Files</h3>
<p>Read a text file with the unary <a href="https://code.kx.com/q/ref/read0/"><code>read0</code></a> that takes a symbolic file handle argument. The result is a list of strings, one for each line in the file. For the file <code>/data/solong.txt</code> with content,</p>
<pre class="highlight"><code class="language-txt">So long
and thanks
for all the fish</code></pre>
<p>we find,</p>
<pre class="highlight"><code class="language-q">q)read0 `:/data/solong.txt
"So long"
"and thanks"
"for all the fish"</code></pre>
<p>You can see the underlying binary values of the text by using <a href="https://code.kx.com/q/ref/read1/"><code>read1</code></a> or casting the result of <code>read0</code> to bytes.</p>
<pre class="highlight"><code class="language-q">q)read1 `:/data/solong.txt
_
q)"x"$read0 `:/data/solong.txt
0x4c696665
0x54686520556e697665727365
0x416e642045766572797468696e67</code></pre>
<p>Or you can read the data as binary and cast the result to char. Observe that the data is a simple list of char so the newline character does not cause line breaks in the console display.</p>
<pre class="highlight"><code class="language-q">q)"c"$read1 `:/data/solong.txt
"Life\nThe Universe\nAnd Everything\n"</code></pre>
<p>To write string as text, use the (infelicitously named) binary <a href="https://code.kx.com/q/ref/file-text/" title="File Text"><code>0:</code></a>, which takes a file handle in the left operand and a list of strings in the right operand. It creates the directory path if necessary and overwrites the file if it already exists.</p>
<pre class="highlight"><code class="language-q">q)`:/data/solong.txt 0: ("Life"; "The Universe"; "And Everything")
`:/data/solong.txt
q)read0 `:/data/solong.txt
_</code></pre>
<h3 id="1142-using-hopen-and-hclose">11.4.2 Using <code>hopen</code> and <code>hclose</code></h3>
<p>Just as with a binary data file, a symbolic text file handle can be opened with <code>hopen</code>. The result is again an int that is conventionally stored in the variable <code>h</code> and is used with function application syntax to write data. The difference is that instead of using plain <code>h</code> to write binary data, you use <code>neg[h]</code> to write strings as text. Seriously.</p>
<pre class="highlight"><code class="language-q">q)h:hopen `:/data/new.txt
q)neg[h] enlist "This"
-3i
q)neg[h] ("and"; "that")
-3i
q)hclose h
q)read0 `:/data/new.txt
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Observe that you apply <code>hclose</code> to <code>h</code>, not to <code>neg[h]</code>.</p>
</div>
<p>If the file already exists, opening with <code>hopen</code> and applying the open handle will append rather than overwrite.</p>
<pre class="highlight"><code class="language-q">q)h:hopen `:/data/new.txt
q)neg[h] ("and"; "more")
-3i
q)hclose h
q)read0 `:/data/new.txt
_</code></pre>
<h3 id="1143-preparing-text">11.4.3 Preparing Text</h3>
<p>We saw the built-in functions for saving tables as text files in <a href="#112-save-and-load-on-tables">¬ß11.2</a>. When you need to control the filename, you can write the table yourself with <code>0:</code>, but then you must prepare the table columns as formatted text. A separate overload of <code>0:</code> is available for this purpose. A confusing naming convention, to say the least.</p>
<p>In this use, <code>0:</code> has as left operand a char delimiter and as right operand a table or list of columns. Observe the use of the pre-defined constant <code>csv</code>, which is simply <code>","</code>.</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:`a`b`c; c2:1 2 3)
q)"\t" 0: t
"c1\tc2"
"a\t1"
"b\t2"
"c\t3"
q)"|" 0: t
_
q)csv
","
q)csv 0: t
_
q)`:/data/t.csv 0: csv 0: t
_</code></pre>
<p>In the last snippet we applied <code>0:</code> with two different meanings: to prepare and then write text. We hope you‚Äôve grown fond of this name, since <a href="#115-parsing-records">¬ß11.5</a> will introduce yet another version of <code>0:</code> for parsing text records.</p>
<h2 id="115-parsing-records">11.5 Parsing Records</h2>
<p>Binary forms of <code>0:</code> and <a href="https://code.kx.com/q/ref/file-binary/" title="File Binary"><code>1:</code></a> parse individual fields according to data type from text or binary records. Field parsing is based on the following field types.</p>
<table>
<thead>
<tr>
<th><em>0</em></th>
<th><em>1</em></th>
<th><em>Type</em></th>
<th><em>Width(1)</em></th>
<th>*Format(0) *</th>
</tr>
</thead>
<tbody>
<tr>
<td>B</td>
<td>b</td>
<td>boolean</td>
<td>1</td>
<td>[1tTyY]</td>
</tr>
<tr>
<td>X</td>
<td>x</td>
<td>byte</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>H</td>
<td>h</td>
<td>short</td>
<td>2</td>
<td>[0-9a-fA-F][0-9a-fA-F]</td>
</tr>
<tr>
<td>I</td>
<td>i</td>
<td>int</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>J</td>
<td>j</td>
<td>long</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>E</td>
<td>e</td>
<td>real</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>F</td>
<td>f</td>
<td>float</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>C</td>
<td>c</td>
<td>char</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>S</td>
<td>s</td>
<td>symbol</td>
<td>n</td>
<td></td>
</tr>
<tr>
<td>P</td>
<td>p</td>
<td>timestamp</td>
<td>8</td>
<td>date?timespan</td>
</tr>
<tr>
<td>M</td>
<td>m</td>
<td>month</td>
<td>4</td>
<td>[yy]yy[?]mm</td>
</tr>
<tr>
<td>D</td>
<td>d</td>
<td>date</td>
<td>4</td>
<td>[yy]yy[?]mm[?]dd or [m]m/[d]d/[yy]yy</td>
</tr>
<tr>
<td>Z</td>
<td>z</td>
<td>datetime</td>
<td>8</td>
<td>date?time</td>
</tr>
<tr>
<td>N</td>
<td>n</td>
<td>timespan</td>
<td>8</td>
<td>hh[:]mm[:]ss[[.]ddddddddd]</td>
</tr>
<tr>
<td>U</td>
<td>u</td>
<td>minute</td>
<td>4</td>
<td>hh[:]mm</td>
</tr>
<tr>
<td>V</td>
<td>v</td>
<td>second</td>
<td>4</td>
<td>hh[:]mm[:]ss</td>
</tr>
<tr>
<td>T</td>
<td>t</td>
<td>time</td>
<td>4</td>
<td>hh[:]mm[:]ss[[.]ddd]</td>
</tr>
<tr>
<td>blank</td>
<td>skip</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>*</td>
<td></td>
<td></td>
<td></td>
<td>literal chars</td>
</tr>
</tbody>
</table>
<p>The column labeled ‚Äò0‚Äô contains the (upper case) field type char for text data. The (lower case) char in column ‚Äò1‚Äô is for binary data. The column labeled ‚ÄòWidth(1)‚Äô contains the number of bytes that will be parsed for a binary read. The column labeled ‚ÄòFormat(0)‚Äô displays the format(s) that are accepted in a text read.</p>
<div class="admonition tip">
<p class="admonition-title">The parsed records are returned in column form rather than row form to make it easy to associate a list of symbol names with <code>!</code> and then flip into a table.</p>
</div>
<h3 id="1151-fixed-width-records">11.5.1 Fixed-Width Records</h3>
<p>The binary form of <code>0:</code> and <code>1:</code> for reading fixed length files is,</p>
<p><code>(</code><em>L<sub>t</sub></em><code>;</code><em>L<sub>w</sub></em><code>) 0:</code><em>f</em></p>
<p><code>(</code><em>L<sub>t</sub></em><code>;</code><em>L<sub>w</sub></em><code>) 1:</code><em>f</em></p>
<p>The left operand is a nested list containing two items: <em>L<sub>t</sub></em> is a simple list of char containing one letter per field; <em>L<sub>w</sub></em> is a simple list of int containing one integer width per field. The sum of the field widths in <em>L<sub>w</sub></em> should equal the width of the record. The result of the function is a list of lists, one list arising from each field.</p>
<p>We demonstrate <code>0:</code> here since it is more commonly used; <code>1:</code> works analogously. The simplest form of the right operand <em>f</em> is a symbolic file handle. For example, suppose we have a file with records of the form,</p>
<pre class="highlight"><code class="language-q">1001  98.000ABCDEF1234Garbage2015.01.01
1002  42.001GHUJKL0123Garbage2015.01.02
1003  44.123nopqrs9876Garbage2015.01.03</code></pre>
<p>We could parse the records of the file with,</p>
<pre class="highlight"><code class="language-q">q)("JFS D";4 8 10 7 10) 0: `:/data/Fixed.txt
1001 1002 1003
98 42.001 44.123
ABCDEF1234 GHUJKL0123 nopqrs9876
2015.01.01 2015.01.02 2015.01.03</code></pre>
<p>This reads a text file containing fixed length records of width 39. The first field is a long occupying 4 positions; the second field is a float occupying 8 positions; the third field consists of a symbol occupying 10 positions; the fourth slot of 6 positions is ignored; the fifth field is a date occupying 10 positions.</p>
<p>You might think that the widths are superfluous, but they are not. The actual data width can be narrower than the normal size due to small values, as in our case of the long field. Or you may need to specify a width larger than that required by the corresponding data type due to whitespace in the fields, as in the case of our float field.</p>
<p>Observe how easy it is to make a table from the result.</p>
<pre class="highlight"><code class="language-q">q)flip `c1`c2`c3`c4!("JFS D";4 8 10 7 10) 0: `:/data/Fixed.txt
c1   c2     c3         c4
---------------------------------
1001 98     ABCDEF1234 2015.01.01
1002 42.001 GHUJKL0123 2015.01.02
1003 44.123 nopqrs9876 2015.01.03</code></pre>
<p>Also note that it is possible to parse a list of strings using the same format, since they represent text records in memory.</p>
<pre class="highlight"><code class="language-q">q)fixed: read0 `:/data/Fixed.txt
q)("JFS D";4 8 10 7 10) 0: fixed
_</code></pre>
<p>The more general form for the right operand <em>f</em> is,</p>
<p><code>(</code><em>h<sub>file</sub></em><code>;</code><em>i</em><code>;</code><em>n</em><code>)</code></p>
<p>where <em>h<sub>file</sub></em> is a symbolic file handle, <em>i</em> is the offset into the file to begin reading and <em>n</em> is the number of bytes to read. This is useful for sampling a file or for large files that cannot be read into memory in a single gulp.</p>
<div class="admonition tip">
<p class="admonition-title">A read operation should begin and end on record boundaries or you will get meaningless results.</p>
</div>
<p>In our trivial example, the following reads just the second and third records,</p>
<pre class="highlight"><code class="language-q">q)("JFS D";4 8 10 7 10) 0: (`:/data/Fixed.txt; 40; 80)
_</code></pre>
<h3 id="1152-variable-length-records">11.5.2 Variable Length Records</h3>
<p>The binary form of <code>0:</code> and <code>1:</code> for reading variable length, delimited files is</p>
<p><code>(</code><em>L<sub>t</sub></em><code>;</code><em>D</em><code>) 0:</code><em>f</em></p>
<p><code>(</code><em>L<sub>t</sub></em><code>;</code><em>D</em><code>) 1:</code><em>f</em></p>
<p>The left operand is a list comprising two lists. <em>L<sub>t</sub></em> is a simple list of char containing one type letter per corresponding field. <em>D</em> is either a char representing the delimiting character or an enlisted char.</p>
<p>Specify <em>D</em> as a delimiter char when the first record of the file does <strong>not</strong> contain column names. In this case, the result of the parse is a list of <strong>column</strong> lists, each of which contains items of type specified by <em>L<sub>t</sub></em>. The simplest form of the right operand <em>f</em> is a symbolic file handle.</p>
<p>For example, say we have a comma-separated file <code>/data/Simple.csv</code> having records
</p><pre class="highlight"><code class="language-q">1001,DBT12345678,98.6
1002,EQT98765432,24.75
1004,CCR00000001,121.23</code></pre>
Parsing with a delimiter char <code>","</code> results in a list of column lists. As with parsing fixed format records, it is easy to make the result into a table.
<pre class="highlight"><code class="language-q">q)("JSF"; ",") 0: read0 `:/data/Simple.csv
1001        1002        1004
DBT12345678 EQT98765432 CCR00000001
98.6        24.7        121.23
q)flip `c1`c2`c3!("JSF"; ",") 0: read0 `:/data/Simple.csv
_</code></pre>
Observe that it is possible to retrieve the second field as a string instead of a symbol using <code>"*"</code> as the data type specifier,
<pre class="highlight"><code class="language-q">q)("J*F"; ",") 0: read0 `:/data/Simple.csv
1001          1002          1004
"DBT12345678" "EQT98765432" "CCR00000001"
98.6          24.7          121.23</code></pre>
Specify <em>D</em> as an enlisted char when the first record contains a separated list of names. Subsequent records are read as data specified by the types in <em>L<sub>t</sub></em>. The result is a table in which the column names are taken from the first record.
<p>Say we have a comma-separated file <code>/data/Titles.csv</code> having records,
</p><pre class="highlight"><code class="language-q">id,ticker,price
1001,DBT12345678,98.6
1002,EQT98765432,24.7
1004,CCR00000001,121.23</code></pre>
Reading with an enlisted <code>","</code> delimiter results in a table.
<pre class="highlight"><code class="language-q">q)("JSF"; enlist ",") 0: `:/data/Titles.csv
id  ticker       price
-----------------------
1001 DBT12345678 98.6
1002 EQT98765432 24.7
1004 CCR00000001 121.23</code></pre>
<h3 id="1153-key-value-records">11.5.3 Key-Value Records</h3>
<p>The operator <code>0:</code> can also be used to process text representing key-value pairs. In this situation, the left operand is a three-character string P<sub>f</sub> that specifies the pair format. The first char of P<sub>f</sub> can be "S" to indicate the key is a string or "I" to indicate the key is an integer. The second char indicates the key-value separator. The third char indicates the pair delimiter.</p>
<p>The following examples illustrate various combinations in P<sub>f</sub>.</p>
<pre class="highlight"><code class="language-q">q)"S=;" 0: "one=1;two=2;three=3"
one two three
,"1" ,"2" ,"3"
q)"S:/" 0: "one:1/two:2/three:3"
_
q)"I=;" 0: "1=one;2=two;3=three"
_</code></pre>
<p>Again it is easy to make the result into a table.</p>
<pre class="highlight"><code class="language-q">q)flip `k`v!"I=;" 0: "1=one;2=two;3=three"
k v
---------
1 "one"
2 "two"
3 "three"</code></pre>
<h2 id="116-interprocess-communication">11.6 Interprocess Communication</h2>
<p>The ease with which a q process can communicate with another q process residing on the network is one of the most impressive features of q. We shall cover all the basics of interprocess communication (IPC) so that you can follow the section on callbacks in <a href="https://code.kx.com/q4m3/1_Q_Shock_and_Awe/">Chapter 1 ‚Äì <em>Q Shock and Awe</em></a>.</p>
<p>We shall use the following terminology. The process that initiates the communication is called the <em>client</em>, while the process receiving and processing requests is the <em>server</em>. The server process can be on the same machine, the same network, a different network or on the Internet, so long as it is accessible. The communication can be <em>synchronous</em> (wait for a result to be returned) or <em>asynchronous</em> (don‚Äôt wait and no result returned).</p>
<p>The only way to learn IPC is to do it, and the easiest way to do this is to set up two processes on the same machine. We recommend you use the machine running your q sessions for this tutorial, provided it will allow a port to be opened. In what follows, we shall assume that a server q process has been started on a machine with an open port.</p>
<pre class="highlight"><code class="language-bash">&gt;q -p 5042
q)</code></pre>
<p>The client process is a separate q process running on the same machine.</p>
<pre class="highlight"><code class="language-bash">&gt;q
q)</code></pre>
<h3 id="1161-communication-handle">11.6.1 Communication Handle</h3>
<p>Symbolic communication handles look similar to file handles but they specify resources on the network. A communication handle has the form,</p>
<p><code>`:</code>[<em>server</em>]<code>:</code><em>port</em></p>
<p>Here the bracketed expression represents an optional server machine identifier and <em>port</em> is a port number. An omitted server specification, or one of the form <code>localhost</code>, refers to the machine on which the originating q session lives. The following both refer to port 5042 on the same machine as the q session in which they are entered.</p>
<pre class="highlight"><code class="language-q">q)`::5042
_
q)`:localhost:5042
_</code></pre>
<p>You can refer to a machine on the network by name. For example, on the author‚Äôs laptop the following is equivalent to the two previous network handles.</p>
<pre class="highlight"><code class="language-q">q)`:aerowing:5042
_</code></pre>
<p>You can use the IP address of a machine.</p>
<pre class="highlight"><code class="language-q">q)`:198.162.0.2:5042
_</code></pre>
<p>Finally, you can also use a URL.</p>
<pre class="highlight"><code class="language-q">q)`:www.myurl.com:5042
_</code></pre>
<h3 id="1162-opening-a-connection-handle">11.6.2 Opening a Connection Handle</h3>
<p>As with a file handle, apply <code>hopen</code> to a communication handle to obtain an open <em>connection handle</em> that is used as a function. As before, the value is an int that is traditionally stored in the variable <code>h</code>. Also as with file I/O, the behavior of this function differs between using the original positive handle or its negation.</p>
<p>Let‚Äôs see how this works with our two sessions. (You did start them, didn‚Äôt you?). Remember, the session that opened port 5042 is the server; the other session is the client. In the <strong>client</strong> session, open a handle to the server and store it in <code>h</code>, then apply <code>h</code> to the string as shown. Finally close the connection handle.
</p><pre class="highlight"><code class="language-q">q)h:hopen `::5042
q)h "a:6*7"
q)h "a"
42
q)hclose h</code></pre>
<div class="admonition tip">
<p class="admonition-title">Whitespace between <code>h</code> and the quoted string is optional, as this is simply prefix syntax. We include it for readability.</p>
</div>
<p>As you have no doubt realized, the application of <code>h</code> sent the string to the server to be evaluated. On the server, we see,
</p><pre class="highlight"><code class="language-q">q)a
42</code></pre>
How cool is that?
<h3 id="1163-remote-execution">11.6.3 Remote Execution</h3>
<p>We have seen that when you open a connection to a q process, you have the full capability of that process available remotely. Apply the connection handle to any q expression in a string and it will be evaluated on the server. As you contemplate the IPC Zen, a dark cloud passes over your tranquility. You realize that, by default, the server is wide open.</p>
<div class="admonition important">
<p class="admonition-title">Allowing quoted q strings to be executed on a server makes the server susceptible to all manner of breaches.</p>
<p>Good practice does not permit this on a production server. You can mitigate this by having your server process accept only requests whose first item is a symbol (see below), which you should verify is the name of a function you have decided to expose.</p>
</div>
<p>An alternative format for remote execution is to apply the connection handler to a list of the form</p>
<p><code>(</code><em>f</em><code>;</code><em>arg<sub>1</sub></em><code>;</code><em>arg<sub>2</sub></em><code>;...)</code></p>
<p>Here <em>f</em> is a client-side expression that evaluates to a map that will be applied on the server. It can be:</p>
<ul>
<li>The value of, or variable associated to, a map on the <strong>client</strong></li>
<li>The symbolic name of a map on the <strong>server</strong>.</li>
</ul>
<p>We use the term <em>map</em> here to be any q expression that can be evaluated as function application ‚Äì e.g., a list on an index, a dictionary on a key or a function on an argument. Most commonly <em>f</em> is a function</p>
<p>The remaining items <em>arg<sub>1</sub></em>, <em>arg<sub>2</sub></em>, ‚Ä¶ are optional values sent along to the server for the evaluation. These are arguments when <code>f</code> is a function, indices when it is a list, or keys when it is a dictionary.</p>
<p>Application of the connection handle to such a list sends the list to the server where it is evaluated. Any result is sent back to the client, where it is presented as the result of the connection handle application. By simply applying the naked handle, this sequence of steps is <strong>synchronous</strong>, meaning that execution of the q session on the client blocks until the result of the server evaluation is returned.</p>
<p>Our examples will cover the case when <code>f</code> is of function type since that is most common. We first consider the first case when <code>f</code> is a map on the client side. In this situation the function (list, dictionary, etc.) is actually transported to the server along with the supplied arguments, where it is applied.</p>
<p>On the client in our two-session setup:</p>
<pre class="highlight"><code class="language-q">q)h:hopen`::5042 / client
q)h ({x*y}; 6; 7)
42
q)f:{x*y}
q)h (f; 6; 7)
42</code></pre>
<p>Before you get too enamored of this form, we point out the limitations that disqualify it from production use. First, global variables referred to in the transported function will need to be present remotely in the exact contexts in effect when the function was defined. This can be avoided by restricting <code>f</code> to be a pure function that does not refer to any global entities. More damning is:</p>
<div class="admonition warning">
<p class="admonition-title">Allowing a function to be sent to the server for remote execution is as dangerous as sending quoted q strings</p>
<p>The function can access resources on the server and instigate an attack. Good practice does not permit this in production environments.</p>
</div>
<p>The remaining format for remote execution can be made safe for production environments. The function to be executed remotely must already be defined on the server and you pass its name and arguments via the connection handle.</p>
<p>On the server,</p>
<pre class="highlight"><code class="language-q">q)g:{x*y} / server</code></pre>
<p>On the client,</p>
<pre class="highlight"><code class="language-q">q)h (`g; 6; 7) / client
42</code></pre>
<p>Now consider the case when the remote function performs an operation on a table and returns the result. This is the q analogue of a remote stored procedure. For example, suppose <code>t</code> and <code>f</code> are defined on the server as,</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:`a`b`c; c2:1 2 3) / server
q)f:{[x] select c2 from t where c1=x}</code></pre>
<p>Now ‚Äúcall‚Äù the function <code>f</code> remotely from the client.</p>
<pre class="highlight"><code class="language-q">q)h (`f; `b) / client
c2
--
2</code></pre>
<p>The difference from SQL stored procedures is that the remote procedure can be <strong>any</strong> q function on the server, making the full power of q available remotely.</p>
<h3 id="1164-synchronous-and-asynchronous-messages">11.6.4 Synchronous and Asynchronous Messages</h3>
<p>The IPC in the previous sections was <strong>synchronous</strong>, meaning that upon application of the connection handle, the client process blocks, waiting for a result from the server before proceeding. The value returned from the server becomes the return value of the open handle application.</p>
<p>Under the covers, IPC is implemented as messages passed over an open connection between q processes. When the <strong>positive</strong> open handle is applied to an argument, the message passing is <strong>synchronous</strong>, meaning that the following steps occur in sequence.</p>
<ul>
<li>The client sends a message containing the argument(s) of the handle application to the server and waits for a return message.</li>
<li>The server receives the message, interprets it as the appropriate function application and obtains the result.</li>
<li>The server sends a message containing the result back to the client.</li>
<li>The client receives the result and resumes execution from the point it left off.</li>
</ul>
<p>When a client sends multiple messages to a server in synchronous message passing, the next message is not sent until the result of the previous message is received. Consequently the messages always arrive at the server in the order in which they are sent. Also, the results from the server arrive back at the client in the order in which the original messages were sent.</p>
<p>It is also possible to perform asynchronous IPC in q. In this case the message is sent to the server and execution on the client continues immediately. In particular, there is no return value from the server. This is useful to initiate a task on the server when you don‚Äôt care about the result. For example, you could initiate a long running operation, or you could send a message that the server will route to other processes.</p>
<p>Use the negation of the open connection handle to send an <strong>asynchronous</strong> message to the server. Let‚Äôs define an instrumented function on the server to demonstrate what is happening.</p>
<pre class="highlight"><code class="language-q">q)sq:{0N!x*x} / server</code></pre>
<p>Now invoke <code>sq</code> asynchronously from the client</p>
<pre class="highlight"><code class="language-q">q)neg[h] (`sq; 5) / client
q)</code></pre>
<p>You will observe 25 displayed on the server console. Also, the client session returns immediately with no return value. The expression on the console actually has a nil value <code>::</code> that is suppressed by the console display.</p>
<details class="warning">
<summary>When sending asynchronous messages, always send an empty ‚Äúchaser‚Äù message immediately before applying <code>hclose</code> to the open handle</summary>
<p>If you do not do this, buffered messages may not be sent when the connection is closed.</p>
</details>
<p>In order to convince ourselves that the client actually does return immediately without waiting for a return from the server, we wrap the client expression in a function. Observe that the client continues with the next statement.</p>
<pre class="highlight"><code class="language-q">q){neg[h] (`sq.; 5); 42}[] / client
42</code></pre>
<p>Because a q session is single threaded by default, the server will process messages in the order in which they are received. However, in asynchronous messaging there is no guarantee that the messages arrive at the server in the order in which they are sent. It can be difficult to observe indeterminancy in simple examples, but you must assume that it will occur in practice.</p>
<h3 id="1165-processing-messages">11.6.5 Processing Messages</h3>
<p>Assuming that you have passed the server either a function from the client side or the name of a function on the server side, the appropriate function is evaluated on the server. During evaluation, the communication handle of the remote process is available in the system variable <a href="https://code.kx.com/q/ref/dotz/#zw-handle"><code>.z.w</code></a> ( ‚Äúwho‚Äù called). For an asynchronous call, this can be used to send messages back to the server during the function application on the server.</p>
<div class="admonition tip">
<p class="admonition-title">Both the client and the server have connection handles when a connection between them is opened</p>
<p>However, these handles are assigned independently and their int values are not equal in general.</p>
</div>
<p>Here is a simple example showing how to use <code>.z.w</code> to send a message back to the client. On the server, we define a function that displays its received parameter and then asynchronously calls <code>mycallback</code> with the passed argument incremented.</p>
<pre class="highlight"><code class="language-q">q)f:{show "Received ",string x; neg[.z.w] (`mycallback; x+1)}</code></pre>
<p>On the client we define <code>mycallback</code> to display its parameter on the console. Then we make an asynchronous call to the function <code>f</code> on the server with an argument of 42.</p>
<pre class="highlight"><code class="language-q">q)mycallback:{show "Returned ",string x;}
q)neg[h] (`f; 42)
q)"Returned 43"</code></pre>
<p>The result is that <code>"Received 42"</code> is displayed on the server console and <code>"Returned 43"</code> is displayed on the client console. Congratulations! We have just invented callbacks in q.</p>
<div class="admonition tip">
<p class="admonition-title">When performing asynchronous messaging, always use <code>neg[.z.w]</code> to ensure that all messages are asynchronous</p>
<p>Otherwise you will get a deadlock as each process waits for the other.</p>
</div>
<p>You can override the default behavior of message processing in q by assigning your own handler(s) to the appropriate system variables. Assign your function to the variable <a href="https://code.kx.com/q/ref/dotz/#zpg-get"><code>.z.pg</code></a> to trap and process synchronous messages and to <a href="https://code.kx.com/q/ref/dotz/#zps-set"><code>.z.ps</code></a> for asynchronous messages. The names end in ‚Äòg‚Äô and ‚Äòs‚Äô because synchronous processing has "get" semantics and asynchronous processing has "set" semantics.</p>
<p>In the following we set the asynchronous handler to a trivial function, essentially ignoring asynchronous calls.</p>
<p>On the server,</p>
<pre class="highlight"><code class="language-q">q).z.ps:{show "ignore"} / server</code></pre>
<p>On the client send an <strong>asynchronous</strong> message.</p>
<pre class="highlight"><code class="language-q">q)neg[h] "6*7" / client</code></pre>
<p>This results in <code>"ignore"</code> being displayed on the server console.</p>
<p>Now we set the synchronous handler to a function that only accepts ‚Äúsafe‚Äù remote calls by function name. It then performs a protected evaluation on the function with the arguments passed, thus ensuring that a failed application does not hang the server.</p>
<p>On the server,</p>
<pre class="highlight"><code class="language-q">q).z.pg:{$[-11h=type first x; .[value first x; 1_x; ::]; `unsupported]}</code></pre>
<p>Now send <strong>synchronous</strong> messages from the client.</p>
<pre class="highlight"><code class="language-q">q)h (`sq; 5) / client
25
q)h (`sq; `5)
"type"
q)h "6*7"
`unsupported
q)h ({x*y};6;7)
`unsupported</code></pre>
<p>You can also specify handlers to be called upon connection open and close by assigning functions to the system variables <a href="https://code.kx.com/q/ref/dotz/#zpo-open"><code>.z.po</code></a> and <a href="https://code.kx.com/q/ref/dotz/#zpc-close"><code>.z.pc</code></a>, respectively. The connection handle of the sending process is passed as the lone argument to the functions assigned to <code>.z.po</code> and to <code>.z.pc</code>.</p>
<p>Here is a simple example that tracks connections and allows client processes to register callbacks with the server. Start a fresh q session on the server and open port 5042. Create a keyed table called <code>Registry</code> and define a function that can be invoked remotely to register a callback. Attach a handler to <code>.z.po</code> that initializes a dummy entry in <code>Registry</code> for the connection being opened and attach a handler to <code>.z.pc</code> to remove the record when a connection is closed.</p>
<pre class="highlight"><code class="language-q">q)Registry:([zw:`int$()] callback:`symbol$())
q)register:{[cb] `Registry upsert (.z.w; cb);}
q).z.po:{`Registry upsert (x; `unregistered);}
q).z.pc:{delete from `Registry where zw=x;}</code></pre>
<p>Start a fresh q session on the client and connect to the server.</p>
<pre class="highlight"><code class="language-q">q)h:hopen`::5042 / client</code></pre>
<p>We check that an item has been entered into <code>Registry</code> on the server.</p>
<pre class="highlight"><code class="language-q">q)Registry / server
zw| callback
--| ------------
6 | unregistered</code></pre>
<p>Next we register the name of a callback function from the client. Note the asynchronous message.</p>
<pre class="highlight"><code class="language-q">q)neg[h] (`register; `mycallback) / client</code></pre>
<p>Again we check <code>Registry</code> on the server and observe that our callback name has indeed been registered.</p>
<pre class="highlight"><code class="language-q">q)Registry / server
zw| callback
--| ----------
6 | mycallback</code></pre>
<p>Finally, we close the connection on the client.</p>
<pre class="highlight"><code class="language-q">q)hclose h / client</code></pre>
<p>And observe that the client has been automatically unregistered.</p>
<pre class="highlight"><code class="language-q">q).z.pg:{show x 0; show x 1; ; string value 1_x 0}
zw| callback
--| --------</code></pre>
<h3 id="1166-remote-queries">11.6.6 Remote Queries</h3>
<p>In this section, we demonstrate how to execute q-sql queries against a remote server. First, we splay a table to stand for a time-series database. We use the <code>mktrades</code> script that we created in <a href="https://code.kx.com/q4m3/9_Queries_q-sql/#931-syntax">¬ß9.3.1</a> to create a trades table with 1,000,000 rows and then splay it to disk.</p>
<pre class="highlight"><code class="language-q">q)trade:mktrades[`aapl`goog`ibm; 1000000]
q)(`:/db/trade/) set .Q.en[`:/db;]
_</code></pre>
<p>Now start a fresh server process (the server), open a port, say 5042, and map the splayed trade table into memory. Check that the mapping succeeded by running a query.</p>
<pre class="highlight"><code class="language-q">q)\p 5042 / server
q)\l /db
q)select from trade where dt=2015.01.01,sym=`ibm
dt         tm           sym qty  px
---------------------------------------
2015.01.01 00:00:01.796 ibm 7080 218.74
2015.01.01 00:00:10.581 ibm 3250 206.88
..</code></pre>
<p>Leave the server process running and start another fresh process (the client), open a connection to the server and send the same query to the server for remote execution.</p>
<pre class="highlight"><code class="language-q">q)h:hopen`::5042 / client
q)h "select from trade where dt=2015.01.01,sym=`ibm"
dt         tm           sym qty  px
---------------------------------------
2015.01.01 00:00:01.796 ibm 7080 218.74
2015.01.01 00:00:10.581 ibm 3250 206.88
..</code></pre>
<p>We have already pointed out that allowing remote execution of arbitrary strings is bad practice because it exposes the server to injection attack. So here is a simplistic example of a ‚Äúsafe‚Äù function that can be used as a stored procedure. It takes a symbolic table name, a list of symbolic column names for the result and a date range for the where phrase. Enter on the server:</p>
<pre class="highlight"><code class="language-q">q)extract:{[tn;cnms;dtrng] ?[tn;enlist (within;`dt; dtrng);0b;cnms!cnms]}</code></pre>
<p>Now on the client we (synchronously) call the stored procedure by name with appropriate arguments.</p>
<pre class="highlight"><code class="language-q">q)h (`extract;`trade;`dt`tm`sym`qty`px;2015.01.01 2015.01.02)
dt         tm           sym   qty  px
----------------------------------------
2015.01.01 00:00:01.194 aapl  6770 94.62
2015.01.01 00:00:01.796 ibm   7080 218.74
..</code></pre>
<div class="admonition tip">
<p class="admonition-title">In an actual application you would validate the input parameters and wrap the core evaluation in protected evaluation to trap unanticipated errors. You would also want to implement an entitlements system based on LDAP.</p>
</div>
<h2 id="117-http-and-web-sockets">11.7 HTTP and Web sockets</h2>
<h3 id="1171-http-connections">11.7.1 HTTP Connections</h3>
<p>When you open a port in a q session, by default that session serves HTTP requests. To demonstrate this, start a q session and open a port, say 5042. Then bring up a relatively recent browser on the same machine (the author uses Chrome) and enter the following URL</p>
<pre class="highlight"><code class="language-txt">http://localhost:5042/?6%2A7</code></pre>
<p>You should see 42 in the browser page display.</p>
<p>You can trap HTTP GET and POST traffic by assigning functions to the system variables <a href="https://code.kx.com/q/ref/dotz/#zph-http-get"><code>.z.ph</code></a> and <a href="https://code.kx.com/q/ref/dotz/#zpp-http-post"><code>.z.pp</code></a> respectively. The default handler for <code>.z.ph</code> is to evaluate the content of the first item of the passed argument.</p>
<div class="admonition tip">
<p class="admonition-title">There is no default handler for <code>.z.pp</code>.</p>
</div>
<p>Here is a simple example that duplicates the default GET processing and shows the two items of its list argument. Define the following handler on the server process opened previously. It displays the two items of the input list then executes the first after removing the leading <code>?</code> and then returns the result as a string.</p>
<pre class="highlight"><code class="language-q">q).z.ph:{show x 0; show x 1; ; string value 1_x 0} / server</code></pre>
<p>Now enter the following from a browser on the same machine.
</p><pre class="highlight"><code class="language-txt">http://localhost:5042/?6*7</code></pre>
The server will display,
<pre class="highlight"><code class="language-q">q)"?6*7"
Host            | "localhost:5042"
Connection      | "keep-alive"
Cache-Control   | "max-age=0"
Accept          | "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,\*/\*;q=0.8"
User-Agent      | "Mozilla/5.0 (Macintosh; Intel Mac OS X 10\_9\_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.89 Safari/537.36"
Accept-Encoding | "gzip, deflate, sdch"
Accept-Language | "en-US,en;q=0.8"</code></pre>
<p>And the browser page displays ‚Äú42‚Äù.</p>
<h3 id="1172-basic-websockets">11.7.2 Basic WebSockets</h3>
<p>WebSockets is a network protocol that upgrades an initial HTTP handshake into a TCP/IP socket connection. It was initially used to enhance communication capability between browsers and web servers but it can be used for general client-server applications. Once the WebSocket connection is established, either the client or server can message the other; in particular, this provides the capability for the server to push data to the client.</p>
<div class="admonition important">
<p class="admonition-title">As of this writing (Sep 2015) q implements only asynchronous messaging in WebSockets.</p>
</div>
<p>In this section we show the basic mechanism for establishing a WebSocket connection between a browser and a q process acting as the server. We use Chrome for the examples but recent versions of Internet Explorer are now WebSockets-capable and should work similarly.</p>
<div class="admonition note">
<p class="admonition-title">In the examples of this section we assume basic familiarity with HTML5 and JavaScript.</p>
</div>
<p>We begin with an extremely simple HTML page with a button that, when clicked, displays the answer to life, the universe and everything. Save the following as a text file <code>sample0.html</code> in a location accessible to your browser.</p>
<pre class="highlight"><code class="language-html">&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script&gt;
  function sayN(n) {
    document.getElementById('answer').textContent = n;
  }
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1 style='font-size:200px' id='answer'&gt;&lt;/h1&gt;
  &lt;button onclick='sayN(42)'&gt;get the answer&lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>In our case we saved the file to <code>/pages/sample0.html</code> on the local drive, so we enter the following URL in the browser:</p>
<pre class="highlight"><code class="language-txt">file:///pages/sample0.html</code></pre>
You should see a page with a single button labeled ‚Äúget the answer‚Äù. Click the button and you will see the answer in a very large font.
<p>Now we enhance this basic page to connect to a q process via WebSockets and retrieve the answer from q. Save the following script as <code>sample1.html</code>. We explain it below.</p>
<div class="admonition note">
<p class="admonition-title">For simplicity in the example, we have placed a copy of <code>c.js</code> in the pages directory. You should modify this to reflect its location in your installation.</p>
</div>
<pre class="highlight"><code class="language-html">&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script src="c.js"&gt;&lt;/script&gt;
&lt;script&gt;
var serverurl = "//localhost:5042/",
  c = connect(),
  ws;
function connect() {
    if ("WebSocket" in window) {
        ws = new WebSocket("ws:" + serverurl);
        ws.binaryType="arraybuffer";
        ws.onopen=function(e){
            ws.send(serialize({ payload: "What is the meaning of life?" }));
        };
        ws.onclose=function(e){
        };
        ws.onmessage=function(e){
            sayN(deserialize(e.data));
        };
        ws.onerror=function(e) {window.alert("WS Error") };
    } else alert("WebSockets not supported on your browser.");
}
function sayN(n) {
    document.getElementById('answer').textContent = n;
}
&lt;/script&gt;</code></pre>
<p>This script first declares the script <code>c.js</code>, which is required for using q WebSockets.</p>
<p>The script then defines JavaScript variables</p>
<ul>
<li><code>serverurl</code> to hold the URL of our q service</li>
<li><code>c</code> to hold the connection object returned by the <code>connect</code> function</li>
<li><code>ws</code> to hold a WebSocket object.</li>
</ul>
<p>The function <code>connect()</code> is where the WebSocket action happens.</p>
<ul>
<li>It first tests to see if <code>WebSocket</code> is in the window, meaning that the browser supports WebSockets. If so, it makes the connection to the server; otherwise it displays an error alert.</li>
<li>The first step in the connection is to create a WebSocket object by connecting to the specified server URL, and storing the result in <code>ws</code>.</li>
<li>Then set the <code>binaryType</code> field in <code>ws</code> to the value needed by the q sockets code.</li>
</ul>
<p>Now we assign handlers for the main WebSockets events.</p>
<ul>
<li>The open handler serializes (into q form) a JavaScript object with a <code>payload</code> field and then sends it to the server. Consequently when a connection is opened, we immediately ask the server the meaning of life.</li>
<li>The close handler is empty.</li>
<li>The message handler deserializes the data field of the parameter <code>e</code> and applies the <code>sayN</code> function to display the result on the page.</li>
<li>The error handler displays an alert page with the error message.</li>
</ul>
<p>The <code>sayN</code> function locates the <code>answer</code> field on the page and places the text of its argument there. Finally, the script defines a simple HTML element answer.</p>
<p>In contrast, the server side q code is blissfully short. Start a fresh q session, open port 5042 and set the WebSockets handler <code>.z.ws</code> to a function that will be invoked to handle WebSockets messages.</p>
<pre class="highlight"><code class="language-q">q)\p 5042
q).z.ws:{0N!-9!x; neg[.z.w] -8!42}</code></pre>
<p>The handler first deserializes its parameter and displays it to the console for debugging, at which point we have no further use for it in this example. Then it serializes the answer to the question asked by the browser and <strong>asynchronously</strong> sends it back to the browser. That‚Äôs all there is to it!</p>
<p>Now point the browser to</p>
<pre class="highlight"><code class="language-txt">file:///pages/sample1.html</code></pre>
<p>and you will see the answer displayed on the page. At this point you are equipped to follow <a href="https://code.kx.com/q4m3/1_Q_Shock_and_Awe/#119-interprocess-communication-101">¬ß1.19</a> in <em>Q Shock and Awe</em>.</p>
<h3 id="1173-pushing-data-to-the-browser">11.7.3 Pushing Data to the Browser</h3>
<p>In ordinary Web applications, the browser initiates interaction with the server. It sends a request to a specific URL on the server and the server replies with the requested page or data. Each such interaction is self-contained and is synchronous in that the browser waits for the server response.</p>
<p>In WebSockets the browser initiates the connection, but once the WebSocket request for protocol upgrade is successful, the browser ‚Äì i.e., client ‚Äì and the server are on equal footing. Either side can send messages. Moreover, in the current q implementation of WebSockets all interaction is asynchronous. Given that most current browsers and the default q session are both single-threaded, you don‚Äôt have to worry about races and deadlocks but you do have to set up callbacks.</p>
<p>In this section we demonstrate how the q server can push data to the browser, beginning with the browser script. Actually this script is a simplification of <code>sample1.html</code> in that we remove the initial call to the server upon open; everything else remains the same. The key point is that the <code>onmessage</code> handler will be called every time data is received, resulting in the data being displayed on the screen. Save the following as <code>sample2.html</code>.</p>
<pre class="highlight"><code class="language-html">&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script src="c.js"&gt;&lt;/script&gt;
&lt;script&gt;
var serverurl = "//localhost:4242/",
    c = connect(),
    ws;
function connect() {
    if ("WebSocket" in window) {
        ws = new WebSocket("ws:" + serverurl);
        ws.binaryType="arraybuffer";
        ws.onopen=function(e){
        };
        ws.onclose=function(e){
        };
        ws.onmessage=function(e){
            sayN(deserialize(e.data));
        };
        ws.onerror=function(e) {window.alert("WS Error") };
    } else alert("WebSockets not supported on your browser.");
}
function toQ(x) { ws.send(serialize({ payload: x })); }
function sayN(n) {
    document.getElementById('answer').textContent = n;
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1 style='font-size:200px' id='answer'&gt;&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>And now for the q side. You can enter the following in the console of a fresh q session; or you can save it as a script and load it with <code>\l</code>.</p>
<pre class="highlight"><code class="language-q">q)\p 4242
q)answer:42
q).z.po:{`requestor set x; system "t 1000";}
q).z.ts:{neg[requestor] -8!answer;; answer+:1;}</code></pre>
<p>Here is what‚Äôs happening in the q code.</p>
<ul>
<li>First we open the port and initialize the <code>answer</code> variable.</li>
<li>Then we set the connection open handler to store the client <code>.z.w</code> value of its parameter into the global requestor and start the system timer firing every 1000 milliseconds. Note that this only happens <strong>after</strong> the browser initiates a connection.</li>
<li>Finally, we set the timer handler to send an asynchronous message containing the serialized value of answer and then increment answer.</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Change since q3.2</p>
<p>‚ÄúThe <code>.z.wo</code> and <code>.z.wc</code> message handlers were introduced in kdb+ version 3.3 (2014.11.26) to be evaluated whenever a WebSocket connection is opened (<code>.z.wo</code>) or closed (<code>.z.wc</code>). Prior to this version, <code>.z.pc</code> and <code>.z.po</code> provide an alternative solution however, these handle the opening and closing of all connections over a port and don‚Äôt distinguish WebSocket connections.‚Äù 
‚Äî Whitepaper <a href="https://code.kx.com/q/wp/websockets/#zwo-and-zwc-message-handlers">Kdb+ and WebSockets</a></p>
<p>See Reference: <a href="https://code.kx.com/q/wp/websockets/#zwo-and-zwc-message-handlers">System and callbacks</a></p>
</div>
<p>Now point the browser to</p>
<pre class="highlight"><code class="language-txt">file:///pages/sample2.html</code></pre>
<p>and you will see the answer ticking every second on the page.</p>
                


                
              
              
                


              
            </article>
            
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))for(var set of document.querySelectorAll("[data-tabs]")){var labels=set.querySelectorAll(":scope > label");e:for(var tab of tabs)for(var label of labels)if(label.innerText.trim()===tab){var input=label.previousElementSibling;input.checked=!0;break e}}</script>

          </div>
        </div>
        
          
        
      
                </div>
            </section>
        
            <section class="chapter" id="chapter-4">
                <div class="chapter-header">
                    <h1 class="chapter-title">12. Workspace Organization¬∂</h1>
                    <div class="chapter-meta">
                        <span>üìñ Source: <a href="https://code.kx.com/q4m3/12_Workspace_Organization/">https://code.kx.com/q4m3/12_Workspace_Organization/</a></span>
                        <span>üìù 2588 words</span>
                        
                    </div>
                </div>
                <div class="chapter-content">
                    
        <div class="md-main__inner md-grid">
          
            
              
              
            
            
              
              
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                
                <h1 id="12-workspace-organization">12. Workspace Organization</h1>
<h2 id="120-overview">12.0 Overview</h2>
<p>The collection of all q entities that have been created in a q session comprises the workspace. This includes not only explicitly created variables but also ancillary items such as enumerations, open handlers, tables mapped from storage and other internal structures.</p>
<p>Like any programming environment of reasonable complexity, q has the potential for name clashes ‚Äì e.g., when two different scripts define variables of the same name. Because q does not have lexical scoping and local variables are strictly scoped to the function in which they are defined, name clashes between locals is not a problem. But global variables are exposed. To illustrate, suppose you load a script that creates a global <code>foobar</code>. Then you load another script that also creates <code>foobar</code>. The result is that the second script overwrites the value assigned in the first script.</p>
<p>This is the simplest example of a condition in which two portions of a program contend for the same resource. Things get more complicated when concurrency is introduced, in which case the contention can lead to what is called a <em>race condition</em>. There is a school of programming that says mutable shared state is the root of all evil in distributed programming. Fortunately q is single-threaded by default and the implementation of threads (wisely) does not support mutating global variables. Nonetheless, simple name clashes are still a real problem.</p>
<h2 id="121-namespaces">12.1 Namespaces</h2>
<p>A partial solution to name clashes is <em>namespaces</em>, which is the idea of placing a (usually hierarchical) structure on names. This is customarily done by specifying a separator character, which is distinct from other valid name characters. You are familiar with this construct from the file system used by most operating systems. The Unix file system uses the separator <code>/</code> and the Windows file system uses <code>\</code>.</p>
<p>The idea is that a compound name with embedded separators represents a nested series of containers. For example, in the Unix file system, the path <code>/mydir/myfile</code> represents a directory (container) <code>mydir</code> that holds a file <code>myfile</code>. Or <code>/d1/d2/fn</code> represents a directory <code>d1</code> that contains a directory <code>d2</code> that contains the file <code>fn</code>. The root container, designated <code>/</code> in Unix, holds all other entities.</p>
<p>Namespaces in many programming languages work similarly, using <code>.</code> as the separator. In q the containers are called <em>contexts</em>. For example, <code>.jab.x</code> represents a variable <code>x</code> contained in the <code>jab</code> context. The context <code>jab</code> has the symbolic name <code>`.jab</code> and the fully qualified name of its variable is <code>`.jab.x</code>.</p>
<p>A notable difference between q namespacing and most others is the way the root is handled. Naming for entities in the root context does not work as you might expect based on the file system analogy. The syntactic form <code>.name</code> does <strong>not</strong> refer to the global variable <code>name</code> in the root context; rather, it refers to the context <code>name</code> in the root. The fully qualified name for an entity <code>x</code> in the root is simply <code>x</code>.</p>
<p>This has the following consequence that causes grief to qbies.</p>
<div class="admonition important">
<p class="admonition-title">Namespaces Fact of Life #1</p>
<p>There is no syntactic way inside a function to distinguish between a local variable <code>x</code> and the global <code>x</code> in the root namespace.</p>
</div>
<p>If you follow the Namespacing conventions at the end of this chapter, you can minimize potential discomfort. However, based on real-world experience, we point out the following.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Inside a function you can not access the global variable <code>foo</code> in the root context as <code>.foo</code>. Instead, <code>.foo</code> refers to the dictionary that holds all entities of the <code>foo</code> context. If you assign a value to <code>.foo</code> you wipe out the entire <code>foo</code> context.</p>
</div>
<h2 id="122-contexts">12.2 Contexts</h2>
<p>Namespacing in q is implemented with dictionaries. A context is a dictionary whose keys are the symbolic names of the variables in the corresponding namespace. The context dictionary associates each variable name with its currently assigned value.</p>
<p>The name of a context has the same restrictions as q variable names except that <code>.</code> is allowable. The following are all valid names of contexts in the root.
</p><pre class="highlight"><code class="language-q">.a
.q
.cat
.an_ugly_context_name</code></pre>
<p>Thus <code>.cat.bubba</code> represents the entity <code>bubba</code> in the <code>.cat</code> context.</p>
<p>With that out of the way, we can nest contexts.</p>
<pre class="highlight"><code class="language-q">.cat.bengal.nuba
.cat.abyssinian.orion</code></pre>
<p>Here we have the entity <code>nuba</code> in the <code>bengal</code> context in the <code>cat</code> context; or the <code>orion</code> entity in the <code>abyssinian</code> context in the <code>cat</code> context.</p>
<p>Astute readers already have a question. How do we distinguish between the first case, in which <code>.cat.bubba</code> is the variable <code>bubba</code> in the <code>cat</code> context, and the second case where <code>.cat.bengal</code> is a context? For example, can we emulate the file system, which appends the separator <code>/</code> to indicate a directory (container). The answer is:</p>
<div class="admonition important">
<p class="admonition-title">Namespacing Fact of Life #2</p>
<p>The interpretation of a fully qualified name depends on its underlying value. If it is a properly constructed dictionary, it is a context. If it is anything else, it is a variable.</p>
</div>
<p>KX reserves all root namespaces of a single letter, as well <code>.kx</code>, for its own use. It is worth noting that most q built-in functions that are not written in C live in the <code>.q</code> namespace. As of this writing (Sep 2015) the namespaces that are actively used by KX include <code>.h</code>, <code>.j</code>, <code>.o</code>, <code>.q</code>, <code>.u</code>, <code>.z</code> and <code>.Q</code>.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Although q prohibits you from re-assigning its own functions during program execution, some programmers think it is clever to override their definitions in the <code>q.k</code> file. This is bad practice bordering on malfeasance. It courts disaster should KX change the internal implementation of those routines in a future release.</p>
</div>
<h2 id="123-creating-contexts">12.3 Creating Contexts</h2>
<p>When you start a fresh q session, all global variables you create live in the root context. All previous examples in this tutorial have created global variable variables in the root simply because we did not indicate otherwise ‚Äì i.e., we used only unqualified variable names.</p>
<p>Start a fresh q session and create some global variables, beginning in the root.</p>
<pre class="highlight"><code class="language-q">q)answer:42
q)calculate:{(x*x)+(-1*x)+1}</code></pre>
<p>To use namespacing, there is no equivalent to <code>mkdir</code> that creates a context before it can be used. Simply specify a qualified name and the context will be created if it does not exist.</p>
<pre class="highlight"><code class="language-q">q).foo.a:42 / context foo created
q).foo.double:{2*x} / existing context foo used</code></pre>
<p>Now suppose a separate script uses the <code>bar</code> namespace with different definitions for <code>a</code> and <code>double</code>.</p>
<pre class="highlight"><code class="language-q">q).bar.a:43 / context bar created
q).bar.double:{2*x} / existing context bar used</code></pre>
<p>We can now load that script without clobbering our root variables, so we have solved the original problem posed in the introduction to this chapter.</p>
<div class="admonition warning">
<p class="admonition-title">Be very careful about placing globals in the root. As the author‚Äôs father would say, ‚ÄúYou‚Äôre cruisin‚Äô for a bruisin‚Äô‚Äù.</p>
</div>
<p>When working with contexts, apply an overload of the key operator to list the names of all contexts in the root.</p>
<pre class="highlight"><code class="language-q">q)key `
`q`Q`h`j`o`foo`bar</code></pre>
<p>There is no need to stop at one level of namespace. You can nest as deeply as you like and all the intermediate contexts will be created as needed. Suppose we work for a company Adiabatic Programming Laboratory. We might structure our library of computation routines something like the following.</p>
<pre class="highlight"><code class="language-q">q).apl.core.calc.array.fill0:{0.0^x}</code></pre>
<p>This single assignment causes the nested series of contexts <code>apl</code>, <code>core</code>, <code>calc</code> and <code>array</code> to be created and a function <code>fill0</code> to be placed in the innermost context <code>array</code>.</p>
<h2 id="124-context-as-dictionary">12.4 Context as Dictionary</h2>
<p>As mentioned previously, a context is a specially formatted q dictionary. Its keys are the symbolic names of the variables it contains; each is associated with the current value of the corresponding variable.</p>
<p>The context dictionaries are dictionaries that live in the workspace along with ordinary variables, which have special meaning to q. We can perform operations on them just as with our own dictionaries.</p>
<p>When we start a fresh q session, the root dictionary is empty. As with any variable, we can reveal the root context by applying <code>get</code> (or <code>value</code>) to its name and then applying the utility <a href="https://code.kx.com/q/ref/dotq/#qs1-string-representation"><code>.Q.s1</code></a> to display its internal form since it is empty.</p>
<pre class="highlight"><code class="language-q">q).Q.s1  get `.
"(`symbol$())!()"</code></pre>
<p>Here we see an empty key list of symbols and a general empty list of values. After defining variables in the root, an ordinary dictionary emerges.</p>
<pre class="highlight"><code class="language-q">q)get `.
a     | 42
double| {2*x}</code></pre>
<div class="admonition tip">
<p class="admonition-title">The entries in a context dictionary are sorted by name.</p>
</div>
<p>Things get more interesting when we use namespacing and create a context.</p>
<pre class="highlight"><code class="language-q">q).jab.wrong:43
q)get `.
a     | 42
double| {2*x}
q)get `.jab
      | ::
wrong | 43</code></pre>
<p>Observe that the newly created context dictionary for <code>.jab</code> is <strong>not</strong> physically in the root directory; it is a separate dictionary.</p>
<div class="admonition advanced">
<p class="admonition-title">Advanced</p>
<p>You might wonder about the significance of the <code>::</code> in the first entry of the <code>.jab</code> context dictionary. It is there to prevent the value list of the context dictionary from collapsing to a simple list in case all the variables should have values of the same scalar type. This would then prevent subsequent definition of variables of other types in that context.</p>
</div>
<p>As they say in certain quarters, q eats its own dog food, meaning all ordinary operations can be performed on a context dictionary. For example, we can look up the values associated with <code>`a</code> in the root and with <code>`wrong</code> in the <code>.jab</code> context.</p>
<pre class="highlight"><code class="language-q">q)`.[`a]
42
q)`.jab[`wrong]
43</code></pre>
<p>In fact you can use this to access an obscured global inside a function.</p>
<pre class="highlight"><code class="language-q">q)a
42
q){a:43; `.[`a]}[]
42</code></pre>
<p>While this sort of thing makes for cute parlor tricks, we do not advise using it in real code.</p>
<div class="admonition tip">
<p class="admonition-title">Use <code>get</code> and <code>set</code> to retrieve and store global variables by name, especially inside functions.</p>
</div>
<pre class="highlight"><code class="language-q"> q){`a set 1+ get `a}[]
 `a
 q)43
 43</code></pre>
<h2 id="125-expunging-from-a-context">12.5 Expunging from a Context</h2>
<p>We have seen that a context is a directory that maps a context‚Äôs entity names to their values. This means that in order to expunge an entity from a context, we could directly remove it from the dictionary. But this is bad practice since it uses the underlying implementation and the actual expression is prone to typing error.</p>
<p>Instead, q provides a special overload of the delete template explicitly for this purpose.</p>
<pre class="highlight"><code class="language-q">q)a:42
q).jab.wrong:43
q)delete a from `.
`.
q)a
'a
q)delete wrong from `.jab
`.jab
q)\v
`symbol$()
q)\v .jab
`symbol$()</code></pre>
<p>Indeed, we issue the <code>\v</code> command to display the names of variables in a context (current context if none is specified) to verify that the variables are gone.</p>
<h2 id="126-saving-and-loading-contexts">12.6 Saving and Loading Contexts</h2>
<p>Since a context is a dictionary, you can persist it ‚Äì and all its contents ‚Äì as a serialized q object using <code>set</code>.</p>
<p>For example, to write out the root context, retrieve it by name and set it into a file.</p>
<pre class="highlight"><code class="language-q">q)`:/data/root set get `.
`:/data/root</code></pre>
<p>Conversely, you can read the serialized object back into memory using <code>get</code> on the file and then overwrite the current root context using <code>set</code></p>
<pre class="highlight"><code class="language-q">q)`. set get `:/data/root</code></pre>
<div class="admonition tip">
<p class="admonition-title">If you organize your globals carefully, this makes check-pointing the state of your application very simple. Overlaying the root context replaces all its entries. As the saying goes, ‚ÄúBe careful what you ask for.‚Äù</p>
</div>
<h2 id="127-working-in-a-context">12.7 Working in a Context</h2>
<p>We return to the analogy of paths in the file system. The operating system keeps track of the current working directory for each program. This is merely a bit of state that points to a logical location in the file system. The main feature is it allows paths for items at or below the current working directory to be specified in <em>relative</em> form.</p>
<p>For example, if we start with the current working directory as the root and we wish to access a file <code>/db/2015.03.01/trades.dat</code>, then we must use the full path. However, if we issue the OS command,</p>
<pre class="highlight"><code class="language-bash">cd /db</code></pre>
<p>then <code>/db</code> becomes the current working directory and we can specify the path of the file as simply <code>2015.03.01/trades.dat</code>. Note the absence of the leading <code>/</code>, which signifies a relative path as opposed to an absolute one. This provides significant simplification for deeply nested directory structures, which often arises in large development environments.</p>
<p>A q session has a similar concept. At any point in the session there is a <em>current working context</em>. At the beginning of a fresh q session, the current working context is the root context and you use absolute names for all global variables. We can change the working context with the <code>\d</code> command (for ‚Äúdirectory‚Äù by analogy to the file system). After you change the current working context, you can use relative names for global variables. Here we create two globals in the root context and then switch the current working context to show relative names.</p>
<pre class="highlight"><code class="language-q">q).jab.util.counter:0
q).jab.util.incrctr:{[] `.jab.util.counter set 1+get `.jab.util.counter}
q).jab.util.incrctr[]
`.jab.util.counter
q)\d .jab
q.jab)util.incrctr[]
`.jab.util.counter
q.jab)util.counter
2</code></pre>
<p>Notice that the q prompt changes to let you know the current working context.</p>
<p>There is a subtle point about how globals are bound during function definition that we must point out. To illustrate, start a fresh q session and do the following.</p>
<pre class="highlight"><code class="language-q">q)state:`NY
q).jab.f1:{[] state}
q)\d .jab
q.jab)state:0N
q.jab)f2:{[] state}
q.jab)\d .
q).jab.f1[]
`NY
q).jab.f2[]
0N
q).jab.f1
{[] state}
q).jab.f2
{[] state}</code></pre>
<p>We began by defining a variable <code>state</code> in the root context to hold a two-character code for one of the fifty United States of America. Also from the root context, we define a function <code>f1</code> in the <code>.jab</code> context that returns the value of <code>state</code> from the root context. Next we switch to the <code>.jab</code> context and define a variable <code>state</code> that holds the integer value of a state machine, along with a function <code>f2</code> that returns the value of this global.</p>
<p>We return to the root context, apply each function using an absolute path name and observe the expected values. Namespacing has done its job by avoiding a clash between the disparate state variables, so what‚Äôs the issue? Look closely at the display of the two function bodies. They are identical! How does q know which <code>state</code> variable to access at runtime?</p>
<div class="admonition important">
<p class="admonition-title">Namespacing Fact of Life #3</p>
<p>Any unqualified global reference in a function is bound to the current working context in effect at the point of the function <strong>definition</strong>. That context is not explicitly displayed in the function body.</p>
</div>
<p>This has the undesirable consequence of requiring a potential user of the function to know the circumstances of its definition.</p>
<p>But wait, there‚Äôs more. Let‚Äôs redo the initial example of this section in a fresh q session, but change the current working context two levels down instead of one.</p>
<pre class="highlight"><code class="language-q">q).jab.util.counter:0
q).jab.util.incrctr:{[] `.jab.util.counter set 1+get `.jab.util.counter}
q)\d .jab.util
'.jab.util</code></pre>
<p>You can‚Äôt do it!</p>
<div class="admonition important">
<p class="admonition-title">Namespacing Fact of Life #4</p>
<p>You can only set the current working context one level down from the root. This is truly unfortunate.</p>
</div>
<p>You might be tempted to abandon namespacing altogether, but don‚Äôt. If you adhere to the following recommendations, you will avoid the issues mentioned above and namespacing will work effectively.</p>
<p><strong>Recommendations for Namespacing</strong>:</p>
<ul>
<li>Use namespacing at arbitrary depth to create hierarchical organization of global variables, both data and functions.</li>
<li>Keep related functions and any globals they require together in an appropriate context in the hierarchy with a descriptive name.</li>
<li>By convention, q namespaces are all lower case.</li>
<li>Define all global entities from the root context using fully qualified names.</li>
<li>Always refer to global entities using fully qualified names.</li>
</ul>
<p>Essentially the last two recommendations amount to avoiding all use of <a href="https://code.kx.com/q/basics/syscmds/#d-directory" title="Directory"><code>\d</code></a> to switch the current working context. Here is one way to define the functions <code>f1</code> and <code>f2</code> above in a fresh q session so that everything is explicit.</p>
<pre class="highlight"><code class="language-q">q).jab.geog.state:`NY
q).jab.geog.f1:{[] .jab.geog.state}
q).jab.machine.state:0N
q).jab.machine.f2:{[] .jab.machine.state}
q).jab.geog.f1
{[] .jab.geog.state}
q).jab.machine.f2
{[] .jab.machine.state}</code></pre>
                


                
              
              
                


              
            </article>
            
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))for(var set of document.querySelectorAll("[data-tabs]")){var labels=set.querySelectorAll(":scope > label");e:for(var tab of tabs)for(var label of labels)if(label.innerText.trim()===tab){var input=label.previousElementSibling;input.checked=!0;break e}}</script>

          </div>
        </div>
        
          
        
      
                </div>
            </section>
        
            <section class="chapter" id="chapter-5">
                <div class="chapter-header">
                    <h1 class="chapter-title">13. Commands and System Variables¬∂</h1>
                    <div class="chapter-meta">
                        <span>üìñ Source: <a href="https://code.kx.com/q4m3/13_Commands_and_System_Variables/">https://code.kx.com/q4m3/13_Commands_and_System_Variables/</a></span>
                        <span>üìù 6788 words</span>
                        
                    </div>
                </div>
                <div class="chapter-content">
                    
        <div class="md-main__inner md-grid">
          
            
              
              
            
            
              
              
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                
                <h1 id="13-commands-and-system-variables">13. Commands and System Variables</h1>
<p><span class="twemoji"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path d="M542.22 32.05c-54.8 3.11-163.72 14.43-230.96 55.59-4.64 2.84-7.27 7.89-7.27 13.17v363.87c0 11.55 12.63 18.85 23.28 13.49 69.18-34.82 169.23-44.32 218.7-46.92 16.89-.89 30.02-14.43 30.02-30.66V62.75c.01-17.71-15.35-31.74-33.77-30.7zM264.73 87.64C197.5 46.48 88.58 35.17 33.78 32.05 15.36 31.01 0 45.04 0 62.75V400.6c0 16.24 13.13 29.78 30.02 30.66 49.49 2.6 149.59 12.11 218.77 46.95 10.62 5.35 23.21-1.94 23.21-13.46V100.63c0-5.29-2.62-10.14-7.27-12.99z"></path></svg></span>
<a href="https://code.kx.com/q/basics/syscmds">System commands</a></p>
<h2 id="131-command-format">13.1 Command Format</h2>
<p>Commands control aspects of the q run-time environment. A command begins with a backslash <code>\</code> followed by the command name. Many commands have optional parameter(s) separated from the command name by a blank (multiple blanks or other whitespace characters are not permitted). Case is significant in the command name.</p>
<p>Notes on optional parameters:</p>
<ul>
<li>Commands whose optional parameter sets an environmental value will display the current value when the parameter is omitted</li>
<li>Commands whose parameter refers to a namespace apply to the current working context if the parameter is omitted.</li>
</ul>
<p>You could execute a command programmatically by placing it in a string as an argument to <code>value</code>. Observe that you must escape the <code>\</code> in the string.</p>
<pre class="highlight"><code class="language-q">q)value "**Error! Hyperlink reference not valid.**" / bad practice!</code></pre>
<div class="admonition warning">
<p class="admonition-title">Never do this in production ‚Äì it exposes your system to all manner of attacks!</p>
<p>Instead use the built-in <a href="https://code.kx.com/q/ref/system/"><code>system</code></a> that at least checks for a valid command. Note that it also eliminates the backslash and hence the need to escape it.</p>
</div>
<pre class="highlight"><code class="language-q">q)system "p 5042"</code></pre>
<h3 id="1311-list-tables-a">13.1.1 List Tables <code>\a</code></h3>
<p>The command <a href="https://code.kx.com/q/basics/syscmds/#a-tables"><code>\a</code> [<em>namespace</em>]</a>, where <em>namespace</em> is an optional namespace, returns a sorted list of symbolic names of all tables in a context. When used without a parameter, it returns the tables in the current working context. For example, in a fresh q session,</p>
<pre class="highlight"><code class="language-q">q)\a
`symbol$()
q)t:([] c1:`a`b`c; c2:10 20 30)
q)\a
,`t
q).jab.t:([] c1:`a`b`c; c2:10 20 30)
q)\a .jab
,`t</code></pre>
<h3 id="1312-viewsaliases-b">13.1.2 Views/Aliases <code>\b</code></h3>
<p>The command <a href="https://code.kx.com/q/basics/syscmds/#b-views"><code>\b</code> [<em>namespace</em>]</a> returns a sorted list of the symbolic names of the aliases (a.k.a. views, dependencies) in a context. In a fresh q session,</p>
<pre class="highlight"><code class="language-q">q)\b
`symbol$()
q)a:42
q)b::a+1
q)c::b*b
q)\b
`s#`b`c</code></pre>
<p>See <a href="#1333-dependencies-zb">¬ß13.3.3</a> for the related <a href="https://code.kx.com/q/ref/dotz/#zb-dependencies"><code>.z.b</code></a>.</p>
<h3 id="1313-pending-viewsaliases-b">13.1.3 Pending Views/Aliases <code>\B</code></h3>
<p>The command <a href="https://code.kx.com/q/basics/syscmds/#b-pending-views"><code>\B</code>[<em>namespace</em>]</a> (note upper case) returns a sorted list of the symbolic names of the aliases (a.k.a. views, dependencies) in a context that are stale ‚Äì i.e., there is a pending update that will be realized on the next reference. In a fresh q session,</p>
<pre class="highlight"><code class="language-q">q)x:42
q)a::x+1
q)\B
,`a
q)a
43
q)\B
`symbol$()</code></pre>
<p>See <a href="#1333-dependencies-zb">¬ß13.3.3</a> for the related <a href="https://code.kx.com/q/ref/dotz/#zb-dependencies"><code>.z.b</code></a>.</p>
<h3 id="1314-console-c">13.1.4 Console <code>\c</code></h3>
<p>The command <a href="https://code.kx.com/q/basics/syscmds/#c-console-size"><code>\c</code> [h w]</a> displays (no arguments) or sets (pair of height and width as integers) the size of the virtual q console display. The default is <code>25 80i</code>. In a fresh q session,</p>
<pre class="highlight"><code class="language-q">q)\c
25 80i
q)\c 10 20
q)2#enlist "abcdefghijkmlnopqrstuvwxyz"
"abcdefghijkmlnop..
"abcdefghijkmlnop..</code></pre>
<h3 id="1315-web-console-c">13.1.5 Web Console <code>\C</code></h3>
<p>The command <a href="https://code.kx.com/q/basics/syscmds/#c-http-size"><code>\C</code> [h w]</a> (note upper case) displays (no arguments) or sets (pair of height and width as integers) the size of the virtual q console display for HTTP requests. The default is <code>25 80i</code>. In a fresh q session, open port 5042 and point the browser to</p>
<pre class="highlight"><code class="language-txt">http://localhost:5042/?10 cut til 20</code></pre>
<p>The browser page will display,</p>
<pre class="highlight"><code class="language-txt">0  1  2  3  4  5  6  7  8  9
10 11 12 13 14 15 16 17 18 19</code></pre>
<p>Now issue the q command,</p>
<pre class="highlight"><code class="language-q">q)\C 10 20</code></pre>
<p>and refresh the browser page. The page will now display,</p>
<pre class="highlight"><code class="language-q">0  1  2  3  4  5 ..
10 11 12 13 14 15 ..</code></pre>
<h3 id="1316-change-os-directory-cd">13.1.6 Change OS Directory <code>\cd</code></h3>
<p>The <a href="https://code.kx.com/q/basics/syscmds/#cd-change-directory"><code>\cd</code> [<em>path</em>]</a> command is passed directly through to the OS. To display the current directory, issue <code>\cd</code> with no argument.</p>
<pre class="highlight"><code class="language-q">q)\cd
"/Users/jeffry"</code></pre>
<p>To change the current working directory, issue <code>\cd</code> followed by the path of the desired directory. If the specified directory does not exist, q displays the error message from the OS.</p>
<p>The <code>\cd</code> command creates the directory if it does not exist. For example, the directory <code>/data</code> is initially empty.</p>
<pre class="highlight"><code class="language-q">q)\ls /data
q)\cd /data/new
q)\ls /data
"new"</code></pre>
<div class="admonition note">
<p class="admonition-title">Windows users will know to write <code>\dir \data</code> and so on.</p>
</div>
<h3 id="1317-context-d">13.1.7 Context <code>\d</code></h3>
<p>The <a href="https://code.kx.com/q/basics/syscmds/#d-directory"><code>\d</code> [<em>namespace</em>]</a> command displays or changes the current context (a.k.a. <em>directory</em> in early versions of k). To determine the current context, issue <code>\d</code> with no parameter. In a fresh q session this will be the root. To change the current working context, include its namespace with the <code>\d</code> command. If the specified context does not exist, it will be created.</p>
<pre class="highlight"><code class="language-q">q)\d
`.
q)\d .jab
q.jab)\d .
q)\d .jab
q.jab)\d
`.jab
q.jab)\d .
q)\d
`.</code></pre>
<div class="admonition warning">
<p class="admonition-title">See our recommendations against using <code>\d</code> in <a href="https://code.kx.com/q4m3/12_Workspace_Organization/#127-working-in-a-context">¬ß12.7</a>.</p>
</div>
<h3 id="1318-error-trap-e">13.1.8 Error Trap <code>\e</code></h3>
<p>The <a href="https://code.kx.com/q/basics/syscmds/#e-error-trap-clients"><code>\e</code> [0|1]</a> command displays or changes the behavior of a q process when an exception occurs during processing a client (i.e., remote) IPC request.</p>
<p>In a fresh q session the default is 0, meaning that when an exception occurs the stack of the failing function is cleared and execution continues. This is the desired behavior for a production server, as you do not want wayward client requests to disable the process.</p>
<p>In a development or testing scenario you can set this value to 1 to enable the familiar stack trace from the interactive console.</p>
<h3 id="1319-functions-f">13.1.9 Functions <code>\f</code></h3>
<p>The <a href="https://code.kx.com/q/basics/syscmds/#f-functions"><code>\f</code> [<em>namespace</em>]</a> command displays a sorted list of symbolic names of functions in the current, or specified, working context. In a fresh q session,</p>
<pre class="highlight"><code class="language-q">q)\f
`symbol$()
q)f:{x*x}
q)g:{x*x*x}
q)\f
`s#`f`g
q).jab.f:{[] 42}
q)\f .jab
,`f</code></pre>
<h3 id="13110-garbage-collection-g">13.1.10 Garbage Collection <code>\g</code></h3>
<p><span class="twemoji"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path d="M542.22 32.05c-54.8 3.11-163.72 14.43-230.96 55.59-4.64 2.84-7.27 7.89-7.27 13.17v363.87c0 11.55 12.63 18.85 23.28 13.49 69.18-34.82 169.23-44.32 218.7-46.92 16.89-.89 30.02-14.43 30.02-30.66V62.75c.01-17.71-15.35-31.74-33.77-30.7zM264.73 87.64C197.5 46.48 88.58 35.17 33.78 32.05 15.36 31.01 0 45.04 0 62.75V400.6c0 16.24 13.13 29.78 30.02 30.66 49.49 2.6 149.59 12.11 218.77 46.95 10.62 5.35 23.21-1.94 23.21-13.46V100.63c0-5.29-2.62-10.14-7.27-12.99z"></path></svg></span>
<a href="https://code.kx.com/q/basics/syscmds/#g-garbage-collection-mode"><code>\g</code> command</a></p>
<p>Following is a description of q/kdb+ memory management provided by Charles Skelton, the KX CTO.</p>
<ul>
<li>Q/Kdb+ manages its own thread-local heap.</li>
<li>Vectors always have a capacity and a used size (the count).</li>
<li>There is no garbage since q/kdb+ uses reference counting. As soon as there are no references to an object, its memory is returned to the heap.</li>
<li>During that return of memory, q/kdb+ checks if the capacity of the object&nbsp; is ‚â•64MB. If it is and <code>\g</code> is 1, the memory is returned immediately to the OS; otherwise, the memory is returned to the thread-local heap for reuse.</li>
<li>Executing <a href="https://code.kx.com/q/ref/dotq/#qgc-garbage-collect"><code>.Q.gc[]</code></a> additionally attempts to coalesce pieces of the heap into their original allocation units and returns any units &gt;=64MB to the OS.</li>
<li>Beginning with 3.3 2015.08.23 ‚Äì Linux only ‚Äì unused pages in the heap are dropped from RSS during <code>.Q.gc[]</code>.</li>
<li>When q/kdb+ is denied additional address space from the OS, it will invoke <code>.Q.gc[]</code> and retry the request to the OS. Should that fail, it will exit with <code>'wsfull</code>.</li>
<li>When slave threads are configured and <code>.Q.gc[]</code> is invoked in the main thread it will automatically invoke <code>.Q.gc[]</code> in each slave thread. If the call is instigated in a slave thread ‚Äì i.e., not the main thread ‚Äì it will affect that thread‚Äôs local heap only.</li>
</ul>
<p>See <a href="#1325-garbage-collection-g">¬ß13.2.5</a> for the related command line parameter <a href="https://code.kx.com/q/basics/cmdline/#-g-garbage-collection"><code>-g</code></a>.</p>
<h3 id="13111-load-l">13.1.11 Load <code>\l</code></h3>
<p>The <a href="https://code.kx.com/q/basics/syscmds/#l-load-file-or-directory"><code>\l</code> <em>path</em></a> command loads a q resource from persistent storage ‚Äì here ‚Äúload‚Äù is used in a generic sense. The <em>path</em> parameter can be a directory or a file. Loosely speaking, the rules for loading are,</p>
<ul>
<li>When something is recognized as a q resource, the loading routine does what is appropriate to make that resource available in the workspace.</li>
<li>When something is not a recognized q resource, it fails.</li>
</ul>
<p>The loading process recognizes two types of files:</p>
<ul>
<li>A file can be a q (or k) script, which is executed as if the individual lines were entered from the console</li>
<li>A file can be a serialized q entity ‚Äì e.g., the sym file for a splayed or partitioned table. In this case, the entity is deserialized into memory into a variable having the name of the file.</li>
</ul>
<p>The situation for a directory is more complicated.</p>
<ul>
<li>The directory of a splayed table is mapped into memory with the name of the directory as the table name. None of the actual table data is actually loaded into memory at this time.</li>
<li>For a directory name that is the value of one of the permitted partition types, the most recent partition directory is inspected for splayed directories and each such directory is mapped into memory with the name of the splayed directory.</li>
<li>The root of a kdb+ database can contain: serialized q entities (e.g., the sym file), scripts (e.g., a start-up script), splayed table directories, partition directories or a par.txt file. In this case, the loading routine simply ‚Äúdoes‚Äù each entity that it finds, as outlined above. The scripts are executed last.</li>
</ul>
<p>For example, to load the distribution script <code>sp.q</code> from the <code>/mypath</code> directory,</p>
<pre class="highlight"><code class="language-q">q)\l /mypath/sp.q
_</code></pre>
<p>To map a database whose root is <code>/mypath/db</code>,</p>
<pre class="highlight"><code class="language-q">q)\l /mypath/db
_</code></pre>
<p>When a directory is mapped, the current working directory in the OS is set to that directory. This allows relative paths to subordinate items in the database and also helps to avoid wayward operations.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Once you have mapped a database into memory, you can issue the command <code>\l .</code> to remap the data without executing any start-up script(s) in the root.</p>
</div>
<h3 id="13112-gmt-offset-o">13.1.12 GMT Offset <code>\o</code></h3>
<p>The <a href="https://code.kx.com/q/basics/syscmds/#o-offset-from-utc"><code>\o</code> [<em>offset</em>]</a> command displays or changes the offset from GMT for q date/time values in the current q session. When the absolute value of the integer <em>offset</em> is strictly less than 24 it is interpreted as hours; if it is 24 or greater it is interpreted as minutes.</p>
<p>In a fresh q session, the value is <code>0Ni</code>, meaning that the underlying OS time zone offset is used.</p>
<pre class="highlight"><code class="language-q">q).z.t / GMT
15:20:10.892
q).z.T / I live in NY
11:20:07.700
q)\o / Using OS offset
0Ni
q).z.t-.z.T / No daylight savings in UK yet
04:00:00.000
q)\o -10 / Think about moving to Hawaii
q).z.T / Much better
05:21:23.155
q).z.t-.z.T / Hawaii doesn‚Äôt use daylight saving
10:00:00.000</code></pre>
<p>See <a href="#1327-offset-o">¬ß13.2.7</a> for the related command line parameter <a href="https://code.kx.com/q/basics/cmdline/#-o-utc-offset"><code>-o</code></a>.</p>
<h3 id="13113-port-p">13.1.13 Port <code>\p</code></h3>
<p>The <a href="https://code.kx.com/q/basics/syscmds/#p-listening-port"><code>\p</code> [<em>port</em>]</a> command displays or changes the port on which the q process is listening. In a fresh q session the value is <code>0i</code>, meaning that no port is open and connection attempts are rejected. To close the open port, use <code>0i</code> as <em>port</em>. In a fresh q session</p>
<pre class="highlight"><code class="language-q">q)\p
0i
q)\p 5042
q)\p
5042i
q)\p 0</code></pre>
<p>When you issue the <code>\p</code> command, q attempts to open the port but the security settings of your machine must allow it.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Once you open a port, that q session is wide open to all connections, including to HTTP traffic. We strongly recommend that you implement appropriate security around any process with an open port in a production environment.</p>
</div>
<p>See <a href="#1328-port-p">¬ß13.2.8</a> for the related command line parameter <a href="https://code.kx.com/q/basics/cmdline/#-p-listening-port"><code>-p</code></a>.</p>
<h3 id="13114-display-precision-p">13.1.14 Display Precision (\P)</h3>
<p>The command <a href="https://code.kx.com/q/basics/syscmds/#p-precision"><code>\P</code> [<em>precision</em>]</a> (note upper case) shows or sets the display precision for floating point numbers ‚Äì i.e., float and real types ‚Äì to the specified number of digits.</p>
<div class="admonition note">
<p class="admonition-title">Only the display of the floating point values is affected. The internal representation remains unchanged.</p>
</div>
<p>The permissible values are 0-17, with 0 meaning maximum. The default precision is 7, meaning that the display of float or real values is rounded to the seventh significant digit. In a fresh q session,</p>
<pre class="highlight"><code class="language-q">q)\P
7i
q)1%3
0.3333333
q)2%3
0.6666667
q)\P 0
q)1%3
0.33333333333333331
q)2%3
0.66666666666666663</code></pre>
<p>Notice the schmutz in the 17<sup>th</sup> significant digit. This is part of the dark mystery of binary floating point that is not mentioned in polite company.</p>
<p>You can use the semi-official functions <a href="https://code.kx.com/q/ref/dotq/#qf-format"><code>.Q.f</code></a> and <a href="https://code.kx.com/q/ref/dotq/#qfmt-format"><code>.Q.fmt</code></a> for controlled formatting of floating point values as strings.</p>
<p>See <a href="#13210-display-precision-p">¬ß13.2.10</a> for the related command line parameter <a href="https://code.kx.com/q/basics/cmdline/#-p-display-precision"><code>-P</code></a>.</p>
<h3 id="13115-replication-r">13.1.15 Replication <code>\r</code></h3>
<p>The replication command <a href="https://code.kx.com/q/basics/syscmds/#r-replication-master"><code>\r</code></a> is reserved for system use when using replicating servers. Do <strong>not</strong> use manually.</p>
<p>See <a href="#13212-replicate-r">¬ß13.2.12</a> for the related command line parameter <a href="https://code.kx.com/q/basics/cmdline/#-r-replicate"><code>-r</code></a>.</p>
<h3 id="13116-slaves-s">13.1.16 Slaves <code>\s</code></h3>
<p>The <a href="https://code.kx.com/q/basics/syscmds/#s-number-of-slaves"><code>\s</code></a> command displays the number of slaves available to the current q process. Read only. See <a href="#13213-slaves-s">¬ß13.2.13</a> for setting this value with the command line parameter <a href="https://code.kx.com/q/basics/cmdline/#-s-slaves"><code>-s</code></a>.</p>
<h3 id="13117-seed-s">13.1.17 Seed <code>\S</code></h3>
<p>The <a href="https://code.kx.com/q/basics/syscmds/#s-random-seed"><code>\S</code> [<em>seed</em>]</a> command (note upper case) displays or sets the initial seed for pseudo-random number generation to the integer value <em>seed</em>. This is useful for obtaining repeatable results from randomized testing. The default value is -314159.</p>
<p>In a simple q session without slaves and multi-threaded input, the behavior is simple. Resetting the seed to the default value allows the pseudo-random values to be reproduced.</p>
<pre class="highlight"><code class="language-q">q)\S
-314159i
q)5?10
8 1 9 5 4
q)5?10
6 6 1 8 5
q)\S -314159i
q)5?10
8 1 9 5 4</code></pre>
<p>When the q process is not started in single-threaded mode, things are more complicated.</p>
<ul>
<li>When the q process is started with a positive number of slaves, each slave gets its own seed (set internally) based on the slave number.</li>
<li>When the process is started in multi-threaded input mode, each thread gets a seed based on the socket descriptor.</li>
<li>When the process is started with negative slaves, each process on a specified range of ports gets its own seed based on the port number.</li>
</ul>
<h3 id="13118-set-timer-t">13.1.18 Set Timer <code>\t</code></h3>
<p>The <a href="https://code.kx.com/q/basics/syscmds/#t-timer"><code>\t</code></a> command has two interpretations, depending the type of its parameter. When <code>\t</code> [<em>millis</em>] is issued with a positive integer argument, it sets the number of milliseconds between timer ticks. The default value is <code>0i</code>, meaning that the timer does not fire. Setting to a non-zero value starts the timer, which will fire after the specified number of milliseconds Reset to <code>0i</code> to turn it off.</p>
<pre class="highlight"><code class="language-q">q).z.ts:{show .z.P}
q)\t 2000
q).z.ts:{show .z.P}
q)2015.03.24D10:59:34.993826000
2015.03.24D10:59:36.993888000
2015.03.24D10:59:38.992911000
\t 0
q)</code></pre>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The actual timer tick frequency is determined by the timing granularity supported by the underlying operating system. This can be considerably different from a millisecond.</p>
</div>
<p>See <a href="#13214-timer-t">¬ß13.2.14</a> for the related command line parameter <a href="https://code.kx.com/q/basics/cmdline/#-t-timer-ticks"><code>-t</code></a>.</p>
<h3 id="13119-elapsed-time-t-expr">13.1.19 Elapsed Time <code>\t <em>expr</em></code></h3>
<p>When <a href="https://code.kx.com/q/basics/syscmds/#t-timer"><code>\t</code> <em>expr</em></a> is issued with a valid q expression, the expression is evaluated and the execution duration in milliseconds is reported. This can be used to profile code execution when tuning an application.</p>
<p>Some expressions execute so quickly in q that the result is less than the timer granularity. Fortunately <code>\t:<em>x</em></code> obviates what was formerly the only valid use of <code>do</code> in q ‚Äì namely, repeating the expression evaluation to raise its execution time above the timer floor.</p>
<pre class="highlight"><code class="language-q">q)\t sum til 100000
0
q)\t:1000 sum til 100000
453</code></pre>
<p>We conclude that adding the first 100,000 integers once requires approximately 453 milliseconds.</p>
<div class="admonition tip">
<p class="admonition-title">Of course you would never evaluate this exact expression in practice; instead, use the insight of the young Gauss.</p>
</div>
<h3 id="13120-elapsed-time-and-space-ts-expr">13.1.20 Elapsed Time and Space (\ts <em>expr</em>)</h3>
<p>The <a href="https://code.kx.com/q/basics/syscmds/#ts-time-and-space"><code>\ts</code> <em>expr</em></a> command is an enhancement of the version of <code>\t</code> that times an expression. It provides both the time and the number of bytes used in evaluating the expression.</p>
<pre class="highlight"><code class="language-q">q)\ts log til 100000
4 3145856</code></pre>
<p>You can also specify the number of repetitions, as with <code>\t</code>.</p>
<pre class="highlight"><code class="language-q">q)\ts:100 log til 100000
248 3145824</code></pre>
<h3 id="13121-timeout-t">13.1.21 Timeout <code>\T</code></h3>
<p>The <a href="https://code.kx.com/q/basics/syscmds/#t-timeout"><code>\T</code> <em>secs</em></a> command (note upper case) sets the number of <strong>seconds</strong> a remotely initiated execution will run before timing out. The default value is 0, meaning that such execution will not timeout. This is useful to protect against runaway client calls when the q process is acting as a server.</p>
<p>See <a href="#13215-timeout-t">¬ß13.2.15</a> for the related command line parameter <a href="https://code.kx.com/q/basics/cmdline/#-t-timeout"><code>-T</code></a>.</p>
<h3 id="13122-user-password-u">13.1.22 User Password <code>\u</code></h3>
<p>When the q process has been started with the ‚Äìu command to load a password file, the <a href="https://code.kx.com/q/basics/syscmds/#u-reload-user-password-file"><code>\u</code></a> command reloads the password file. This allows the password to be changed while the process is running.</p>
<p>See <a href="#13217-user-validation-u">¬ß13.2.17</a> for the related command line parameter <a href="https://code.kx.com/q/basics/cmdline/#-u-usr-pwd-local"><code>-u</code></a>.</p>
<h3 id="13123-variables-v">13.1.23 Variables <code>\v</code></h3>
<p>The <a href="https://code.kx.com/q/basics/syscmds/#v-variables"><code>\v</code> [<em>namespace</em>]</a> command displays a sorted list of symbolic names of all variables in the specified context when the <em>namespace</em> parameter is present, or the current working context if it is not. In a fresh q session,</p>
<pre class="highlight"><code class="language-q">q)\v
`symbol$()
q)a:b:c:42
q)\v
`a`b`c
q)\v .
`a`b`c
q).jab.a:43
q)\v .jab
,`a</code></pre>
<h3 id="13124-workspace-w">13.1.24 Workspace <code>\w</code></h3>
<p>The workspace command <a href="https://code.kx.com/q/basics/syscmds/#w-workspace"><code>\w</code> [0]</a> displays information about resource utilization in the current q session. When the parameter is not present, it returns a list of six integers:</p>
<ul>
<li>Number of bytes allocated</li>
<li>Number bytes available in heap</li>
<li>Maximum heap size used heretofore in session</li>
<li>Maximum bytes available as specified at startup in&nbsp;<a href="https://code.kx.com/q/basics/cmdline/#-w-workspace"><code>-w</code></a></li>
<li>Number of bytes for mapped entities</li>
<li>Number of bytes of physical (i.e. machine) memory</li>
</ul>
<p>For example, in a fresh q session on the author‚Äôs laptop:</p>
<pre class="highlight"><code class="language-q">q)\w
118256 67108864 67108864 0 0 17179869184
q)bigdata:til 200000000
q)\w
2147601952 2214592512 2214592512 0 0 17179869184</code></pre>
<p>When the parameter is present, <code>\w 0</code> returns a list with two items relating to symbol usage: the number of symbols and the corresponding number of bytes of memory used. For example, in a fresh q session on the author‚Äôs laptop:</p>
<pre class="highlight"><code class="language-q">q)\w 0
566 18470
q)lottasyms:1000000?`5
q)\w
4312768 67108864 67108864 0 0 17179869184</code></pre>
<h3 id="13125-week-offset-w">13.1.25 Week Offset <code>\W</code></h3>
<p>The week offset command <a href="https://code.kx.com/q/basics/syscmds/#w-week-offset"><code>\W</code> [<em>offset</em>]</a> (note upper case) displays or sets the week offset. An offset of 0 corresponds to Saturday. The default is 2, which is Monday. This is useful in controlling weekends when aggregating weekly data. In a fresh q session,</p>
<pre class="highlight"><code class="language-q">q)\W
2i
q)group `week$2015.01.01+til 10
2014.12.29| 0 1 2 3
2015.01.05| 4 5 6 7 8 9
q)\W 0
q)group `week$2015.01.01+til 10
2014.12.27| 0 1
2015.01.03| 2 3 4 5 6 7 8
2015.01.10| ,9
q)\W 1
q)group `week$2015.01.01+til 10
_</code></pre>
<h3 id="13126-expunge-handler-x">13.1.26 Expunge Handler <code>\x</code></h3>
<p>The expunge handler command <a href="https://code.kx.com/q/basics/syscmds/#x-expunge"><code>\x</code> <em>handler</em></a> un-assigns a user specified event handler for one of the <code>.z.*</code> event handlers and restores the default system behavior. For example, here is how you can customize the console response and then restore the original behavior.</p>
<pre class="highlight"><code class="language-q">q).z.pi:{"==&gt;",.Q.s value x}
q)42
==&gt;42
q)43
==&gt;43
q)\x .z.pi
==&gt;q)43
43
q)44
44</code></pre>
<div class="admonition note">
<p class="admonition-title">There is no default handler for <a href="https://code.kx.com/q/ref/dotz/#zph-http-get"><code>.z.ph</code></a> so expunge does not work there.</p>
</div>
<h3 id="13127-date-format-z">13.1.27 Date Format <code>\z</code></h3>
<p>The date parsing format command <a href="https://code.kx.com/q/basics/syscmds/#z-date-parsing"><code>\z</code> [0|1]</a> displays or specifies the format for date parsing. A value of 0 corresponds to month-then-day ‚Äì as in <em>mm</em>/<em>dd</em>/<em>yyyy</em> ‚Äì and a value of 1 corresponds to day-then month ‚Äì as in <em>dd</em>/<em>mm</em>/<em>yyyy</em>. The default value is <code>0i</code>. In a fresh q session,</p>
<pre class="highlight"><code class="language-q">q)\z
0i
q)"D"$"12/31/2015"
2015.12.31
q)"D"$"31/12/2015"
0Nd
q)\z 1
q)"D"$"12/31/2015"
0Nd
q)"D"$"31/12/2015"
2015.12.31</code></pre>
<p>See <a href="#13221-date-parsing-format-z">¬ß13.2.21</a> for the related command line parameter <a href="https://code.kx.com/q/basics/cmdline/#-z-date-format"><code>-z</code></a>.</p>
<h3 id="13128-lock-script-_">13.1.28 Lock Script <code>\_</code></h3>
<p>The <a href="https://code.kx.com/q/basics/syscmds/#_-hide-q-code"><code>\_</code></a> command with no parameter checks to see if client write access is blocked. See the description of <code>‚Äìb</code> in <a href="#1321-block-database-modification-b">¬ß13.2.1</a>.</p>
<p>The <code>_ <em>script.q</em></code> command transforms the specified script file into an equivalent one in <code>script.q\_</code> that can be loaded and executed with <code>\l</code> but whose contents are scrambled for human eyes. The resulting file cannot be viewed, serialized or modified.</p>
<p>For example, suppose we have saved the following script as <code>/scripts/sensitive.q</code>.</p>
<pre class="highlight"><code class="language-q">secret:42
reveal:{[] 42}</code></pre>
<p>Then we can lock it as follows.</p>
<pre class="highlight"><code class="language-q">q)\_ sensitive.q
`sensitive.q_
q)\l sensitive.q_
q)secret
q)reveal[]
42
q)reveal / ignored
q)-8!reveal / ignored
q)read1`:sensitive.q_ / scrambled
_</code></pre>
<h3 id="13129-redirect-1-and-2">13.1.29 Redirect <code>\1</code> and <code>\2</code></h3>
<p>These commands<a href="https://code.kx.com/q/basics/syscmds/#1-2-redirect"> <code>\1</code> and <code>\2</code></a> allow you to redirect the OS stdout and stderr from within a q session. Follow the command with a file name for the redirected output. In a fresh q session,</p>
<pre class="highlight"><code class="language-q">q)\1 /data/out.txt
q)1+2*til 5
q)\2 /data/err.txt
6*`7
\\
&gt;cat /data/out.txt
1 3 5 7 9
&gt;cat /data/err.txt
q)'type</code></pre>
<h3 id="13130-operating-system-text">13.1.30 Operating System <code>\<em>text</em></code></h3>
<p>The command <a href="https://code.kx.com/q/basics/syscmds/#os-commands"><code>\<em>oscmd</em></code></a>, in which <em>oscmd</em> is any text not recognized as a q command, is assumed to be an operating system command and is passed to the OS for execution. Any output to stdout will be returned to q as strings. This is handy to avoid having to exit the q session and can be done programmatically with the <a href="https://code.kx.com/q/ref/system/"><code>system</code></a> function. For example, on the author‚Äôs laptop,</p>
<pre class="highlight"><code class="language-q">q)\pwd
"/q4m"
q)\ls /pages
"c.js"
"sample0.html"
"sample1.html"
"sample2.html"
"ws101.html"
"ws101.q"
q)pages:system "ls /pages"
q)pages
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>If oscmd results in an operating system error, an exception will be thrown in q. For safe programmatic execution, you can trap the exception by executing oscmd with system wrapped in protected evaluation.</p>
</div>
<h3 id="13131-interrupt-ctl-c-and-ctl-z">13.1.31 Interrupt (Ctl-c and Ctl-z)</h3>
<p>You can interrupt a long-running q function with Ctl-c. Note that some q functions are so tight that the interrupt may not be registered. You can terminate any q console session with extreme prejudice using Ctl-z, which will result in all contents of the workspace being lost.</p>
<h3 id="13132-terminate">13.1.32 Terminate <code>\</code></h3>
<p>Use <a href="https://code.kx.com/q/basics/syscmds/#terminate"><code>\</code></a> to terminate one level of suspended execution arrived at via an exception.</p>
<pre class="highlight"><code class="language-q">q)f:{x*y}
q)f[2;`3]
{x*y}
'type
*
2
`3
q))\
q)‚òê</code></pre>
<div class="admonition warning">
<p class="admonition-title">Do not have an itchy trigger finger when exiting multiple levels of suspended evaluation, as <code>\\</code> will exit the q session immediately.</p>
</div>
<p>If you are adventuresome, you can also issue <code>\</code> at the normal q console prompt to toggle between the q interpreter and the k interpreter.</p>
<pre class="highlight"><code class="language-q">q)\
a:42
-a
-42
\
q)-a
'-</code></pre>
<h3 id="13133-exit">13.1.33 Exit <code>\\</code></h3>
<p>To exit the q process, enter a double backslash <a href="https://code.kx.com/q/basics/syscmds/#quit"><code>\\</code></a> at any console prompt.</p>
<pre class="highlight"><code class="language-q">q)\\
$</code></pre>
<div class="admonition warning">
<p class="admonition-title">There is no confirmation prompt for <code>\\</code>. The q session is terminated with extreme prejudice.</p>
</div>
<div class="admonition tip">
<p class="admonition-title">For programmatic q shutdown, use <a href="https://code.kx.com/q/ref/exit/"><code>exit</code></a> with a return value, which can be piped into other processes.</p>
</div>
<h2 id="132-command-line-parameters">13.2 Command Line Parameters</h2>
<p><span class="twemoji"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path d="M542.22 32.05c-54.8 3.11-163.72 14.43-230.96 55.59-4.64 2.84-7.27 7.89-7.27 13.17v363.87c0 11.55 12.63 18.85 23.28 13.49 69.18-34.82 169.23-44.32 218.7-46.92 16.89-.89 30.02-14.43 30.02-30.66V62.75c.01-17.71-15.35-31.74-33.77-30.7zM264.73 87.64C197.5 46.48 88.58 35.17 33.78 32.05 15.36 31.01 0 45.04 0 62.75V400.6c0 16.24 13.13 29.78 30.02 30.66 49.49 2.6 149.59 12.11 218.77 46.95 10.62 5.35 23.21-1.94 23.21-13.46V100.63c0-5.29-2.62-10.14-7.27-12.99z"></path></svg></span>
<a href="https://code.kx.com/q/basics/cmdline/">Command line options</a></p>
<p>When you start q from the command line, you can optionally follow the q executable immediately with a file or directory to be ‚Äúloaded‚Äù upon startup. This is effectively the same as issuing the <code>\l</code> command with that file or directory as the first action in the q session.</p>
<p>Following the q executable and the file name, you can include one or more command-line options. Each is prefaced with <code>-</code> and followed by whitespace and an optional parameter value. Many of the command-line parameters have equivalent q commands that can be issued within the session.</p>
<h3 id="1321-block-database-modification-b">13.2.1 Block Database Modification <code>-b</code></h3>
<p>The <a href="https://code.kx.com/q/basics/cmdline/#-b-blocked"><code>‚Äìb</code></a> command line parameter disallows connected clients to modify data. This includes setting global variables or modifying files.</p>
<div class="admonition tip">
<p class="admonition-title">This behavior is only in effect for operations initiated via remote (i.e., client) connection, so you will not see the effects in a console session on the server process.</p>
</div>
<h3 id="1322-console-size-c">13.2.2 Console Size <code>-c</code></h3>
<p>The <a href="https://code.kx.com/q/basics/cmdline/#-c-console-size"><code>‚Äìc <em>r c</em></code></a> parameter specifies a pair of integers for the size of the q virtual console display as rows and columns. The default size is <code>25 80i</code>.</p>
<h3 id="1323-http-console-c">13.2.3 HTTP Console <code>-C</code></h3>
<p>The <a href="https://code.kx.com/q/basics/cmdline/#-c-http-size"><code>‚ÄìC <em>r c</em></code></a> parameter (note upper case) specifies a pair of integers for the size of the HTTP virtual console display as rows and columns. The default setting is 36 by 2000.</p>
<h3 id="1324-client-error-trapping-e">13.2.4 Client Error Trapping <code>-e</code></h3>
<p>The <a href="https://code.kx.com/q/basics/cmdline/#-e-error-traps"><code>-e</code> 0|1</a> parameter enables or disables trapping exceptions arising during processing IPC requests. The default is 0.</p>
<h3 id="1325-garbage-collection-g">13.2.5 Garbage Collection (-g)</h3>
<p>The <a href="https://code.kx.com/q/basics/cmdline/#-g-garbage-collection"><code>-g</code> 0|1</a> parameter sets the garbage collection behavior. See <a href="#13110-garbage-collection-g">¬ß13.1.10</a> for an explanation.</p>
<h3 id="1326-logging-l-and-l">13.2.6 Logging <code>-l</code> and <code>-L</code></h3>
<p>The <a href="https://code.kx.com/q/basics/cmdline/#-l-log-updates"><code>-l</code></a> parameter starts q with logging of remote requests enabled. Following is a brief description of how logging works; see <a href="https://code.kx.com/q/kb/logging/">the KX site</a> for more information. The <a href="https://code.kx.com/q/basics/cmdline/#-l-log-sync"><code>‚ÄìL</code></a> parameter (note upper case) forces disk write on each remote execution.</p>
<p>A logging server uses files with <code>.log</code> and <code>.qdb</code> extensions and name specified immediately after the q executable on the command line that starts q. For example, starting q with</p>
<pre class="highlight"><code class="language-q">$q /data/logdemo -l
will use files /data/logdemo.log and /data/logdemo.qdb.</code></pre>
<p>The idea of logging is that each time a remote request is executed, it is logged. Periodically the application issues the <code>\l</code> command to checkpoint the current state of the workspace (more specifically, to serialize and persist the root context) and clear the log.</p>
<p>Should a logging process terminate abruptly, restarting it with the same <code>‚Äìl</code> command causes the most recently persisted state to be restored. Specifically, the serialized root context is restored from the <code>.qdb</code> file and requests that were processed after the state was persisted are replayed from the <code>.log</code> file.</p>
<p>Note that although only remote requests are logged, the process can ensure that its own activity is logged by sending requests to itself with the reserved handle 0.</p>
<p>Here is a simple session that demonstrates the logging scenario using local activity. Remote activity works the same.</p>
<pre class="highlight"><code class="language-q">&gt;q /data/logdemo -l
q)0 "a:42"
q)0 "b:43"
q)\l
q)\\
&gt;q /data/logdemo -l
q)a
42
q)b
4</code></pre>
<h3 id="1327-offset-o">13.2.7 Offset <code>-o</code></h3>
<p>The <a href="https://code.kx.com/q/basics/cmdline/#-o-utc-offset"><code>‚Äìo</code> <em>offset</em></a> parameter specifies the offset from GMT for q time values. See <a href="#13110-garbage-collection-g">¬ß13.1.10</a> for an explanation.</p>
<h3 id="1328-port-p">13.2.8 Port <code>-p</code></h3>
<p>The <a href="https://code.kx.com/q/basics/cmdline/#-p-listening-port"><code>‚Äìp</code> <em>portnum</em></a> parameter opens <em>portnum</em> for TCP/IP and HTTP traffic. The default is 0 meaning that no port is open.</p>
<div class="admonition tip">
<p class="admonition-title">Only one port can be open in a given q session.</p>
</div>
<h3 id="1329-multithreaded-session-p">13.2.9 Multithreaded Session <code>-p</code></h3>
<p>The <code>‚Äìp</code> -<em>portnum</em> parameter starts the q session in multithreaded mode. See <a href="https://code.kx.com/q/kb/multithreaded-input/">the KX site</a> for information on how this works.</p>
<h3 id="13210-display-precision-p">13.2.10 Display Precision <code>-P</code></h3>
<p>The <a href="https://code.kx.com/q/basics/cmdline/#-p-display-precision"><code>‚ÄìP</code> <em>digits</em></a> parameter (note upper case) specifies the number of digits for floating-point display. See <a href="#13114-display-precision-92p">¬ß13.1.14</a> for an explanation.</p>
<h3 id="13211-quiet-q">13.2.11 Quiet <code>-q</code></h3>
<p>The <a href="https://code.kx.com/q/basics/cmdline/#-q-quiet-mode"><code>‚Äìq</code></a> parameter starts q quietly, meaning that no start-up banner is displayed and there is no q prompt at the console.</p>
<h3 id="13212-replicate-r">13.2.12 Replicate <code>-r</code></h3>
<p>The <a href="https://code.kx.com/q/basics/cmdline/#-r-replicate"><code>‚Äìr</code></a> parameter starts a replicating q server. See the KX web site for information on replication.</p>
<h3 id="13213-slaves-s">13.2.13 Slaves <code>-s</code></h3>
<p>The <a href="https://code.kx.com/q/basics/cmdline/#-s-slaves"><code>‚Äìs</code> <em>N</em></a> parameter starts the q process with <em>N</em> slaves for concurrent execution. See <a href="https://code.kx.com/q/basics/peach/">the KX web site</a> for information on slaves.</p>
<h3 id="13214-timer-t">13.2.14 Timer <code>-t</code></h3>
<p>The <a href="https://code.kx.com/q/basics/cmdline/#-t-timer-ticks"><code>‚Äìt</code> <em>millis</em></a> command specifies the number of milliseconds between timer ticks. See <a href="#13117-seed-s">¬ß13.1.17</a> for an explanation.</p>
<h3 id="13215-timeout-t">13.2.15 Timeout <code>-T</code></h3>
<p>The <a href="https://code.kx.com/q/basics/cmdline/#-t-timeout"><code>‚ÄìT</code> <em>secs</em></a> parameter specifies the number of seconds for timeout of remote requests. See <a href="#13120-elapsed-time-and-space-92ts-expr">¬ß13.1.20</a> for an explanation.</p>
<h3 id="13216-exit-u">13.2.16 Exit (-u)</h3>
<p>The <a href="https://code.kx.com/q/basics/cmdline/#-u-disable-syscmds"><code>‚Äìu 1</code></a> parameter disables calling out to the OS via <code>system</code>.</p>
<h3 id="13217-user-validation-u">13.2.17 User Validation <code>-u</code></h3>
<p>The <a href="https://code.kx.com/q/basics/cmdline/#-u-usr-pwd-local"><code>‚Äìu</code> <em>filename</em></a> parameter starts a q session with a file of user names and passwords that will be checked when a remote connection requests is received. The remote connection has <strong>no access</strong> outside the database root directory.</p>
<h3 id="13218-user-validation-u">13.2.18 User Validation <code>-U</code></h3>
<p>The <a href="https://code.kx.com/q/basics/cmdline/#-u-usr-pwd"><code>‚ÄìU</code> <em>filename</em></a> parameter (note upper case) starts a q session with a file of user names and passwords that will be checked when a remote connection requests is received. <strong>No restriction</strong> is placed on file system access by remote connections.</p>
<h3 id="13219-workspace-size-w">13.2.19 Workspace Size <code>-w</code></h3>
<p>The <a href="https://code.kx.com/q/basics/cmdline/#-w-workspace"><code>‚Äìw</code> <em>bytes</em></a> parameter specifies the maximum virtual size of the workspace in bytes. Any attempt to allocate more than this amount of memory will result in a <code>'wsfull</code> exception and immediate termination of the q process. The default is twice the amount of physical machine memory.</p>
<h3 id="13220-week-offset-w">13.2.20 Week Offset <code>-W</code></h3>
<p>The <a href="https://code.kx.com/q/basics/cmdline/#-w-start-week"><code>‚ÄìW</code> <em>offset</em></a> parameter (note upper case) sets the offset of the beginning of the week relative to Saturday. See <a href="#13124-workspace-w">¬ß13.1.24</a> for the related <a href="https://code.kx.com/q/basics/syscmds/#w-week-offset"><code>\W</code></a> command.</p>
<h3 id="13221-date-parsing-format-z">13.2.21 Date Parsing Format <code>-z</code></h3>
<p>The <a href="https://code.kx.com/q/basics/cmdline/#-z-date-format"><code>‚Äìz</code> 0|1</a> parameter specifies the date parsing format. See <a href="#13125-week-offset-w">¬ß13.1.25</a> for details in the related <code>\W</code> command.</p>
<h2 id="133-system-variables">13.3 System Variables</h2>
<p>Variables in the <a href="https://code.kx.com/q/ref/dotz/"><code>.z</code> namespace</a> reflect q environmental information and behavior.</p>
<h3 id="1331-ip-address-za">13.3.1 IP Address <code>.z.a</code></h3>
<p>The system variable <a href="https://code.kx.com/q/ref/dotz/#za-ip-address"><code>.z.a</code></a> is an encoded int representing the IP address of the current running q instance. To see the usual four-integer IP address, decode the int using base 256. For example, on the author‚Äôs laptop,</p>
<pre class="highlight"><code class="language-q">q).z.a
-1407972861i
q)`int$0x0 vs .z.a
172 20 10 3i</code></pre>
<h3 id="1332-access-control-zac">13.3.2 Access Control (.z.ac)</h3>
<p>Assign a function to the system variable <a href="https://code.kx.com/q/ref/dotz/#zac-http-auth-from-cookie"><code>.z.ac</code></a> to process Single Sign On (SSO) token cookies from the HTTP header. Your handler is passed a two-item list comprising the request text and a dictionary containing the elements of the request header. Your custom code should process the <code>Authorization</code> value of the dictionary and should return a list in one of the following forms:</p>
<ul>
<li><code>(0; "")</code> to indicate 401 page not found</li>
<li><code>(1; "</code><em>username</em><code>")</code> to indicate that <em>username</em> has been validated and to assign this value to <code>.z.u</code></li>
<li><code>(2; "</code><em>raw text</em><code>")</code> to send raw response text to the client</li>
</ul>
<p>Note that <code>.z.ac</code> supersedes <code>.z.pw</code> when defined.</p>
<h3 id="1333-dependencies-zb">13.3.3 Dependencies <code>.z.b</code></h3>
<p>The system variable [<code>.z.b</code>][https://code.kx.com/q/ref/dotz/#zb-dependencies) is a dictionary that represents the (direct) dependencies of all aliases. The keys are symbolic names of entities in the workspace and the associated values are lists of symbolic names of entities that depend directly on the entity named by the key.</p>
<p>In a fresh q session,</p>
<pre class="highlight"><code class="language-q">q)a::x+y
q)b::x*x
q)c::a+b
q).z.b
x| `a`b
y| ,`a
a| ,`c
b| ,`c</code></pre>
<p>It is a nice exercise to write a q expression that recursively finds all dependencies, not just direct ones. Another nice exercise is to invert the dictionary to relate the name of an entity to everything it depends on.</p>
<h3 id="1334-cores-zc">13.3.4 Cores <code>.z.c</code></h3>
<p>The system variable <a href="https://code.kx.com/q/ref/dotz/#zc-cores"><code>.z.c</code></a> represents the number of cores on the physical machine hosting the q process. Hardware with hyper-threading reports the number of virtual cores.</p>
<h3 id="1335-exit-routine-zexit">13.3.5 Exit Routine <code>.z.exit</code></h3>
<p>The system variable <a href="https://code.kx.com/q/ref/dotz/#zexit-action-on-exit"><code>.z.exit</code></a> specifies a handler to be called just before the q process exits in order to clean up resources.</p>
<div class="admonition important">
<p class="admonition-title">The handler cannot cancel the exit.</p>
</div>
<p>The parameter passed to the handler is <code>0i</code> if the exit was invoked manually with <code>\\</code> or it is the argument to the <a href="https://code.kx.com/q/ref/exit/"><code>exit</code></a> function when that was called programmatically.</p>
<p>In a fresh q session,</p>
<pre class="highlight"><code class="language-q">q).z.exit:{show x}
q)\\
0i</code></pre>
<p>Or in another fresh q session,</p>
<pre class="highlight"><code class="language-q">q).z.exit:{show x}
q)exit 43
43i</code></pre>
<p>Note that if the handler itself throws an exception ‚Äì deliberate or otherwise ‚Äì the session will be suspended at that error.</p>
<pre class="highlight"><code class="language-q">q).z.exit:{'bad}
q)exit 0
{'bad}
'bad
q))</code></pre>
<div class="admonition tip">
<p class="admonition-title">The default exit behavior can be restored by expunging with <code>\x</code>.</p>
</div>
<h3 id="1336-global-date-zd">13.3.6 Global Date <code>.z.d</code></h3>
<p>The system variable <a href="https://code.kx.com/q/ref/dotz/#zt-zt-zd-zd-timedate-shortcuts"><code>.z.d</code></a> retrieves the date component of Greenwich Mean Time (GMT) and is equivalent to <code>`date$.z.p</code>.</p>
<h3 id="1337-local-date-zd">13.3.7 Local Date <code>.z.D</code></h3>
<p>The system variable <a href="https://code.kx.com/q/ref/dotz/#zt-zt-zd-zd-timedate-shortcuts"><code>.z.D</code></a> retrieves the local date component according to the time zone offset from GMT and is equivalent to <code>`date$.z.P</code>.</p>
<h3 id="1338-startup-file-zf">13.3.8 Startup File <code>.z.f</code></h3>
<p>The system variable <a href="https://code.kx.com/q/ref/dotz/#zf-file"><code>.z.f</code></a> is a symbol representing the file parameter entered on the q start-up command line. For example,
</p><pre class="highlight"><code class="language-bash">$ q /scripts/answer.q</code></pre>
<pre class="highlight"><code class="language-q">q).z.f
`/scripts/answer.q</code></pre>
<h3 id="1339-host-zh">13.3.9 Host <code>.z.h</code></h3>
<p>The variable <a href="https://code.kx.com/q/ref/dotz/#zh-host"><code>.z.h</code></a> is a symbol representing the network name of the host running the q instance, which is the same as the OS command hostname on Unix. For example, on the author‚Äôs laptop,</p>
<pre class="highlight"><code class="language-q">q).z.h
`aerowing.local</code></pre>
<h3 id="13310-process-id-zi">13.3.10 Process ID <code>.z.i</code></h3>
<p>The variable <a href="https://code.kx.com/q/ref/dotz/#zi-pid"><code>.z.i</code></a> is an int representing the process ID of the running q instance. For example, on the author‚Äôs laptop,</p>
<pre class="highlight"><code class="language-q">q).z.i
4903i</code></pre>
<div class="admonition warning">
<p class="admonition-title">As of this writing (Sep 2015), <code>.z.i</code> is not implemented on Windows.</p>
</div>
<h3 id="13311-release-date-zk">13.3.11 Release Date <code>.z.k</code></h3>
<p>The system variable <a href="https://code.kx.com/q/ref/dotz/#zk-release-date"><code>.z.k</code></a> is a date value representing the release date of the running q instance. For example, on the author‚Äôs laptop,</p>
<pre class="highlight"><code class="language-q">q).z.k
2014.11.01</code></pre>
<h3 id="13312-release-version-zk">13.3.12 Release Version <code>.z.K</code></h3>
<p>The system variable <a href="https://code.kx.com/q/ref/dotz/#zk-version"><code>.z.K</code></a> is a float value representing the major version of the running q instance. For example, on the author‚Äôs laptop,</p>
<pre class="highlight"><code class="language-q">q).z.K
3.2</code></pre>
<h3 id="13313-license-information-zl">13.3.13 License Information <code>.z.l</code></h3>
<p>The system variable <a href="https://code.kx.com/q/ref/dotz/#zl-license"><code>.z.l</code></a> is a list of strings containing information about the license of the running kdb+ instance. The most useful are the items in positions 1 and 2, which represent the expiry date and update date, respectively. For example, on a system long, long ago,</p>
<pre class="highlight"><code class="language-q">q).z.l
("";"2007.07.01";"2007.07.01";,"1";,"1";,"0";,"0")</code></pre>
<div class="admonition info">
<p class="admonition-title">The value of <code>.z.l</code> is <code>()</code> for 32‚Äìbit non-production versions of q.</p>
</div>
<h3 id="13314-gmt-timespan-zn">13.3.14 GMT Timespan <code>.z.n</code></h3>
<p>The system variable <a href="https://code.kx.com/q/ref/dotz/#zn-utc-timespan"><code>.z.n</code></a> retrieves the timespan component of Greenwich Mean Time (GMT) and is equivalent to <code>`timespan$.z.p</code>.</p>
<h3 id="13315-local-timespan-zn">13.3.15 Local Timespan <code>.z.N</code></h3>
<p>The system variable <a href="https://code.kx.com/q/ref/dotz/#zn-local-timespan"><code>.z.N</code></a> retrieves the local timespan component according to the time zone offset from GMT and is equivalent to <code>`timespan$.z.P</code>.</p>
<h3 id="13316-os-zo">13.3.16 OS <code>.z.o</code></h3>
<p>The system variable <a href="https://code.kx.com/q/ref/dotz/#zo-os-version"><code>.z.o</code></a> is a symbol representing the operating system hosting the current q process. For example, this text is being written on a 32-bit Mac system.</p>
<pre class="highlight"><code class="language-q">q).z.o
`m32</code></pre>
<h3 id="13317-gmt-timestamp-zp">13.3.17 GMT Timestamp <code>.z.p</code></h3>
<p>The system variable <a href="https://code.kx.com/q/ref/dotz/#zp-utc-timestamp"><code>.z.p</code></a> retrieves the current Greenwich Mean Time (GMT) with nanosecond resolution. It is the basis for all other date and time values in the .z namepsace.</p>
<p>For example, at the exact time of this writing we find,</p>
<pre class="highlight"><code class="language-q">q).z.p
2015.03.26D17:40:21.997067000</code></pre>
<h3 id="13318-local-timestamp-zp">13.3.18 Local Timestamp <code>.z.P</code></h3>
<p>The system variable <a href="https://code.kx.com/q/ref/dotz/#zp-local-timestamp"><code>.z.P</code></a> displays the current local nanosecond resolution from <code>.z.p</code> according to the time zone offset.</p>
<p>For example, at the exact time of this writing in the Hawaii time zone we find,</p>
<pre class="highlight"><code class="language-q">q).z.P
2015.03.26D07:41:11.269534000</code></pre>
<h3 id="13319-on-close-zpc">13.3.19 On Close <code>.z.pc</code></h3>
<p>Assign a q function to the system variable <a href="https://code.kx.com/q/ref/dotz/#zpc-close"><code>.z.pc</code></a> to be invoked <strong>after</strong> a connection is closed ‚Äì a.k.a. ‚Äúprocess close.‚Äù At the point your handler is invoked, the other variables associated with the connection ‚Äì e.g., <a href="https://code.kx.com/q/ref/dotz/#zw-handle"><code>.z.w</code></a> ‚Äì have already been wiped. The handle of the connection that has just been closed is passed as the lone parameter to your handler so that you can clean up any resources associated with it in your application.</p>
<p>To reset to the default setting, expunge the handler with <code>\x .z.pc</code>.</p>
<h3 id="13320-peach-distribution-zpd">13.3.20 Peach Distribution <code>.z.pd</code></h3>
<p>Assign an int list or q function representing an event handler to the system variable <a href="https://code.kx.com/q/ref/dotz/#zpd-peach-handles"><code>.z.pd</code></a> for use by <a href="https://code.kx.com/q/ref/each/#peach"><code>peach</code></a> for a q process that has been started with the <code>‚Äìs</code> command line parameter with a negative value. Your handler supplies a list of ints representing open handles to other processes and will be called by <code>peach</code> when it distributes work to those processes. These handles must not be used for other processing as <code>peach</code> will close any handle that presents data it is not accepting. See <a href="https://code.kx.com/q4m3/A_Built-in_Functions/#a682-distributed-peach">¬ßA.68.2</a> on distributed processing with <code>peach</code>.</p>
<div class="admonition tip">
<p class="admonition-title">The int return list of your handler must have the <code>`u#</code> attribute applied.</p>
</div>
<p>Here is a simple example that opens and returns five handles on the local machine starting at port 20000. It assumes that worker processes have already been started with these ports open. See the <a href="https://code.kx.com/q/basics/ipc/">KX site</a> for more comprehensive examples. </p>
<pre class="highlight"><code class="language-q">q).z.pd:{`u#hopen each 20000+til 5}</code></pre>
<h3 id="13321-on-synchronous-message-zpg">13.3.21 On Synchronous Message <code>.z.pg</code></h3>
<p>Assign a function to the system variable <a href="https://code.kx.com/q/ref/dotz/#zpg-get"><code>.z.pg</code></a> to be invoked whenever a remote client q process makes a synchronous call over an open connection ‚Äì a.k.a. ‚Äúprocess get.‚Äù The name derives from the fact that a synchronous call has get semantics. The default behavior applies <a href="https://code.kx.com/q/ref/value/"><code>value</code></a> to the incoming message.</p>
<p>To reset to the default setting, expunge the handler with <code>\x .z.pg</code>.</p>
<h3 id="13322-on-http-get-zph">13.3.22 On HTTP Get <code>.z.ph</code></h3>
<p>Assign a function to the system variable <a href="https://code.kx.com/q/ref/dotz/#zph-http-get"><code>.z.ph</code></a> to be evaluated whenever a synchronous HTTP request is routed to the current q process ‚Äì a.k.a. ‚Äúprocess http.‚Äù See <a href="https://code.kx.com/q4m3/11_IO/#1171-http-connections">¬ß11.7.1</a> for a discussion.</p>
<p>To reset to the default setting, expunge the handler with <code>\x .z.ph</code>.</p>
<h3 id="13323-on-input-zpi">13.3.23 On Input <code>.z.pi</code></h3>
<p>Assign a function to the system variable <a href="https://code.kx.com/q/ref/dotz/#zpi-input"><code>.z.pi</code></a> to be evaluated when q echoes the result of user input to the console ‚Äì a.k.a. ‚Äúprocess input.‚Äù For example, the following mimics the console display of pre-2.4 q versions.</p>
<pre class="highlight"><code class="language-q">q).z.pi:{-1 .Q.s1 value x}</code></pre>
<p>To reset to the default behavior, expunge the handler with <code>\x .z.pi</code>.</p>
<h3 id="13324-http-options-method-zpm">13.3.24 HTTP Options method <code>.z.pm</code></h3>
<p>Assign a function to the system variable <a href="https://code.kx.com/q/ref/dotz/#zpm-http-options"><code>.z.pm</code></a> to receive HTTP OPTIONS as,</p>
<pre class="highlight"><code class="language-q">(`OPTIONS;requestText;requestHeaderDict)</code></pre>
<h3 id="13325-on-open-zpo">13.3.25 On Open <code>.z.po</code></h3>
<p>Assign a function to the system variable <a href="https://code.kx.com/q/ref/dotz/#zpo-open"><code>.z.po</code></a> to be evaluated after a connection to the current q process has been successfully opened ‚Äì a.k.a. ‚Äúprocess open.‚Äù See <a href="https://code.kx.com/q4m3/11_IO/#116-interprocess-communication">¬ß11.6</a> for a discussion. The local handle of the connecting process is passed in the second parameter.</p>
<p>To reset to the default setting, expunge the handler with <code>\x .z.po</code>.</p>
<h3 id="13326-on-http-post-zpp">13.3.26 On HTTP Post <code>.z.pp</code></h3>
<p>Assign a function to the system variable <a href="https://code.kx.com/q/ref/dotz/#zpp-http-post"><code>.z.pp</code></a> to be evaluated whenever an HTTP post is routed to the current q process ‚Äì a.k.a. ‚Äúprocess post.‚Äù See <a href="https://code.kx.com/q4m3/11_IO/#117-http-and-web-sockets">¬ß11.7</a> for a discussion of <code>.z.pg</code>, whose parameters are the same.</p>
<p>To reset the <code>.z.pp</code> to the default setting, expunge the handler with <code>\x .z.pp</code>.</p>
<h3 id="13327-on-set-zps">13.3.27 On Set <code>.z.ps</code></h3>
<p>Assign a function to the system variable <a href="https://code.kx.com/q/ref/dotz/#zps-set"><code>.z.ps</code></a> to be evaluated whenever a client process sends an asynchronous message to the current q process ‚Äì a.k.a. ‚Äúprocess set.‚Äù The name derives from the fact that an asynchronous call has set semantics. The parameter passed to your handler is the message content. The default behavior is to invoke <code>value</code>.</p>
<p>To reset the to the default setting, expunge the handler with <code>\x .z.ps</code>.</p>
<h3 id="13328-on-password-zpw">13.3.28 On Password <code>.z.pw</code></h3>
<p>Assign a function to the system variable <a href="https://code.kx.com/q/ref/dotz/#zpw-validate-user"><code>.z.pw</code></a> to be evaluated after the command line <a href="https://code.kx.com/q/basics/cmdline/#-u-usr-pwd-local"><code>‚Äìu</code></a> and <a href="https://code.kx.com/q/basics/cmdline/#-u-usr-pwd"><code>‚ÄìU</code></a> checks but before the <code>.z.po</code> handler ‚Äì a.k.a. ‚Äú<strong>p</strong>ass<strong>w</strong>ord.‚Äù This can be used to implement authorization ‚Äì i.e., who is allowed to do what. Your handler should accept two parameters: a symbolic user name and a password string. It should return a boolean pass/fail indicator.</p>
<p>To reset to the default setting, expunge the handler with <code>\x .z.pw</code>.</p>
<h3 id="13329-quiet-mode-zq">13.3.29 Quiet Mode <code>.z.q</code></h3>
<p>The system variable <a href="https://code.kx.com/q/ref/dotz/#zq-quiet-mode"><code>.z.q</code></a> is a read-only boolean indicating whether q was started in quiet mode using the <code>‚Äìq 1</code> command line parameter.</p>
<h3 id="13330-self-zs">13.3.30 Self <code>.z.s</code></h3>
<p>The system variable <a href="https://code.kx.com/q/ref/dotz/#zs-self"><code>.z.s</code></a> represents the current function during function evaluation. This can be useful when writing recursive functions but there is often a better way to do this using iterators. For example, here is a stack-eating recursive factorial.</p>
<pre class="highlight"><code class="language-q">q){$[x=1;x;x*.z.s x-1]} 10
3628800</code></pre>
<h3 id="13331-gmt-date-zt">13.3.31 GMT Date <code>.z.t</code></h3>
<p>The system variable <a href="https://code.kx.com/q/ref/dotz/#zt-zt-zd-zd-timedate-shortcuts"><code>.z.t</code></a> retrieves the time component of Greenwich Mean Time (GMT) and is equivalent to <code>`time$.z.p</code>.</p>
<h3 id="13332-local-date-zt">13.3.32 Local Date <code>.z.T</code></h3>
<p>The system variable <a href="https://code.kx.com/q/ref/dotz/#zt-zt-zd-zd-timedate-shortcuts"><code>.z.T</code></a> retrieves the local date component according to the time zone offset from GMT and is equivalent to <code>`time$.z.P</code>.</p>
<h3 id="13333-on-timer-zts">13.3.33 On Timer <code>.z.ts</code></h3>
<p>Assign a function to the system variable <a href="https://code.kx.com/q/ref/dotz/#zts-timer"><code>.z.ts</code></a> to be evaluated on every timer tick ‚Äì see <a href="#13118-set-timer-t">¬ß13.1.18</a> for the command <a href="https://code.kx.com/q/basics/syscmds/#t-timer"><code>\t</code></a> to start/stop the timer. For example, the following assigns a handler to display local time to the console, turns on the timer to fire (approximately) every two seconds and turns it off after a few ticks.</p>
<pre class="highlight"><code class="language-q">q).z.ts:{show .z.P}
q)\t 2000
q)2015.03.26D12:48:24.487145000
2015.03.26D12:48:26.488286000
2015.03.26D12:48:28.488237000
2015.03.26D12:48:30.488372000
q)2015.03.26D12:48:32.488206000
2015.03.26D12:48:34.488370000
\t 0
q)</code></pre>
<p>To restore the default behavior, expunge the handler with <code>\x .z.ts</code>.</p>
<h3 id="13334-user-zu">13.3.34 User <code>.z.u</code></h3>
<p>The system variable <a href="https://code.kx.com/q/ref/dotz/#zu-user-id"><code>.z.u</code></a> is a symbol that represents the user ID of the q session.</p>
<div class="admonition tip">
<p class="admonition-title">Inside the processing of a remote message on a server, <code>.z.u</code> represents the user ID of the remote session.</p>
</div>
<h3 id="13335-on-value-set-zvs">13.3.35 On Value Set <code>.z.vs</code></h3>
<p>Assign a function to the system variable <a href="https://code.kx.com/q/ref/dotz/#zvs-value-set"><code>.z.vs</code></a> to be evaluated <strong>after</strong> a global variable in the root context is set. The parameters for your handler are the symbolic name of the global being set and the subdomain of the assignment. For example, in a fresh q session,</p>
<pre class="highlight"><code class="language-q">q)a:42
q)m:(1 2; 3 4)
q).z.vs:{0N!(x;y;value x)}
q)a:43
(`a;();43)
q)m[0;0]:42
(`m;0 0;(42 2;3 4))</code></pre>
<p>To restore the default behavior, expunge the handler with <code>\x .z.vs</code>.</p>
<h3 id="13336-who-zw">13.3.36 Who <code>.z.w</code></h3>
<p>The system variable <a href="https://code.kx.com/q/ref/dotz/#zw-handle"><code>.z.w</code></a> represents the handle of ‚Äúwho‚Äù is in communication during the current remote call. At the console prompt, the value is <code>0i</code>, representing the interactive user. In the midst of processing a remote message, it is the (local) open handle associated with that remote client on this process.</p>
<h3 id="13337-handle-queues-zw">13.3.37 Handle Queues <code>.z.W</code></h3>
<p>The system variable <a href="https://code.kx.com/q/ref/dotz/#zw-handles"><code>.z.W</code></a> (note upper case) returns a list of dictionaries whose keys are open handles and whose values are lists of bytes in the corresponding output queue. See the <a href="https://code.kx.com/q/ref/dotz/#zw-handles">KX site</a> for more details.</p>
<h3 id="13338-on-websocket-close-zwc">13.3.38 On WebSocket Close <code>.z.wc</code></h3>
<p>Introduced in q3.3, the system variable <a href="https://code.kx.com/q/ref/dotz/#zwc-websocket-close"><code>.z.wc</code></a> can be assigned a handler that is called when a WebSocket connection is closed. Prior to q3.3 this was handled in <code>.z.pc</code>.</p>
<p>Your handler is executed immediately <strong>after</strong> a WebSocket connection has been closed. Since the connection has been closed by the time the handler is called, there are no valid remote values for <a href="https://code.kx.com/q/ref/dotz/#za-ip-address"><code>.z.a</code></a>, <a href="https://code.kx.com/q/ref/dotz/#zu-user-id"><code>.z.u</code></a> or <a href="https://code.kx.com/q/ref/dotz/#zw-handle"><code>.z.w</code></a>. Consequently the local values are returned.</p>
<div class="admonition tip">
<p class="admonition-title">This is useful to clean up things like a table of users keyed by handle, in which case you use the just-closed handle that is passed as a parameter to <code>.z.wc</code>.</p>
</div>
<h3 id="13339-on-websocket-open-zwo">13.3.39 On WebSocket Open <code>.z.wo</code></h3>
<p>Introduced in q3.3, the system variable <a href="https://code.kx.com/q/ref/dotz/#zwo-websocket-open"><code>.z.wo</code></a> can be assigned a handler that is called when a WebSocket connection is opened. Prior to q3.3 this was handled in <a href="https://code.kx.com/q/ref/dotz/#zpo-open"><code>.z.po</code></a>.</p>
<p>Your handler is executed just <strong>after</strong> a WebSocket connection to a kdb+ session has been initialized ‚Äì i.e., once it has been validated against a <a href="https://code.kx.com/q/basics/cmdline/#-u-usr-pwd-local"><code>-u</code></a>/<a href="https://code.kx.com/q/basics/cmdline/#-u-usr-pwd"><code>-U</code></a> file (if specified) and <a href="https://code.kx.com/q/ref/dotz/#zpw-validate-user"><code>.z.pw</code></a> checks. The argument is the just-opened handle.</p>
<div class="admonition tip">
<p class="admonition-title">This handler is typically used to build a dictionary of handles associated with session information such as <code>.z.a</code> or <code>.z.u</code>.</p>
</div>
<h3 id="13340-on-websocket-message-zws">13.3.40 On WebSocket Message <code>.z.ws</code></h3>
<p>Assign a function to the system variable <a href="https://code.kx.com/q/ref/dotz/#zws-websockets"><code>.z.ws</code></a> to be evaluated whenever a message arrives over a WebSocket. See <a href="https://code.kx.com/q4m3/11_IO/#117-http-and-web-sockets">¬ß11.7</a> for examples.</p>
<h3 id="13341-command-line-parameters-zx">13.3.41 Command-Line Parameters <code>.z.x</code></h3>
<p>The system variable <a href="https://code.kx.com/q/ref/dotz/#zx-argv"><code>.z.x</code></a> is a list of strings representing the command-line parameters provided after the name of the file or directory on the command-line invocation of the q process. For example, if q is invoked from the OS console with,</p>
<pre class="highlight"><code class="language-bash">q convertargs.q 42 forty 2.0</code></pre>
<p>we find,</p>
<pre class="highlight"><code class="language-q">q).z.f
`convertargs.q
q).z.x
("42";"forty";"2.0")</code></pre>
<h3 id="13342-raw-command-line-zx">13.3.42 Raw Command Line <code>.z.X</code></h3>
<p>The system variable <a href="https://code.kx.com/q/ref/dotz/#zx-raw-command-line"><code>.z.X</code></a> was introduced in q3.3. It is a string representing the unprocessed command line that invoked the q process, beginning with the invocation of q. For example,</p>
<pre class="highlight"><code class="language-bash">$rlwrap m32/q trade.q -p 12345 -u 1 -b -MyParam foo
KDB+ 3.3 2015.09.02 Copyright (C) 1993-2015 Kx Systems
...</code></pre>
<pre class="highlight"><code class="language-q">q).z.X
"m32/q"
"trade.q"
"-p"
"12345"
"-u"
,"1"
"-b"
"-MyParam"
"foo"
q).z.x
"-MyParam"
"foo"</code></pre>
<h3 id="13343-gmt-datetime-zz">13.3.43 GMT Datetime <code>.z.z</code></h3>
<p>The system variable <a href="https://code.kx.com/q/ref/dotz/#zz-utc-datetime"><code>.z.z</code></a> retrieves the GMT date component and is equivalent to <code>`datetime$.z.p</code>.</p>
<div class="admonition note">
<p class="admonition-title">This is deprecated in favor of <code>.z.p</code>.</p>
</div>
<h3 id="13344-local-datetime-zz">13.3.44 Local Datetime <code>.z.Z</code></h3>
<p>The system variable <a href="https://code.kx.com/q/ref/dotz/#zz-local-datetime"><code>.z.Z</code></a> retrieves the local date component according to the timezone offset from GMT and is equivalent to <code>`datetime$.z.P</code>.</p>
<div class="admonition note">
<p class="admonition-title">This is deprecated in favor of <code>.z.P</code>.</p>
</div>
<h3 id="13345-zip-defaults-zzd">13.3.45 Zip Defaults <code>.z.zd</code></h3>
<p>The system variable <a href="https://code.kx.com/q/ref/dotz/#zzd-zip-defaults"><code>.z.zd</code></a> displays or sets a list of parameters for data compression: logical block size, compression algorithm and compression level. For example, the following are reasonable settings.</p>
<pre class="highlight"><code class="language-q">q).z.zd:17 2 6</code></pre>
<p>See <a href="https://code.kx.com/q/kb/file-compression/">the KX site</a> for more details on the implementation of data compression.</p>
                


                
              
              
                


              
            </article>
            
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))for(var set of document.querySelectorAll("[data-tabs]")){var labels=set.querySelectorAll(":scope > label");e:for(var tab of tabs)for(var label of labels)if(label.innerText.trim()===tab){var input=label.previousElementSibling;input.checked=!0;break e}}</script>

          </div>
        </div>
        
          
        
      
                </div>
            </section>
        
            <section class="chapter" id="chapter-6">
                <div class="chapter-header">
                    <h1 class="chapter-title">14. Introduction to Kdb+¬∂</h1>
                    <div class="chapter-meta">
                        <span>üìñ Source: <a href="https://code.kx.com/q4m3/14_Introduction_to_Kdb%2B/">https://code.kx.com/q4m3/14_Introduction_to_Kdb%2B/</a></span>
                        <span>üìù 17492 words</span>
                        
                    </div>
                </div>
                <div class="chapter-content">
                    
        <div class="md-main__inner md-grid">
          
            
              
              
            
            
              
              
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                
                <h1 id="14-introduction-to-kdb">14. Introduction to Kdb+</h1>
<h2 id="140-overview">14.0 Overview</h2>
<p>In this chapter we provide an introduction to kdb+, which is the database offering from KX. Roughly speaking, kdb+ is what happens when q tables are persisted and then mapped back into memory for operations. Of course, things are more complicated than that.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Many examples in this chapter use directories that are parented directly to the root. This is done for pedagogical reasons and also to make paths short enough to fit on a page without wrapping. Unless you are creating kdb+ databases on a machine over which you have complete control, you will <strong>not</strong> be able to create directories in the root. When emulating the examples here, you should change the paths to relative paths that live under a directory that you control. You can usually do this by removing the leading <code>/</code> in the path.</p>
</div>
<h2 id="141-tables-in-memory-and-serialization">14.1 Tables in Memory and Serialization</h2>
<p>It is possible to maintain a table entirely in memory, provided you have enough physical memory to hold it. There is one problem with this from a database perspective:</p>
<ul>
<li>An in-memory table is ephemeral ‚Äì meaning that all modifications are lost if the q process dies.</li>
</ul>
<p>One solution is to serialize the table to persistent storage using <a href="https://code.kx.com/q/ref/set/"><code>set</code></a> or similar mechanisms. In this section we recapitulate material from previous chapters from this perspective.</p>
<h3 id="1411-tables-and-keyed-tables">14.1.1 Tables and Keyed Tables</h3>
<p>A table is the <a href="https://code.kx.com/q/ref/flip/"><code>flip</code></a> of a column dictionary, in which address slots are reversed but no data is moved during the transpose. For example, here is a table with two simple list columns.</p>
<pre class="highlight"><code class="language-q">q)flip `s`v!(`a`b`c;100 200 300)
_</code></pre>
<p>Table definition syntax permits tables to be defined in more readable format.</p>
<pre class="highlight"><code class="language-q">q)([] s:`a`b`c; v:100 200 300)
_</code></pre>
<p>The schema of a table has the same form but with empty columns ‚Äì i.e., no rows.</p>
<pre class="highlight"><code class="language-q">q)([] s:`symbol$(); v:`int$())
_
q)t:([] s:`a`b; v:10 20)
_</code></pre>
<p>It is good practice to prototype the empty lists in a schema; unfortunately, this is not possible if the corresponding columns are not simple lists.</p>
<p>The <a href="https://code.kx.com/q/basics/datatypes/">type</a> of any table is <code>98h</code> and the function <a href="https://code.kx.com/q/ref/meta/"><code>meta</code></a> summarizes the column names, types and attributes in a result keyed table.</p>
<pre class="highlight"><code class="language-q">q)meta ([] s:`symbol$(); v:`int$())
_</code></pre>
<p>A keyed table is a dictionary that establishes positional correspondence between a table of (presumably unique) keys and a table of values.</p>
<pre class="highlight"><code class="language-q">q)([] id:1001 1002 1003)!([] s:`a`b`c; v:100 200 300)
id | s v
----| -----
1001| a 100
1002| b 200
1003| c 300</code></pre>
<p>Table definition syntax is more compact.</p>
<pre class="highlight"><code class="language-q">q)([id:1001 1002 1003] s:`a`b`c; v:100 200 300)
_</code></pre>
<p>The type of any keyed table is <code>99h</code>, since it is a dictionary and <code>meta</code> applies exactly as with tables.</p>
<h3 id="1412-foreign-keys-and-link-columns">14.1.2 Foreign Keys and Link Columns</h3>
<p>A foreign key is one or more table columns that are enumerated over the key component of a keyed table. For example, the column ID in the table below is a foreign key over <code>kt</code>. Note that the foreign-key column is identified by the name of its target table in the result of <code>meta</code>.</p>
<pre class="highlight"><code class="language-q">q)kt:([id:1001 1002 1003] s:`a`b`c; v:100 200 300)
q)t:([]; id:`kt$1002 1001 1003 1001; q:100 101 102 103)
q)meta t
c | t f a
--| ------
id| j kt
q | j</code></pre>
<p>A query on a table having a foreign key can access columns in the keyed table via dot notation.</p>
<pre class="highlight"><code class="language-q">q)select id.v, q from t
v q
-------
200 100
100 101
300 102
100 103</code></pre>
<p>A link column is similar to a foreign key, in that its entries are indices of rows in a table, but you must perform the lookup manually. The advantages of link columns are:</p>
<ul>
<li>The target can be a table or keyed table.</li>
<li>The target can be the table containing the link column.</li>
<li>Link columns can be splayed or partitioned, whereas foreign keys cannot.</li>
</ul>
<p>Here is the previous foreign-key example redone with a link column against a table.</p>
<pre class="highlight"><code class="language-q">q)tk:([] id:1001 1002 100; s:`a`b`c; v:100 200 300)
q)t:([]; id:`tk!(exec id from tk)?1002 1001 1003 1001; q:100 101 102 103)
q)meta t
c | t f a
--| ------
id| i tk
q | j</code></pre>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>As of this writing (Sep 2015) integers are 64-bit in q3+, enumerations are 32-bit. In particular, the integers stored in a link column are truncated to 32 bits by the <code>!</code> operator. Observe that type of the link column ID in the previous example is <code>I</code> even though the result of the <code>?</code> operation is of type <code>j</code>. One consequence is that you cannot use links columns with tables of more than 2<sup>32</sup> records.</p>
</div>
<p>Here is an example that uses a link column to implement a hierarchical structure in a table. The column <code>pid</code> is a link column that relates a row to its parent row.</p>
<pre class="highlight"><code class="language-q">q)tree:([] id:0 1 2 3 4; pid:`tree!0N 0 0 1 1; v:100 200 300 400 500)
q)select from tree where pid=0 / find children of root
_</code></pre>
<h3 id="1413-serializing-tables">14.1.3 Serializing Tables</h3>
<p>It is possible to persist any table (or keyed table) using the general q serialization/deserialization capability of <code>set</code> and <code>get</code>. There is no restriction on table or column types.</p>
<pre class="highlight"><code class="language-q">q)`:/data/t set ([] s:`a`b`c; v:100 200 300)
`:/data/t
q)\\
&gt;q
q)t:get `:/data/t
q)t
_</code></pre>
<p>You can serialize foreign keys and link columns and bring them back into memory.</p>
<pre class="highlight"><code class="language-q">q)kt:([id:1001 1002 1003] s:`a`b`c; v:100 200 300)
q)tk:([] id:1001 1002 100; s:`a`b`c; v:100 200 300)
q)`:/data/kt set kt
`:/data/kt
q)`:/data/tk set tk
`:/data/tk
q)`:/data/t1 set ([]; id:`kt$1002 1001 1003 1001; q:100 101 102 103)
`:/data/t1
q)`:/data/t2 set ([]; id:`kt!(exec id from tk)?1002 1001 1003 1001; q:100 101 102 103)
`:/data/t2
q)\\
&gt;q
q)kt:get `:/data/kt
q)tk:get `:/data/tk
q)t1:get `:/data/t1
q)t2:get `:/data/t2</code></pre>
<h3 id="1414-operating-on-serialized-tables">14.1.4 Operating on Serialized Tables</h3>
<p>You operate on a serialized table by loading it into memory with <a href="https://code.kx.com/q/ref/get/"><code>get</code></a> or <a href="https://code.kx.com/q/basics/syscmds/#l-load-file-or-directory"><code>\l</code></a>.</p>
<pre class="highlight"><code class="language-q">q)`:/data/t set ([] s:`a`b`c; v:100 200 300)
`:/data/t
q)\l /data/t
`t
q)select from t
_
q)t1: get `:/data/t
q)select from t1
_</code></pre>
<p>Alternatively, you can perform a query on a serialized table by specifying its file handle as the table name.</p>
<pre class="highlight"><code class="language-q">q)`:/data/t set ([] s:`a`b`c; v:100 200 300)
`:/data/t
q)select from `:/data/t where s in `a`c
s v
-----
a 100
c 300
q)`:/data/t upsert (`x;42)
`:/data/t
q).[`:/data/t;();,;([] s:`y`z; v:400 500)]
`:/data/t
q)select from `:/data/t where s in `x`y`z
_</code></pre>
<p>Similar operations are available on keyed tables.</p>
<pre class="highlight"><code class="language-q">q)`:/data/kt set ([k:`a`b`c] v:10 20 30)
`:/data/kt
q)`:/data/kt upsert (`b;200)
`:/data/kt
q)`:/data/kt upsert (`x;42)
`:/data/kt
q)select from `:/data/kt
k| v
-| ---
a| 10
b| 200
c| 30
x| 42</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The limitation to using a serialized table or keyed table is that, behind the scenes, the operations load it into memory and write it back out. Amongst other things, this means that anyone wanting to work with it must be able to fit it into memory in its entirety.</p>
</div>
<h3 id="1415-the-database-view">14.1.5 The Database View</h3>
<p>Persisting a table via serialization creates a single file in the OS file system. Let‚Äôs raise our perspective to the 50,000-foot level. From this height, we see the table as a single point.</p>
<p><strong>Big Picture (0):</strong> We think of a serialized table as a zero-dimensional persisted form since it is stored in a single file and is not decomposed.</p>
<table>
<thead>
<tr>
<th></th>
<th>file</th>
</tr>
</thead>
<tbody>
<tr>
<td>table</td>
<td>‚ñ™</td>
</tr>
</tbody>
</table>
<p>Here the ‚ñ™ represents the contents of the table as an opaque entity. This contrasts with higher-dimensional forms we shall encounter later.</p>
<h2 id="142-splayed-tables">14.2 Splayed Tables</h2>
<p>In the previous section, we saw that it is possible to persist tables using serialization. From a database perspective there are (at least) two issues with operating on serialized tables due to the fact that the entire table is loaded into memory.</p>
<ul>
<li>The entire table must fit into memory on each user‚Äôs machine.</li>
<li>Operations against the persisted table will be slow due to reloading the entire table each time.</li>
</ul>
<h3 id="1420-splaying-a-table">14.2.0 Splaying a Table</h3>
<p>When a table is too large to fit into memory as a single entity, we can persist its components into a directory. This is called <a href="https://code.kx.com/q/kb/splayed-tables/"><em>splaying</em> the table</a> because the table is pulled apart into its constituent columns (it is an interesting exercise to look up the derivation of this word in English). Splaying solves the memory/reload issue because a splayed table is mapped into memory; columns are loaded on demand then memory is released when no longer needed. Tables with many columns especially benefit from splaying since most queries refer to only a handful of columns and only those columns will actually be loaded.</p>
<p>A splayed table corresponds to a directory whose name <strong>is</strong> the table name. Each column list of the table is serialized into a file whose name <strong>is</strong> the column name.</p>
<div class="admonition tip">
<p class="admonition-title">You don‚Äôt have any choice in the names.</p>
</div>
<p>A list of the symbolic column names is serialized to the hidden file <code>.d</code>in the directory to record column order. This is the <strong>only</strong> metadata stored by kdb+; all other metadata is read from directory and file names.</p>
<p>Customarily the splayed directory is created one level down from a directory that serves as the root of the database.</p>
<pre class="highlight"><code class="language-q">/root
/tablename &lt;- splayed table directory
.d &lt;- file with column names
column1name &lt;- column data file
column2name &lt;- column data file
‚Ä¶</code></pre>
<p>From the 50,000-foot level, we see the following on the file system.</p>
<p><strong>Big Picture (1):</strong> We think of a splayed table as a persisted form that is cut vertically along columns.</p>
<table>
<thead>
<tr>
<th></th>
<th>column1</th>
<th>column2</th>
<th>column3</th>
<th>‚Ä¶</th>
</tr>
</thead>
<tbody>
<tr>
<td>table</td>
<td>‚ñ™</td>
<td>‚ñ™</td>
<td>‚ñ™</td>
<td>‚Ä¶</td>
</tr>
</tbody>
</table>
<p>Geometrically, the persisted table is 1-dimensional ‚Äì there is a point for each column in the persisted image of the table.</p>
<h3 id="1421-creating-splayed-tables">14.2.1 Creating Splayed Tables</h3>
<p>We start with a very simple example of creating a splayed table. Make sure you include the trailing <code>/</code> in the file handle; otherwise, you will serialize the table into a single file.</p>
<pre class="highlight"><code class="language-q">q)`:/db/t/ set ([] v1:10 20 30; v2:1.1 2.2 3.3)
`:/data/t/
q)\ls -a /db/t
,"."
".."
".d"
"v1"
"v2"</code></pre>
<p>It is also possible to create a splayed table with <a href="https://code.kx.com/q/ref/upsert/"><code>upsert</code></a>, or with the equivalent generalized application, using the file handle as the table name. When the file does not exist, these act like <a href="https://code.kx.com/q/ref/set/"><code>set</code></a>.</p>
<pre class="highlight"><code class="language-q">q)`:/db/t2/ upsert ([] v1:10 20 30; v2:1.1 2.2 3.3)
_
q).[`:/db/t3/; (); ,; ([] v1:10 20 30; v2:1.1 2.2 3.3)]
_</code></pre>
<p>Reading the constituents of the splayed directory with <a href="https://code.kx.com/q/ref/get/"><code>get</code></a> demonstrates that they are simply serialized q entities.</p>
<pre class="highlight"><code class="language-q">q)get `:/db/t/v1
10 20 30
q)get `:/db/t/v2
_
q)get `:/db/t/.d
`v1`v2</code></pre>
<p>Of course, if your notion of fashion is a hair shirt, you can splay your table manually. In a fresh <code>/db</code> directory,</p>
<pre class="highlight"><code class="language-q">q)t:([] v1:10 20 30; v2:1.1 2.2 3.3)
q)cs:cols t
q){[cname] (hsym `$"/db/t",string cname) set t cname} each cs
_
q)`:/db/t/.d set cs
_</code></pre>
<p>There are serious restrictions on what can be splayed.</p>
<ol>
<li>
<p>Tables can be splayed. Keyed tables <strong>cannot</strong>.</p>
<p>This might seem to preclude relational capabilities since it eliminates persisting a foreign key relation. But the day is saved by link columns, which can be persisted. See <a href="#1412-foreign-keys-and-link-columns">¬ß14.1.2</a>.</p>
</li>
<li>
<p>Only columns that are simple lists or compound lists can be splayed. By <em>compound</em> list we mean a list of simple lists of uniform type.</p>
<p>The isn‚Äôt too limiting in practice since data often comes in a uniform format that can be readily put into simple or compound lists. Incidentally, the reason for this restriction is that working with mapped general lists would be much slower than working with simple or compound lists, especially for very large data sets. See <a href="#1424-basic-operations-on-splayed-tables">¬ß14.2.4</a> for more on nested columns.</p>
</li>
<li>
<p>All symbol columns must be enumerated.</p>
<p>This restriction might seem to complicate life but there are conventions and utilities that eliminate most of the pain. See <a href="#1422-splayed-tables-with-symbol-columns">¬ß14.2.2</a>. </p>
</li>
</ol>
<h3 id="1422-splayed-tables-with-symbol-columns">14.2.2 Splayed Tables with Symbol Columns</h3>
<p>The convention for symbol columns in splayed (and partitioned) tables is that <strong>all</strong> symbol columns in <strong>all</strong> tables are enumerated over the list sym, which is serialized into the root directory.</p>
<p>The author prefers to use a projected form of the utility <a href="https://code.kx.com/q/ref/dotq/#qen-enumerate-varchar-cols"><code>.Q.en</code></a> for enumerating symbols. Its first parameter is the file handle of the root directory (the location of the sym file) and its second parameter is the table whose symbol columns you wish enumerated. Here is a simple example.</p>
<pre class="highlight"><code class="language-q">q)`:/db/t/ set .Q.en[`:/db;] ([] s1:`a`b`c; v:10 20 30; s2:`x`y`z)
`:/db/t/
q)\ls /db
"sym"
,"t"
q}\\
&gt;q
q)\l /db
q)sym
`a`b`c`x`y`z
q)select from t
_</code></pre>
<p>We offer several observations on the action of <code>.Q.en</code> in this example.</p>
<ul>
<li>If there is a sym list in memory, it is overwritten</li>
<li>If there is a sym list on disk it is locked and then loaded into memory</li>
<li>If no sym list exists in memory or on disk an empty one is created.</li>
<li>All symbols in all symbol columns of the table are conditionally enumerated over the sym list in memory.</li>
<li>Once the enumeration is complete the sym list in memory is serialized to the root and the file is unlocked.</li>
</ul>
<p>Once again, you could don your hair shirt and do symbol enumeration manually.</p>
<pre class="highlight"><code class="language-q">q)t:([] s1:`a`b`c; v:10 20 30; s2:`x`y`z)
q)sym:()
q)`:/db/t/ set @[t;exec c from meta t where "s"=t;`sym?]
_
q)sym
_
\\
&gt;q
q)\l /db
q)select from t
_</code></pre>
<h3 id="1423-splayed-tables-with-nested-columns">14.2.3 Splayed Tables with Nested Columns</h3>
<p>The only nested columns that can be splayed are what we call <em>compound</em> lists ‚Äì i.e., lists of simple lists of uniform type. The most common example is a list of strings, which is a list of lists of char. A compound column is indicated by an upper case letter in the result of <code>meta</code>. For example, here is a table having two compound columns, which can be splayed in a fresh directory <code>/db</code>.</p>
<pre class="highlight"><code class="language-q">q)meta ([] ci:(1 2 3; enlist 4; 5 6); cstr:("abc";enlist"d";"ef"))
c   | t f a
----| -----
x   | J
cstr| C
q)`:/db/tcomp2/ set ([] ci:(1 2 3; enlist 4; 5 6); cstr:("abc";enlist"d";"ef"))
_</code></pre>
<p>By contrast, the following table cannot be splayed and results in an error.</p>
<pre class="highlight"><code class="language-q">q)meta ([] c:(1;1,1;`1))
c| t f a
-| -----
c|
q)`:/db/tcomp2/ set ([] c:(1;1,1;`1))
k){$[@x;.[x;();:;y];-19!((,y),x)]}
'type
q.q))</code></pre>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>You might reasonably think that you can use the result of <code>meta</code> to determine whether your table can be splayed by checking for a blank in the <code>t</code> column. You would be wrong since <code>meta</code> only examines the initial item of a column list and improperly reports some mixed columns as compound.</p>
</div>
<pre class="highlight"><code class="language-q">q)meta ([] c:(1 2 3 ;1,1;`1))
c| t f a
-| -----
c| J
q)`:/db/tbad/ set ([] c:(1 2 3 ;1,1;`1))
k){$[@x;.[x;();:;y];-19!((,y),x)]}
'type
q.q))</code></pre>
<p>The following function will tell you which columns of a table cannot be splayed.</p>
<pre class="highlight"><code class="language-q">{where {(ts~1#0h)|1&lt;count ts:distinct `type each`x} each flip x}</code></pre>
<p>When you splay a table with compound columns, q creates not one but two files for each compound column. For example, in a fresh directory <code>/db</code>, we splay a table with a single string column and then inspect the splayed directory.</p>
<pre class="highlight"><code class="language-q">q)`:/db/tstr/ set ([] c:("abc";enlist "d";"ef"))
_
q)system "ls -a /db/tstr"
,"."
".."
".d"
,"c"
"c#"</code></pre>
<p>Observe that there are two files associated with the compound column  ‚Äì namely, <code>c</code> and <code>c#</code>. If you examine these files you will discover that the ‚Äúsharp‚Äù file contains the binary data of the original list in flattened form and the non-sharp file is a serialized q list of integers representing the lengths of each sublist of the original list.</p>
<pre class="highlight"><code class="language-q">q)"c"$read1 hsym `$"/db/tstr/c#"
"abcdef"
q)read1 hsym `$"/db/tstr/c"
0xfe205700000000000300000000000000030000000000000004000000000000000600000000000000</code></pre>
<p>Interestingly, <code>get</code> reconstitutes the list from the non-sharp file.</p>
<pre class="highlight"><code class="language-q">q)get hsym `$"/db/tstr/c"
"abc"
,"d"
"ef"</code></pre>
<p>The purpose of writing compound columns as two files is to speed up operations against them when the splayed table is mapped into memory. Of course, the processing won‚Äôt be as fast as for a simple column, but it is still plenty fast for most purposes.</p>
<p>One question that always arises when designing a kdb+ database is whether to store text data as symbols or strings. The advantage of symbols is that they have atomic semantics and, since they are integers under the covers once they are enumerated, processing is quite fast. The main issue with symbols is that if you make all text into symbols, your sym list gets enormous and the advantages of enumeration disappear.</p>
<p>In contrast, strings do not pollute the sym list with one-off instances and are reasonably fast. The disadvantage is that they are not first class and you must revert to teenage years by using <code>like</code> to match them.</p>
<div class="admonition recommendation">
<p class="admonition-title">Recommendation</p>
<p>Only make text columns into symbols when the fields will be drawn from a small, reasonably stable domain and there is significant repetition in their use. When in doubt, start with a string column. It is much easier to convert a string column to symbols that it is to remove symbols from the sym list.</p>
</div>
<p>A text column that is drawn from a fixed list or a lookup table is an ideal candidate. So are invariant keys, provided the key domain is small and will not grow unreasonably. On the other hand, fields such as comments or notes should always be strings.</p>
<h3 id="1424-basic-operations-on-splayed-tables">14.2.4 Basic Operations on Splayed Tables</h3>
<p>Let us create a splayed table in a fresh <code>/db</code>.</p>
<pre class="highlight"><code class="language-q">q)`:/db/t/ set .Q.en[`:/db;] ([] s1:`a`b`c; v:10 20 30; s2:`x`y`z)
_</code></pre>
<p>To operate on a splayed table you can map it into memory in one of two ways.</p>
<div class="admonition tip">
<p class="admonition-title">Note the lack of a trailing <code>/</code> in both techniques of mapping the table below.</p>
</div>
<p>You can specify a splayed table on the q startup command immediately after the q executable.</p>
<pre class="highlight"><code class="language-bash">$q /db/t</code></pre>
<pre class="highlight"><code class="language-q">q)select from t
_</code></pre>
<p>Alternatively, you can use <a href="https://code.kx.com/q/basics/syscmds/#l-load-file-or-directory"><code>\l</code></a> to map the table.</p>
<div class="admonition tip">
<p class="admonition-title">Confusingly, folks say they are ‚Äúloading‚Äù the table, even though none of the table data is actually brought into memory in this step.</p>
</div>
<pre class="highlight"><code class="language-q">q)\l /db/t
`t
q)select from t
_</code></pre>
<p>The illusion that the table is actually in memory after it is mapped is convincing. Many fundamental table operations work on splayed tables.</p>
<pre class="highlight"><code class="language-q">q)\a
,`t
q)meta t
c | t f a
--| -----
s1| s
v | j
s2| s
q)cols t
`s1`v`s2
q)type t
98h
q)count t
3</code></pre>
<p>You can index records.</p>
<pre class="highlight"><code class="language-q">q)t[0]
s1| `sym$`a
v | 10
s2| `sym$`x</code></pre>
<p>You <strong>cannot</strong> use dot notation to extract columns from a splayed table but you <strong>can</strong> extract a column with symbol indexing.</p>
<pre class="highlight"><code class="language-q">q)t.s1
'type
q)t `s1
`sym$`a`b`c</code></pre>
<p>You can use both <a href="https://code.kx.com/q/ref/select/"><code>select</code></a> and <a href="https://code.kx.com/q/ref/exec/"><code>exec</code></a> templates on a splayed table.</p>
<pre class="highlight"><code class="language-q">q)select v from t where s1=`c
_
q)exec s1 from t
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>This contrasts with partitioned tables where you can only use <code>select</code>.</p>
</div>
<h3 id="1425-operations-on-a-splayed-directory">14.2.5 Operations on a Splayed Directory</h3>
<p>As of this writing (Sep 2015), the table operations available against the file handle of a splayed table are: <a href="https://code.kx.com/q/ref/select/"><code>select</code></a>, <a href="https://code.kx.com/q/ref/exec/"><code>exec</code></a>, <a href="https://code.kx.com/q/ref/upsert/"><code>upsert</code></a>, <a href="https://code.kx.com/q/ref/xasc/"><code>xasc</code></a>, <code>`<em>attr</em>#</code> (<a href="https://code.kx.com/q/ref/set-attribute/" title="Set Attribute">apply an attribute</a>).</p>
<p>With <code>t</code> splayed as above,</p>
<pre class="highlight"><code class="language-q">q)select from `:/db/t
_
q)exec v from `:/db/t
_
q)`v xdesc `:/db/t
_
q)@[`:/db/t;`s1;`p#]
_
q)\l /db
q)meta t
_</code></pre>
<p>We point out a source of confusion to qbies. Specifically, the behavior of <a href="https://code.kx.com/q/ref/update/"><code>update</code></a> on a splayed table that has been mapped into memory. Starting with a fresh directory <code>/db</code>, create a splayed table, map it into memory and then update it.</p>
<pre class="highlight"><code class="language-q">q)`:/db/t/ set .Q.en[`:/db;] ([] s1:`a`b`c; v:10 20 30; s2:`x`y`z)
_
q)\l /db
q)update v:300 from `t where s1=`c
`t
q)select from t
s1 v s2
---------
a 10 x
b 20 y
c 300 z</code></pre>
<p>But a rude surprise awaits when we remap the table.</p>
<pre class="highlight"><code class="language-q">q)\l /db
q)select from t
s1 v  s2
--------
a  10 x
b  20 y
c  30 z</code></pre>
<div class="admonition note">
<p class="admonition-title">Updates applied to a mapped table are only visible in the workspace and are not reflected on disk. There may be scenarios where this is useful but we advise avoiding it.</p>
</div>
<p>And now we arrive at a fundamental limitation of kdb+.</p>
<div class="admonition important">
<p class="admonition-title">Really Important</p>
<p>It is not possible to use built-in operations to update data in persisted splayed tables.</p>
</div>
<p>You read that correctly. Kdb+ is intended to store data that is not updated or deleted once it has been written. We shall see in the next section how to append to a splayed table, which makes it possible to process updates and deletes in a bitemporal fashion, but this capability is not available out of the box.</p>
<h3 id="1426-appending-to-a-splayed-table">14.2.6 Appending to a Splayed Table</h3>
<p>Since <code>upsert</code> acts as <a href="https://code.kx.com/q/ref/insert/"><code>insert</code></a> on regular (non-keyed) tables and only non-keyed tables can be splayed, we use <code>upsert</code> with the splayed directory name in order to append records to a splayed table on disk. This is a good thing, since <code>insert</code> doesn‚Äôt work on splayed tables. Also, because symbol columns must be enumerated for splayed tables, it is best to make rows into tables.</p>
<p>In a fresh <code>/db</code>,</p>
<pre class="highlight"><code class="language-q">q)`:/db/t/ set .Q.en[`:/db;] ([] s1:`a`b`c; v:10 20 30; s2:`x`y`z)
_
q)`:/db/t/ upsert .Q.en[`:/db;] ([] s1:`d`e; v:40 50; s2:`u`v)
_
q)`:/db/t upsert .Q.en[`:/db;] enlist `s1`v`s2!(`f;60;`t)
_
q)`:/db/t upsert .Q.en[`:/db;] flip `s1`v`s2!flip ((`g;70;`r);(`h;80;`s))
_
q)\l / db
q)select from t
_</code></pre>
<p>You can use <code>upsert</code> in this fashion to build large splayed tables incrementally. The following example can be enhanced to create a splayed table step-by-step as batches of new records arrive. In a fresh <code>/db</code>,</p>
<pre class="highlight"><code class="language-q">q)batch:{[rt;tn;recs] hsym[`$rt,"/",tn,"/"] upsert .Q.en[hsym `$rt;] recs}
q)dayrecs:{([] dt:x; ti:asc 100?24:00:00; sym:100?`ibm`aapl; qty:100*1+100?1000)}
q)appday:batch["/db";"t";]
q)appday dayrecs 2015.01.01
_
q)appday dayrecs 2015.01.02
_
q)appday dayrecs 2015.01.03
_
q)\l /db
q)select from t
_</code></pre>
<h3 id="1427-manual-operations-on-a-splayed-directory">14.2.7 Manual Operations on a Splayed Directory</h3>
<p>Although there are no built-in operations to update splayed tables on disk, you can perform such operations by manipulating the serialized files.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The examples shown here should be used with caution, as none of the operations are atomic; they are simply file-system manipulation. Even read-only users could see inconsistent data, so things are best done when no other users are accessing the database.</p>
</div>
<p>Here is an example of how to simulate an <code>update .. where</code> on a single column. In a fresh <code>/db</code>,</p>
<pre class="highlight"><code class="language-q">q)`:/db/t/ set ([] ti:09:30:00 09:31:00; p:101.5 33.5)
_
q)`:/db/t/p set .[get `:/db/t/p; where 09:31:00=get `:/db/t/ti; :;42.0]
_
q)\l /db/t
_
q)select from t
_</code></pre>
<p>To add a new column of nulls to an existing splayed table, we first get the row count from any column file. Then we revise the <code>.d</code> file with the new column name. This example is easily modified to place arbitrary data in the new column.</p>
<pre class="highlight"><code class="language-q">q)`:/db/t/s set (count get `:/db/t/ti)#`
_
q)`:/db/t/.d set get[`:/db/t/.d] union `s
_</code></pre>
<p>To delete a column, remove its file and revise the <code>.d</code> file to reflect its absence.</p>
<pre class="highlight"><code class="language-q">q)system "rm /db/t/s"
q)`:/db/t/.d set get[`:/db/t/.d] except `s
_
q)\l /db
q)select from t
_</code></pre>
<p>While you can sort a splayed table on disk, suppose you want to implement your own custom sort. We show how to create the standard sort. First create the appropriate sort index with <a href="https://code.kx.com/q/ref/iasc/"><code>iasc</code></a> or <a href="https://code.kx.com/q/ref/idesc/"><code>idesc</code></a> and then use this to re-index all the column files. Here we perform a descending sort by the <code>ti</code> column.</p>
<pre class="highlight"><code class="language-q">q)cs:system "ls /db/t"
q)I:idesc `:/db/t/ti
q){pth set get[pth:hsym `$"/db/t/",x] I} each cs
`:/db/t/ix`:/db/t/p`:/db/t/ti
q)\l /db
q)select from t
_</code></pre>
<h3 id="1428-working-with-sym-files">14.2.8 Working with sym Files</h3>
<p>On occasion you may need to perform operations involving the sym files. For example, you may want to move a table from one database to another. Or you may find that your sym domain has become polluted due to symbol columns that should have been strings. Or you may have unwisely chosen to have many different enumeration domains and you wish to consolidate them into one. All these situations can be resolved by careful operations on the sym file(s).</p>
<div class="admonition tip">
<p class="admonition-title">Updating sym files is delicate and should be done with great care, only after you have made a complete backup of the root directory. Corrupting the sym file will almost certainly render your database useless.</p>
</div>
<p>In our first example we show how to merge a table from one database into another. Suppose we have root directories <code>/db1</code> and <code>/db2</code>, both with the standard sym file in the root and with splayed tables <code>t1</code> and <code>t2</code>, respectively. In fresh directories <code>/db1</code> and <code>/db2</code>,</p>
<pre class="highlight"><code class="language-q">q)`:/db1/t1/ set .Q.en[`:/db1;] ([] s:`a`b`c; v:10 20 30)
_
q)`:/db2/t2/ set .Q.en[`:/db2;] ([] s:`c`d`e; v:300 400 500)
_
q)get `:/db1/sym
`a`b`c
q)get `:/db2/sym
`c`d`e</code></pre>
<p>In order to copy table <code>t2</code> to the <code>/db1</code> root, we un-enumerate all its symbol columns and then re-enumerate them in the target database.</p>
<pre class="highlight"><code class="language-q">q)symcols2:exec c from meta `:/db2/t2 where t="s"
q)t2noenum:@[select from `:/db2/t2;symcols2;value]
q)`:/db1/t2/ set .Q.en[`:/db1] t2noenum
_
q)get `:/db1/sym
`a`b`c`d`e</code></pre>
<p>In another example, suppose that we mistakenly made a comment column into symbols instead of strings, with the result being a pollution of the sym domain with many single-use items. In a fresh <code>/db</code>, we save <code>t1</code> with a valid symbol column and then screw up on the comment field in <code>t2</code>.</p>
<pre class="highlight"><code class="language-q">q)`:/db/t1/ set .Q.en[`:/db;] ([] s:`a`b`c; v:10 20 30)
_
q)`:/db/t2/ set .Q.en[`:/db;] ([] c:1 2 3; comment:`$("abc";"de";"fg"))
_
q)get `:/db/sym
`a`b`c`abc`de`fg</code></pre>
<p>First we load the database and remove the offending comments from the sym list.</p>
<pre class="highlight"><code class="language-q">q)\l /db
q)sym:sym except exec comment from t2
q)sym
_</code></pre>
<p>Next we re-enumerate the re-typed culprit table over the clean sym list and re-splay it. Note that we use (<code>`sym?</code>) for the enumeration since it is possible that some of the comments actually overlapped with symbols from other tables.</p>
<pre class="highlight"><code class="language-q">q)reenum:{@[x;exec c from meta x where t="s";`sym?]}
q)`:/db/t2/ set reenum ([] s:`a`b`c; comment:("abc";"de";"fg"))</code></pre>
<p>Next we un-enumerate, re-enumerate and re-splay the remaining tables.</p>
<pre class="highlight"><code class="language-q">q)ts:system["a"] except `t2
q)unenum:{@[select from x; exec c from meta x where t="s";value]}
q){(hsym `$"/db/",string[x],"/") set reenum unenum x} each ts
_</code></pre>
<p>Finally we overwrite the sym file with the correct sym list that is now in memory and reload the database to check our handiwork.</p>
<pre class="highlight"><code class="language-q">q)`:/db/sym set sym
q)\l /db
q)meta t1
_
q)meta t2
_</code></pre>
<h3 id="1429-splayed-tables-with-link-columns">14.2.9 Splayed Tables with Link Columns</h3>
<p>We previously pointed out that you cannot splay a keyed table, and therefore cannot have a foreign-key relation between splayed tables. However, you can splay a link column and then use dot notation just as you would with a foreign key. You must do the work of creating the index yourself, just as with link columns with tables in memory.</p>
<p>In our first example, we create the link at the same time as we splay the tables. This is the same as creating the link on in-memory tables and then splaying them. In a fresh <code>/db</code>,</p>
<pre class="highlight"><code class="language-q">q)t1:([] c1:`c`b`a; c2: 10 20 30)
q)t2:([] c3:`a`b`a`c; c4: 1. 2. 3. 4.)
q)update t1lnk:`t1!t1[`c1]?t2[`c3] from `t2
_
q)`:/db/t1/ set `.Q.en[`:/db;] t1
_
q)`:/db/t2/ set `.Q.en[`:/db;] t2
_
q)\\
$q
q)\l /db
q)meta t2
c | t f a
-----| ------
c3 | s
c4 | f
t1lnk| i t1
q)select c3,t1lnk.c2,c4 from t2
_</code></pre>
<p>Now we redo this example, assuming that the tables have already been splayed. You could map the database into memory but let‚Äôs work directly with the files. We have the additional step of appending the link columns to the <code>.d</code> file for <code>t2</code>.</p>
<pre class="highlight"><code class="language-q">q)`:/db/t1/ set .Q.en[`:/db;] ([] c1:`c`b`a; c2: 10 20 30)
_
q)`:/db/t2/ set .Q.en[`:/db;] ([] c3:`a`b`a`c; c4: 1. 2. 3. 4.)
_
q)`:/db/t2/t1link set `t1!(get `:/db/t1/c1)?get `:/db/t2/c3
_
q).[`:/db/t2/.d;();,;`t1link]
_
q)\l /db
q)meta t2
_</code></pre>
<h3 id="14210-query-execution-on-splayed-tables">14.2.10 Query Execution on Splayed Tables</h3>
<p>As we noted in the introduction of the chapter, splayed tables are a memory win, in that the table is mapped into memory and columns are actually loaded only as needed. Since a typical query requires only a handful of columns, this can greatly reduce the amount of memory required to process a table with many columns.</p>
<p>In addition to the memory win, if the same columns are referenced again soon, there is a good chance that their data is cached, either in memory or by the storage controller. This can be a significant performance win.</p>
<p>There is also a more subtle performance win in how the where phrase is implemented. As mentioned in <a href="https://code.kx.com/q4m3/11_IO/">Chapter 11</a>, each where subphrase produces a boolean vector that acts as mask, on which positions will be examined in the subsequent grouping and aggregation. When the table is mapped, this can also significantly reduce the amount of data that is loaded into memory.</p>
<h2 id="143-partitioned-tables">14.3 Partitioned Tables</h2>
<p>To recap the previous section, a splayed table has been split vertically along its columns and is subsequently mapped into memory. When a query is executed against the mapped table, column data is loaded as needed and is presumably cached for subsequent access. This reduces the table‚Äôs memory footprint, especially for tables with many columns.</p>
<p>Some timeseries data is so large that even the individual columns may not fit into memory ‚Äì for example, daily trades and quotes for an entire exchange. In this case, we can further decompose the table by slicing horizontally ‚Äì called <em>partitioning</em> in kdb+. For example, the solution for trades and quotes is to slice into daily portions. The result is a collection of daily splayed directories, one for each day for which data exists.</p>
<div class="admonition tip">
<p class="admonition-title">All partitioned tables are splayed but not all splayed tables are partitioned.</p>
</div>
<h3 id="1431-partitions">14.3.1 Partitions</h3>
<p>A <em>partitioned</em> table is a splayed table that is further decomposed by grouping records having common values along a column of special type. The allowable special column types have the property that the underlying value is an integer: date, month, year and long.</p>
<p>The slice of records having a given value is splayed into a directory, called a <em>partition</em>, whose name <strong>is</strong> that common value. In the canonical finance example, historical trades (or quotes) are stored in daily partition directories ‚Äì remember a q date is an integer under the covers.</p>
<p><strong>Big Picture (2)</strong>: We think of a partitioned table as a two-dimensional persisted form since it is cut in two directions: vertically by splaying along columns and horizontally by slicing into partitions.</p>
<table>
<thead>
<tr>
<th></th>
<th>column1</th>
<th>column2</th>
<th>column3</th>
<th>‚Ä¶</th>
</tr>
</thead>
<tbody>
<tr>
<td>partition1</td>
<td>‚ñ™</td>
<td>‚ñ™</td>
<td>‚ñ™</td>
<td>‚Ä¶</td>
</tr>
<tr>
<td>partition2</td>
<td>‚ñ™</td>
<td>‚ñ™</td>
<td>‚ñ™</td>
<td>‚Ä¶</td>
</tr>
<tr>
<td>‚Ä¶</td>
<td>‚Ä¶</td>
<td>‚Ä¶</td>
<td>‚Ä¶</td>
<td>‚Ä¶</td>
</tr>
</tbody>
</table>
<p>Here each ‚ñ™ represents a (partial) column of a partition slice as an opaque entity.</p>
<p>As with splaying, kdb+ implements partitioning using the OS directory structure. Each partition must be stored in a directory immediately under the database root directory. The directory name <strong>is</strong> the common column value for all the rows in the partition. Each partition directory in turn contains a subdirectory holding a splayed table with the records for that slice. The two-dimensional decomposition is reflected in two levels of nested directories under the root.</p>
<p>Since each splayed table subdirectory name <strong>is</strong> the name of the table, these names must be consistent across all partitions. Likewise, as portions of a single table, all splayed slices should have identical schemas. This means that each slice directory contains column files with the same names and internal data types, as well as identical <code>.d</code> files.</p>
<pre class="highlight"><code class="language-txt">/root
    /partitionvalue1
        /tablename
            .d
            column1name
            column2name
            ‚Ä¶
    /partitionvalue2
        /tablename
            .d
            column1name
            column2name
            ‚Ä¶
        ‚Ä¶</code></pre>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Since a partition directory name factors out the common value for all records in its slice, do not include the partition column when you splay a partition slice ‚Äì e.g., do not include a date column for a daily partitioned table. Instead, kdb+ infers the name, value and type from the partition directory name and creates a virtual column from this information. The name of the virtual column is set by q and cannot be controlled.</p>
</div>
<h3 id="1432-partition-domain">14.3.2 Partition Domain</h3>
<p>We call the type of the virtual column for the partition the <em>partition domain</em>. As noted previously, the partition domain must have an underlying integral value.</p>
<div class="admonition tip">
<p class="admonition-title">You cannot use a symbol column as a partition domain, even if the symbols are enumerated.</p>
</div>
<p>For example, suppose we have daily timeseries data. A daily partitioning could look as follows.</p>
<p>2015.01.01, 2015.01.02, ‚Ä¶</p>
<p>The virtual column is date in this case. Under each partition directory, there is a subdirectory <code>t</code> with that day‚Äôs slice of records.</p>
<pre class="highlight"><code class="language-txt">/db
    /2015.01.01
        /t          &lt;- trade records for 2015.01.01
    /2015.01.02
        /t          &lt;- trade records for 2015.01.02 ‚Ä¶</code></pre>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>A kdb+ database can only have a single partition domain. This means that you must create separate databases if you need partitions of different granularity. For example, you cannot have daily and monthly partitions in one database.</p>
</div>
<p>There is no requirement that there be entries for every value in the partition domain. For example, there may be no trades for holidays.</p>
<pre class="highlight"><code class="language-txt">/db
    /2014.12.31
        /t
    /2015.01.02
        /t
    ‚Ä¶</code></pre>
<p>If we partition by month,</p>
<p>2015.01m, 2015.02m, ‚Ä¶</p>
<p>the virtual column name is <code>month</code>.</p>
<p>For daily data that requires frequent multi-year queries, partitioning by year may be better.</p>
<p>2010, 2011, ‚Ä¶</p>
<p>In this case, the virtual column is <code>year</code> even though there is no year type in q. The values are recognized as valid q years if they are less than 10,000.</p>
<p>You can also partition by an arbitrary int such as a bin number.</p>
<p>0, 1, ‚Ä¶</p>
<p>This results in a virtual column <code>int</code>.</p>
<h3 id="1433-creating-partitioned-tables">14.3.3 Creating Partitioned Tables</h3>
<p>For simplicity, our first example has no symbols. In a fresh <code>/db</code>,</p>
<pre class="highlight"><code class="language-q">q)`:/db/2015.01.01/t/ set ([] ti:09:30:00 09:31:00; p:101 102f)
_
q)`:/db/2015.01.02/t/ set ([] ti:09:30:00 09:31:00; p:101.5 102.5)
_
q)\l /db
q)t / never do this at home!
date ti p
-------------------------
2015.01.01 09:30:00 101
2015.01.01 09:31:00 102
2015.01.02 09:30:00 101.5
2015.01.02 09:31:00 102.5</code></pre>
<p>The table appears to be in the workspace, along with the virtual date columns, but this is an illusion. It is actually mapped into memory. The request to display <code>t</code> forces all columns for all days to be loaded into memory.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Always qualify the partition column in the first where sub-phrase in any query against a partitioned table. If you do not, you will cause all partitions to be loaded into memory and will probably live-lock the server. Well before this completes, your colleagues will be at your desk with pitchforks and burning torches.</p>
</div>
<p>A more responsible way to create the previous display is,</p>
<pre class="highlight"><code class="language-q">q)select from t where date within 2015.01.01 2015.01.02
_</code></pre>
<p>Here we partition tables with symbols in a fresh <code>/db</code>. </p>
<!-- Note that we wrap the line in our display. -->

<pre class="highlight"><code class="language-q">q)`:/db/2015.01.01/t/ set .Q.en[`:/db;] ([] ti:09:30:00 09:31:00; s:`ibm`msft; p:101 33f)
_
q)`:/db/2015.01.02/t/ set .Q.en[`:/db;] ([] ti:09:30:00 09:31:00; s:`ibm`msft; p:101.5 33.5)
_
q)\l /db
q)select from t where date within 2015.01.01 2015.01.02
_</code></pre>
<h3 id="1434-working-with-partitioned-tables">14.3.4 Working with Partitioned Tables</h3>
<p>Continuing with the last example of the previous section, we can apply some basic operations on a partitioned table that has been mapped. Observe that the virtual partition column is included in the results of <a href="https://code.kx.com/q/ref/meta/"><code>meta</code></a> and <a href="https://code.kx.com/q/ref/cols/"><code>cols</code></a>.</p>
<pre class="highlight"><code class="language-q">q)count t
_
q)meta t
c   | t f a
----| -----
date| d
ti  | v
s   | s
p   | f
q)cols t
`date`ti`s`p
q)type t
98h</code></pre>
<p>However, none of the following work on partitioned tables, even though they work on splayed tables.</p>
<pre class="highlight"><code class="language-q">t[0j]
t[;`p]
0#t
exec from t
select[1] from t
`p xasc t</code></pre>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The fact that <code>exec</code> doesn‚Äôt work on partitioned tables is annoying but the workaround is,</p>
<pre><code class="language-q">
exec ‚Ä¶ from select ‚Ä¶ from ‚Ä¶ 
</code></pre>
</div>
<p>The select template, or the equivalent functional form, is <strong>the</strong> way to access data for a partitioned table. We have already seen how to retrieve the records for consecutive days. Here is the query to retrieve a day‚Äôs slice.</p>
<pre class="highlight"><code class="language-q">q)select from t where date=2015.01.01
_</code></pre>
<p>Here is how to retrieve the first or last day without hardcoding the date.</p>
<pre class="highlight"><code class="language-q">q)select from t where date=first date
_
q)select from t where date=max date
_</code></pre>
<p>Always place the partition column constraint first.</p>
<pre class="highlight"><code class="language-q">q)select from t where date=2015.01.01, ti&lt;09:30:30
_</code></pre>
<p>You can group by the partition column. Note we have wrapped the line for display.</p>
<pre class="highlight"><code class="language-q">q)select hi:max p, lo:min p by date from t
where date within 2015.01.01 2015.01.02
_</code></pre>
<h3 id="1435-the-virtual-column-i-in-partitioned-tables">14.3.5 The Virtual Column <code>i</code> in Partitioned Tables</h3>
<p>In a partitioned table, the virtual column <code>i</code> does <strong>not</strong> refer to absolute row number as it does with in-memory and splayed tables. Instead, it refers to the relative row number within a partition. Thus, a constraint on <code>i</code> alone would apply across all partitions and the result will contain that row in each partition slice ‚Äì probably not what you want and almost certainly a bad idea (colleagues with pitchforks again).</p>
<p>Continuing with the previous example, the following query retrieves the initial record from each of the specified partitions.</p>
<pre class="highlight"><code class="language-q">q)select from t where date in 2015.01.01 2015.01.02, i=0
_</code></pre>
<p>The following queries retrieve the first and last records in the table, respectively.</p>
<pre class="highlight"><code class="language-q">q) select from t where date=first date, i=0
_
q) select from t where date=max date, i=max i
_</code></pre>
<p>See <a href="#1446-balancing-slaves-and-cores">¬ß14.4.6</a> for using <a href="https://code.kx.com/q/ref/dotq/#qind-partitioned-index"><code>.Q.ind</code></a> to index <strong>across</strong> partitions.</p>
<h3 id="1436-query-execution-on-partitioned-tables">14.3.6 Query Execution on Partitioned Tables</h3>
<p>Query execution against a partitioned table is more complex than execution against a splayed table. Understanding how it works is necessary to achieve good design and performance with kdb+ databases.</p>
<p>Recall that the motivation for partitions was to avoid loading entire columns into memory. Behind the scenes, kdb+ achieves this as follows.</p>
<ul>
<li>Analyze the where phrase to determine which partition slices are targeted by the query</li>
<li>Process the remaining where sub-phrases to determine the column sub-domains that must be loaded.</li>
<li>Process the query separately against the requisite partition slices to obtain partial results.</li>
<li>Combine the partial results to obtain the final result.</li>
</ul>
<p>Reading only partial column slices of a table having many partitions is clearly a big memory and performance win. But things are even more interesting with regard to the third point above. If you have started q without slaves, the query is executed sequentially against the partitions and the time to complete is (roughly) the sum of the time against each of the partition slices.</p>
<p>By contrast, if you have started q with slaves, the query will be executed concurrently, once slice per slave. Thus, you can see significant speedup provided the query is compute-bound and the slaves are running on separate cores. On the other hand, if the query is I/O bound and you have only a single I/O channel to the data, you may see no speedup.</p>
<p>Next we discuss how kdb+ executes some types of queries concurrently.</p>
<h3 id="1437-map-reduce">14.3.7 Map-Reduce</h3>
<p>We start with a brief introduction to map-reduce. Suppose we want to compute some aggregation ‚Äì say the sum or the average ‚Äì of a large list of numbers and have at our disposal a crop of interns armed with smartphones. Our strategy is to decompose the overall task into two stages. In the first stage, we split the list into roughly (but not exactly) equal size sublists, distributing one to each intern along with instructions on what to compute. In the second step, we collect the (partial) results from each intern and combine them to get the overall result. This is what good managers do, after all.</p>
<p>Think about how to do this for sum before continuing. For the sum, you could instruct each intern to compute the sum of her list and then compute the sum of the individual sums. The same simple approach works for count or maximum.</p>
<p>For average, things aren't quite so simple. If you simply have each intern compute an average of her list, you will need to weight each partial average by the size of the sublist to get the final average. Thus you need the count too. You quickly realize that you can distribute the average computation more effectively. Instead of asking each intern to return the average and count for her list, ask her to compute the sum and the count. In the reduction step, you obtain the overall average as the sum of the partial sums divided by the sum of the partial counts.</p>
<p>More generally, map-reduce decomposes an operation on a (presumably large) list into two suboperations, <em>op<sub>map</sub></em> and <em>op<sub>reduce</sub></em>. In the first step, called 'map', <em>op<sub>map</sub></em> is performed on each sublist to obtain a list of partial results. In the second step, called "reduce", the partial result lists are combined with <em>op<sub>reduce</sub></em> to obtain the final result. A good exercise (and interview question) is to express sorting a list using map-reduce. In greater generality, map-reduce may apply the two steps recursively ‚Äì i.e., the reduce step may itself involve a map-reduce, etc.</p>
<p>It is easy to see how map-reduce applies to a query against a partitioned table, since the table is a list of records sliced into sub-lists by the partitioning. The challenge is to decompose the query into a map step and a reduce step. The solution depends on whether the query involves aggregation.</p>
<p>If there is no aggregation, the result of the query on each partition is simply the computed columns for the list of the records in the partition slice matching the constraint. In other words, produce a partial result table by computing the columns of the query across partitions. Because all the partial result tables conform, union the partial result tables in order of their virtual partition column values. In summary: fan the query across the partitions and union the ordered results.</p>
<p>Things are more interesting when the query contains aggregation. For aggregates that kdb+ recognizes as map-reducible, it applies the map operation across partition slices to obtain partial results. It then applies the reduce operation across the partial result tables to obtain the final result table.</p>
<p>At the time of this writing (Sep 2015), the aggregates that kdb+ can decompose with map-reduce are: <a href="https://code.kx.com/q/ref/avg/"><code>avg</code></a>, <a href="https://code.kx.com/q/ref/cor/"><code>cor</code></a>, <a href="https://code.kx.com/q/ref/count/"><code>count</code></a>, <a href="https://code.kx.com/q/ref/cov/"><code>cov</code></a>, <a href="https://code.kx.com/q/ref/dev/"><code>dev</code></a>, <a href="https://code.kx.com/q/ref/distinct/"><code>distinct</code></a>, <a href="https://code.kx.com/q/ref/first/"><code>first</code></a>, <a href="https://code.kx.com/q/ref/last/"><code>last</code></a>, <a href="https://code.kx.com/q/ref/max/"><code>max</code></a>, <a href="https://code.kx.com/q/ref/med/"><code>med</code></a>, <a href="https://code.kx.com/q/ref/min/"><code>min</code></a>, <a href="https://code.kx.com/q/ref/prd/"><code>prd</code></a>, <a href="https://code.kx.com/q/ref/sum/"><code>sum</code></a>, <a href="https://code.kx.com/q/ref/var/"><code>var</code></a>, <a href="https://code.kx.com/q/ref/wavg/"><code>wavg</code></a>, <a href="https://code.kx.com/q/ref/wsum/"><code>wsum</code></a>.</p>
<p>To make this more concrete, we re-examine computing an average against a daily partitioned trades table.</p>
<pre class="highlight"><code class="language-q">select avg size from trade where date within ‚Ä¶</code></pre>
<p>Because kdb+ recognizes <code>avg</code> as an aggregate it can decompose with map-reduce, it performs the calculation in two steps. Specifically, <em>op<sub>map</sub></em> computes the sum and record count for each date, while <em>op<sub>reduce</sub></em> divides the sum of the daily sums by the sum of the daily counts to give the average. The user gets the expected result and is none the wiser unless q was started with slaves, in which case the result maybe faster than linear.</p>
<h3 id="1438-multiple-partitioned-tables">14.3.8 Multiple Partitioned Tables</h3>
<p>Recall that there can be only one partition domain in a given kdb+ root ‚Äì i.e., daily, monthly, yearly or long. However, multiple tables can share this partitioning.</p>
<p>For example, quotes and trades can coexist in a daily partition. That layout would look something like,</p>
<pre class="highlight"><code class="language-txt">/db
    /2015.01.01
        /trade
        /quote
    /2015.01.02
        /trade
        /quote</code></pre>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Although not all potential partition values need be populated, any value that is populated must contain slices for all tables.
The following layout is in error.</p>
<pre><code class="language-txt">
/db
    /2015.01.01 &lt;- this is a bad partition!
        /quote
    /2015.01.02
        /trade
        /quote
</code></pre>
</div>
<p>We demonstrate how to create a simplified database with tables standing for trades and quotes in a fresh <code>/db</code> directory. Notice that we wrap the lines that do not fit within this page margin.</p>
<pre class="highlight"><code class="language-q">q)`:/db/2015.01.01/t/ set .Q.en[`:/db;]
 ([] ti:09:30:00 09:31:00; sym:`ibm`msft;p:101 33f)
_
q)`:/db/2015.01.02/t/ set .Q.en[`:/db;]
 ([] ti:09:30:00 09:31:00; sym:`ibm`msft;p:101.5 33.5)
_
q)`:/db/2015.01.01/q/ set .Q.en[`:/db;]
 ([] ti:09:30:00 09:31:00; sym:`ibm`msft;b:100.75 32.75; a:101.25 33.25f)
_
q)`:/db/2015.01.02/q/ set .Q.en[`:/db;]
 ([] ti:09:30:00 09:30:00; sym:`ibm`msft;b:101.25 33.25; a:101.75 33.75)
_</code></pre>
<p>Mapping the root, we now find both are available.</p>
<pre class="highlight"><code class="language-q">q)select from t where date within 2015.01.01 2015.01.02
_
q)select from q where date within 2015.01.01 2015.01.02
_</code></pre>
<p>Next we add a historical slice for q on 2014.12.31 but neglect to add the corresponding slice for t. Things seem fine when we map the root and query q on the newly added date.</p>
<pre class="highlight"><code class="language-q">q)`:/db/2014.12.31/q/ set .Q.en[`:/db;]
 ([] ti:09:30:00 09:31:00; sym:`ibm`msft; b:101. 33.; a:101.5 33.5f)
`:/db/2014.12.31/q/
q)\l /db
q)select from q where date=2014.12.31
_</code></pre>
<p>But we get a nasty surprise when we query <code>t</code> on the missing date.</p>
<pre class="highlight"><code class="language-q">q)select from t where date=2014.12.31
k){0!(?).@[x;0;p1[;y;z]]}
'./2014.12.31/t/ti: No such file or directory
.
?
(+`ti`sym`p!`:./2014.12.31/t;();0b;())
q.Q))</code></pre>
<p>We could remedy this by splaying an empty copy of <code>t</code> on that date. Instead we use the utility <a href="https://code.kx.com/q/ref/dotq/#qchk-fill-hdb"><code>.Q.chk</code></a> that fills all missing slices with empty tables from the most recent partition. We remap and find things are fine.</p>
<pre class="highlight"><code class="language-q">q).Q.chk `:/db
_
q)\l /db
q)select from t where date=2014.12.31
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>If you neglect to place a table slice in the most recent partition, the table will effectively disappear from your database since kdb+ inspects only that partition to determine which tables are present.</p>
</div>
<p>Continuing with our previous (repaired) example we add a trade slice for 2015.01.03 but neglect to add a quotes slice. When we remap, the table <code>q</code> is nowhere to be found.</p>
<pre class="highlight"><code class="language-q">q)`:/db/2015.01.03/t/ set .Q.en[`:/db;]
 ([] ti:09:30:00 09:31:00; sym:`ibm`msft;p:101 33f)
_
q)\l /db
q)\a
,`t</code></pre>
<p>Here is one way to fill an empty slice.</p>
<pre class="highlight"><code class="language-q">q)`:/db/2015.01.03/q/ set 0#select from `:/db/2015.01.02/q
_
q)\l /db
q)\a
`q`t</code></pre>
<h3 id="1439-examples-of-other-partition-domain-types">14.3.9 Examples of Other Partition Domain Types</h3>
<p>We present simple examples of partitions with the other permissible types. For simplicity, we do not include symbol columns; to do so, merely add the call to <code>.Q.en</code> as in previous examples.</p>
<p>Yearly partitioning can be a good solution when you regularly need to retrieve multiple years of daily data. Note that we explicitly include the date column but not the year column, which is virtual. In a fresh <code>/db</code>,</p>
<pre class="highlight"><code class="language-q">q)`:/db/2015/t/ set ([] date:2015.01.01 2015.01.02; p:101 102f)
`:/db/2015/t/
q)`:/db/2014/t/ set ([] date:2014.01.01 2014.01.02; p:101.5 102.5)
`:/db/2014/t/
q)\l /db
q)select from t where year within 2014 2015
_</code></pre>
<p>Monthly partitioning can be a good compromise between daily and yearly when you have both single day and year-to-date queries. We explicitly include the date column but not the month column, which is virtual.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Do <strong>not</strong> include a trailing <code>/</code> in the partition directory name but <strong>do</strong> include it in the queries.</p>
</div>
<p>In a fresh <code>/db</code>,</p>
<pre class="highlight"><code class="language-q">q)`:/db/2015.01/t/ set ([] date:2015.01.01 2015.01.02; p:101 102f)
`:/db/2015.01/t/
q)`:/db/2015.02/t/ set ([] date:2015.02.01 2015.02.02; p:101.5 102.5)
`:/db/2015.02/t/
q)\l /db
q)select from t where month within 2015.01m 2015.02m
_</code></pre>
<p>You can partition by a long to slice into arbitrary bins. The data need not be daily. In a fresh <code>/db</code>,</p>
<pre class="highlight"><code class="language-q">q)`:/db/1/t/ set ([] ti:09:30:00 09:31:00; p:101 102f)
_
q)`:/db/2/t/ set ([] ti:09:30:00 09:31:00; p:101.5 102.5)
_
q)\l /db
q)select from t where i within 1 2
_</code></pre>
<h3 id="14310-partitioned-tables-with-links">14.3.10 Partitioned Tables with Links</h3>
<p>You can create links between tables in the same partitioned database with the following restriction.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A link column in the slice of a partitioned table must be intra-partition ‚Äì i.e., it must refer to another table in the same slice. In particular, you cannot link across days in a daily partitioned database.</p>
</div>
<p>Since the daily slices are splayed tables, the mechanics of creating links for partitioned tables are the same as for splayed tables. We first demonstrate how to create a link as the slices are created in memory and splayed. Again we avoid symbols for simplicity; to include them, add a call to <code>.Q.en</code> as in previous examples.</p>
<p>We create two days of linked tables in a fresh <code>/db</code>.</p>
<pre class="highlight"><code class="language-q">q)t1:([] id:101 102 103; v:1.1 2.2 3.3)
q)`:/db/2015.01.01/t1/ set t1
_
q)`:/db/2015.01.01/t2/ set ([] id:`t1!t1[`id]?103 101 101 102; n:10 20 30 40)
_
q)`:/db/2015.01.02/t1/ set t1
_
q)`:/db/2015.01.02/t2/ set ([] id:`t1!t1[`id]?105 104 104; n:50 60 70)
_</code></pre>
<p>Now we map the root and use dot notation on the link column.</p>
<pre class="highlight"><code class="language-q">q)\l /db
q)select date,n,id.v from t2 where date in 2015.01.01 2015.01.02
_</code></pre>
<p>Adding a link column to persisted partitions is only a bit more complicated. Here we create a link on (enumerated) symbol columns. In a fresh <code>/db</code> we first create the partitioned tables without the link.</p>
<pre class="highlight"><code class="language-q">q)`:/db/2015.01.01/t1/ set .Q.en[`:/db;] ([] id:`c`b`a; c1: 10 20 30)
_
q)`:/db/2015.01.02/t1/ set .Q.en[`:/db;] ([] id:`x`a; c1: 40 50)
_
q)`:/db/2015.01.01/t2/ set .Q.en[`:/db;] ([]id:`a`b`a`c; c2: 1 2 3 4.)
_
q)`:/db/2015.01.02/t2/ set .Q.en[`:/db;] ([] id:`x`a`x; c2:5 6 7.)
_</code></pre>
<p>Presumably at a later time, we add the link column to <code>t2</code> in each partition, making sure to update the <code>.d</code> files.</p>
<pre class="highlight"><code class="language-q">q)`:/db/2015.01.01/t2/t1lnk set
`t1!get[`:/db/2015.01.01/t1/id]?get[`:/db/2015.01.01/t2/id]
_
q)`:/db/2015.01.01/t2/.d set get[`:/db/2015.01.01/t2/.d],`t1lnk
_
q)`:/db/2015.01.02/t2/t1lnk set
`t1!get[`:/db/2015.01.02/t1/id]?get[`:/db/2015.01.02/t2/id]
_
q)`:/db/2015.01.02/t2/.d set get[`:/db/2015.01.02/t2/.d],`t1lnk
_</code></pre>
<p>Now we can map the root and use dot notation.</p>
<pre class="highlight"><code class="language-q">q)select date,id,t1lnk.c1,c2 from t2 where date&lt;=2015.01.02
_</code></pre>
<h2 id="144-segmented-tables">14.4 Segmented Tables</h2>
<p>We saw in the previous section that queries against partitioned tables execute separately across the partitions. When q is started without slaves this is a memory win but not a performance win, except for the reduced amount of data manipulation required. When q is started with slaves this can offer significant performance enhancement for compute-bound queries.</p>
<p>In large timeseries databases, the queries are often I/O-bound. In this case, the multiple slaves for a partitioned query will mostly be waiting on I/O (or Godot). The solution requires multiple I/O channels so that data retrieval and processing can occur in parallel. Kdb+ provides another level of data decomposition to enable parallel processing in this scenario.</p>
<p>Traditional kdb+ parlance did not distinguish between this level and the basic partitioning we encountered in the last section. We find this confusing and, at the suggestion of Simon Garland of KX, have introduced the terminology of <em>segmentation</em>.</p>
<h3 id="1441-segments">14.4.1 Segments</h3>
<p>Segmentation is an additional level of structure on top of partitioning. <em>Segmentation</em> spreads a partitioned table‚Äôs records across multiple directories that have the same structure as the root directory in a partitioned database. Each pseudo-root, called a <em>segment</em>, is thus a directory that contains a collection of partition directories. The segment directories are presumably on independent I/O channels so that data retrieval can occur in parallel.</p>
<p>You can use any criteria to decompose partition slices, as long as the results are conforming record subsets that are disjoint and complete ‚Äì i.e., they reconstitute the original table with no omissions or duplication. The decomposition can be along rows, along partitions or by some combination thereof, but it cannot occur only along columns since all records must conform across the decomposition.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>You must ensure that the segments conform and are complete and disjoint, since kdb+ will not check this when you write the data files. In particular, overlapping segments will result in duplicate records in query results and an incomplete decomposition will result in dropped records.</p>
</div>
<p><strong>Big Picture (3)</strong>: .We view a segmented table as a three-dimensional persisted form: the table is cut vertically by splaying, sliced horizontally by partitions and is additionally segmented across physical locations. The primary purpose of the third dimension is to allow operations against the tables to take advantage of parallel I/O and concurrent processing. Following is an abstract representation of segmentation:</p>
<p><em>segment1</em></p>
<table>
<thead>
<tr>
<th></th>
<th align="center">column1</th>
<th align="center">column2</th>
<th>‚Ä¶</th>
</tr>
</thead>
<tbody>
<tr>
<td>partition*</td>
<td align="center">‚ñ™</td>
<td align="center">‚ñ™</td>
<td>‚Ä¶</td>
</tr>
<tr>
<td>partition*</td>
<td align="center">‚ñ™</td>
<td align="center">‚ñ™</td>
<td>‚Ä¶</td>
</tr>
<tr>
<td>‚Ä¶</td>
<td align="center">‚Ä¶</td>
<td align="center">‚Ä¶</td>
<td>‚Ä¶</td>
</tr>
</tbody>
</table>
<p><em>segment2</em></p>
<table>
<thead>
<tr>
<th></th>
<th align="center">column1</th>
<th align="center">column2</th>
<th>‚Ä¶</th>
</tr>
</thead>
<tbody>
<tr>
<td>partition*</td>
<td align="center">‚ñ™</td>
<td align="center">‚ñ™</td>
<td>‚Ä¶</td>
</tr>
<tr>
<td>partition*</td>
<td align="center">‚ñ™</td>
<td align="center">‚ñ™</td>
<td>‚Ä¶</td>
</tr>
<tr>
<td>‚Ä¶</td>
<td align="center">‚Ä¶</td>
<td align="center">‚Ä¶</td>
<td>‚Ä¶</td>
</tr>
</tbody>
</table>
<p><em>‚Ä¶</em></p>
<p>Here each ‚ñ™ represents a (partial) column of a partition slice as an opaque entity.</p>
<p>In contrast to the partitioned table layout in which partitions reside under the root, the segment directories must <strong>not</strong> reside under the root. The only portion of a segmented table (other than the sym file for enumerated symbol columns) that lives in the root is a file called <a href="https://code.kx.com/q/kb/partition/"><code>par.txt</code></a> containing the paths of the physical locations of the segments, one segment path per line.</p>
<p>Here is how the abstract segmentation discussed above would be laid out on the file system.</p>
<pre class="highlight"><code class="language-txt">/db
    [sym]
    par.txt
=============== &lt;- channel 1
/segment1
    /partition*
        /table*
        /table*
        ‚Ä¶
    /partition*
        /table*
        /table*
        ‚Ä¶
=============== &lt;- channel 2
/segment2
    /partition*
        /table*
        /table*
        ‚Ä¶
    /partition*
        /table*
        /table*
        ‚Ä¶
=============== ‚Ä¶</code></pre>
<p>To make this more concrete, we demonstrate how to segment daily trades (and eventually quotes) in several useful ways. To begin, we create segments by bucketing trades into alternating days of the week.</p>
<pre class="highlight"><code class="language-txt">/1                  &lt;- drive 1
    /2015.01.01
        /t          &lt;- day‚Äôs trades
    /2015.01.03
        /t          &lt;- day‚Äôs trades
    ‚Ä¶
=============
/2                  &lt;- drive 2
    /2015.01.02
        /t          &lt;- day‚Äôs trades
    /2015.01.04
        /t          &lt;- day‚Äôs trades
    ‚Ä¶</code></pre>
<p>This segmentation represents grouping of partitions, so it is orthogonal to the partitioning. It is clearly complete and disjoint and is easily generalizable to round-robining every <em>n</em> business days.</p>
<p>We could alternatively create segments by splitting the daily slices into records with symbols starting with a-m and those starting with n-z. Here we are decomposing based on the values in a symbol column, which we could not do with simple partitioning.</p>
<pre class="highlight"><code class="language-txt">/am                 &lt;- drive 1
    /2015.01.01
        /t          &lt;- day‚Äôs trades for syms a-m
    /2015.01.02
        /t          &lt;- day‚Äôs trades for syms a-m
    ‚Ä¶
=============
/nz &lt;- drive 2
    /2015.01.01
        /t          &lt;- day‚Äôs trades for syms n-z
    /2015.01.02
        /t          &lt;- day‚Äôs trades for syms n-z
    ‚Ä¶</code></pre>
<p>This segmentation clearly results in complete, disjoint subsets. It is not orthogonal to the partitioning because a single day's trades span multiple segments. It is easily generalizable to <em>n</em> segments by splitting the alphabet into <em>n</em> roughly equal portions.</p>
<p>Alternately, we can create segments by splitting the daily slices into trades from NYSE and trades from NASDAQ.</p>
<pre class="highlight"><code class="language-txt">/nyse               &lt;- drive 1
    /2015.01.01
        /t          &lt;- day‚Äôs trades for nyse
    /2015.01.02
        /t          &lt;- day‚Äôs trades for nyse
    ‚Ä¶
=============
/nasd               &lt;- drive 2
    /2015.01.01
        /t          &lt;- day‚Äôs trades for nasd
    /2015.01.02
        /t          &lt;- day‚Äôs trades for nasd ‚Ä¶</code></pre>
<p>The segmentation is also not orthogonal to the partitioning since a single day's trades span multiple segments. It is clearly complete and disjoint and is easily generalizable to multiple exchanges ‚Äì e.g., all Asian exchanges.</p>
<p>Finally, we provide an example of a non-uniform segmentation, in which some partitions span segments and others do not. The <em>A</em> segment contains trades from the beginning of day 1 until lunchtime of day 2. The <em>B</em> segment contains the trades from lunchtime of day 2 through the end of day 3. The <em>C</em> segment contains all trades from day 4. We rely on our understanding of the business logic to know that segmentation is disjoint and complete.</p>
<pre class="highlight"><code class="language-txt">/seg A              &lt;- drive 1
    /2015.01.01
        /t          &lt;- entire day‚Äôs trades
    /2015.01.02
        /t          &lt;- morning trades
=============
/seg B &lt;- drive 2
    /2015.01.02
        /t          &lt;- afternoon trades
    /2015.01.03
        /t          &lt;- entire day‚Äôs trades
=============
/seg C &lt;- drive 3
    /2015.01.04
        /t          &lt;- entire day‚Äôs trades</code></pre>
<p>This sort of segmentation can be useful if your query patterns are not uniform across days.</p>
<h3 id="1442-segmentation-vs-partitions">14.4.2 Segmentation vs. Partitions</h3>
<p>We collect the following into tabular form so that you can use it for meditation.</p>
<table>
<thead>
<tr>
<th></th>
<th>Partitioned Table</th>
<th>Segmented Table</th>
</tr>
</thead>
<tbody>
<tr>
<td>Record location</td>
<td>All partitions (and hence all records) reside under the root directory.</td>
<td>None of the segments (and hence no records) reside under the root.</td>
</tr>
<tr>
<td>I/O channels</td>
<td>All partitions (and hence all records) reside on a single I/O channel.</td>
<td>The segments (and hence the records) should reside on multiple I/O channels.</td>
</tr>
<tr>
<td>Processing</td>
<td>Partitions loaded and processed sequentially in aggregation queries.</td>
<td>Given appropriate slaves and cores, aggregate queries load segments in parallel and process them concurrently.</td>
</tr>
<tr>
<td>Decomposition</td>
<td>Partition by grouping rows on the values of a virtual column of underlying integral type.</td>
<td>Segment by any criteria yielding disjoint and complete decomposition.</td>
</tr>
<tr>
<td>Symbols</td>
<td>Cannot partition on a symbol column</td>
<td>Can segment along a symbol column</td>
</tr>
<tr>
<td>Virtual Column</td>
<td>Partition column not stored. Virtual column values inferred from directory names</td>
<td>No special column associated with segmentation (virtual column from underlying partition still present)</td>
</tr>
</tbody>
</table>
<h3 id="1443-creating-segmented-tables">14.4.3 Creating Segmented Tables</h3>
<p>There is no one-size-fits-all utility to create segments. Instead, you write a q program that places a subset of each partition slice into a segment. You can create segments and partitions at the same time by including logic in your data load script to extract slice subsets and place them in the appropriate directory on the appropriate drive.</p>
<p>Along with creating the partitions, you must also specify the locations of the segments in an ASCII text file <code>par.txt</code> located in the root. Each line of <code>par.txt</code> contains the path of one segment directory; symlinks are acceptable.</p>
<div class="admonition warning">
<p class="admonition-title">The segment paths must not be under the root. Qbies who make this mistake will prefer Vogon poetry.</p>
</div>
<p>We illustrate the process by creating segmented tables for each example in <a href="#1441-segments">¬ß14.4.1</a>. Our intent is to demonstrate how to create the segments and observe how execution of the query pieces the segment results back together. Initially we create the segments without concern for placing them on multiple drives and running multiple slaves, as we are not (yet) considering performance. That comes shortly.</p>
<p>We begin with the example in which daily slices are segmented alternately across two bins. This will result in roughly even access and will give good performance assuming the queries are uniformly distributed across days. The storage layout looks like,</p>
<pre class="highlight"><code class="language-txt">/1
    /2015.01.01
        /t
    /2015.01.03
        /t
/2
    /2015.01.02
        /t
    /2015.01.04
        /t</code></pre>
<p>The corresponding <code>par.txt</code> file is,</p>
<pre class="highlight"><code class="language-txt">/1
/2</code></pre>
<p>In a fresh directories <code>/1</code>, <code>/2</code> and <code>/db</code> we construct the segments and write the <code>par.txt</code> file.</p>
<pre class="highlight"><code class="language-q">q)`:/1/2015.01.01/t/ set .Q.en[`:/db;]
 ([] ti:09:30:00 09:31:00; s:`ibm`t; p:101 17f)
_
q)`:/2/2015.01.02/t/ set .Q.en[`:/db;]
 ([] ti:09:30:00 09:31:00; s:`ibm`t; p:101.5 17.5)
_
q)`:/1/2015.01.03/t/ set .Q.en[`:/db;]
 ([] ti:09:30:00 09:31:00; s:`ibm`t; p:103 16.5f)
`:/1/2015.01.03/t/
q)`:/2/2015.01.04/t/ set .Q.en[`:/db;]
 ([] ti:09:30:00 09:31:00; s:`ibm`t; p:102 17f)
_

q)`:/db/par.txt 0: ("/1"; "/2")
_

q)\l /db
q)select from t where date within 2015.01.01 2015.01.04
_</code></pre>
<p>Next we segment trades by symbol range. The storage layout looks like,</p>
<pre class="highlight"><code class="language-txt">/am
    /2015.01.01
    /2015.01.02
/nz
    /2015.01.01
    /2015.01.02</code></pre>
<p>The corresponding <code>par.txt</code> file is,</p>
<pre class="highlight"><code class="language-q">/am
/nz</code></pre>
<p>We begin with fresh directories <code>/am</code>, <code>/an</code>, and <code>/db</code> and a utility function to extract records for symbols within a range. Then we create the segments and write out the <code>par.txt</code> file.</p>
<pre class="highlight"><code class="language-q">q)extr:{[t;r] select from t where (`$1#'string sym) within r}

q)t1:.Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`ibm`t; p:101 17f)
q)`:/am/2015.01.01/t/ set extr[t1;`a`m]
_
q)`:/nz/2015.01.01/t/ set extr[t1;`n`z]
_

q)t2:.Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`ibm`t; p:101.5 17.5)
q)`:/am/2015.01.02/t/ set extr[t2;`a`m]
_
q) `:/nz/2015.01.02/t/ set extr[t2;`n`z]
_

q)`:/db/par.txt 0: ("/am"; "/nz")
`:/db/par.txt

q)\l /db
q)select from t where date within 2015.01.01 2015.01.02
_</code></pre>
<p>Next we segment trades by exchange. The storage layout looks like,</p>
<pre class="highlight"><code class="language-txt">/nyse
    /2015.01.01
        /t
    /2015.01.02
        /t
/nasd
    /2015.01.01
        /t
    /2015.01.02
        /t</code></pre>
<p>The corresponding <code>par.txt</code> file is,</p>
<pre class="highlight"><code class="language-txt">/nyse
/nasd</code></pre>
<p>Segment construction is completely analogous to that of the previous example. We begin with fresh directories <code>/nyse</code>, <code>/nasd</code>, <code>/db</code> and a utility to extract records by exchange.</p>
<pre class="highlight"><code class="language-q">q)extr:{[t;e] select from t where ex=e}

q)t1:.Q.en[`:/db;] ([] ti:09:30:00 09:31:00; s:`ibm`aapl; p:101 17f;ex:`n`o)
q)`:/nyse/2015.01.01/t/ set extr[t1;`n]
_
q)`:/nasd/2015.01.01/t/ set extr[t1;`o]
_

q)t2:.Q.en[`:/db;] ([] ti:09:30:00 09:31:00; s:`aapl`ibm; p:143 102f; ex:`o`n)
q)`:/nyse/2015.01.02/t/ set extr[t2;`n]
_
q)`:/nasd/2015.01.02/t/ set extr[t2;`o]
_

q)`:/db/par.txt 0: ("/nyse"; "/nasd")
_

q)\l /db
q)select from t where date within 2015.01.01 2015.01.02
_</code></pre>
<p>Finally we show how to distribute a day across segments. The storage layout looks like,</p>
<pre class="highlight"><code class="language-txt">/seg A
    /2015.01.01
    /2015.01.02
/seg B
    /2015.01.02
    /2015.01.03
/seg C
    /2015.01.04</code></pre>
<p>The corresponding <code>par.txt</code> file is,</p>
<pre class="highlight"><code class="language-txt">/A
/B
/C</code></pre>
<p>In fresh directories <code>/A</code>, <code>/B</code>, <code>/C</code> and <code>/db</code>,</p>
<pre class="highlight"><code class="language-q">q) t1:.Q.en[`:/db;] ([] ti:09:30:00 12:31:00; s:`ibm`t; p:101 17f)
q)`:/A/2015.01.01/t/ set t1
_
q)t2:.Q.en[`:/db;] ([] ti:09:31:00 12:32:00; s:`ibm`t; p:102 18f)
q)`:/A/2015.01.02/t/ set select from t2 where ti&lt;=12:00:00
_
q)`:/B/2015.01.02/t/ set select from t2 where ti&gt;12:00:00
_
q)t3:.Q.en[`:/db;] ([] ti:09:33:00 12:33:00; s:`ibm`t; p:103 19f)
q)`:/B/2015.01.03/t/ set t3
_
q)t4:.Q.en[`:/db;] ([] ti:09:34:00 12:35:00; s:`ibm`t; p:104 20f)
q)`:/C/2015.01.04/t/ set t4
_

q)`:/db/par.txt 0: ("/A";"/B";"/C")
_

q)\l /db
q)select from t where date within 2015.01.01 2015.01.04
_</code></pre>
<h3 id="1444-multiple-segmented-tables">14.4.4 Multiple Segmented Tables</h3>
<p>Multiple tables that share a partition can also be segmented. While there is no requirement that the tables be distributed similarly across the segmentation, they should do so if you expect to use links or joins between them. In this section, we create (vastly simplified) trades and quotes that share a segmentation in order to do joins.</p>
<p>Our actual segmentation layout is designed to allow parallel retrieval for <a href="https://code.kx.com/q/ref/aj/"><code>aj</code></a>. We first observe that it performs an equijoin on the sym and date columns, while it performs a non-equijoin on the time column. Thus we want all the time values for a given symbol and date in one segment. Consequently, segmentation by symbol range will allow parallelization of <code>aj</code> across symbols.</p>
<p>Here is a simple version of this scheme.</p>
<pre class="highlight"><code class="language-txt">/a_m &lt;- segment for first portion of alphabet
    /2015.01.01     &lt;- the specific day
        /t          &lt;- that day‚Äôs trades for symbols a-m
        /q          &lt;- that day‚Äôs quotes for symbols a-m
    /2015.01.02     &lt;- the specific day
        /t          &lt;- that day‚Äôs trades for symbols a-m
        /q          &lt;- that day‚Äôs quotes for symbols a-m
=================
/n_z                &lt;- segment for second portion of alphabet
    /2015.01.01     &lt;- the specific day
        /t          &lt;- that day‚Äôs trades for symbols n-z
        /q          &lt;- that day‚Äôs quotes for symbols n-z
    /2015.01.02     &lt;- the specific day
        /t          &lt;- that day‚Äôs trades for symbols n-z
        /q          &lt;- that day‚Äôs quotes for symbols n-z
=================</code></pre>
<p>The corresponding <code>par.txt</code> file is,</p>
<pre class="highlight"><code class="language-txt">/a_m
/n_z</code></pre>
<p>Setting up the segments and partitions is a matter of getting the details right. In our simplified example, we pretend that the directories <code>/am</code>and <code>/nz</code> reside on different drives. In fresh directories <code>/am</code>, <code>/nz</code> and <code>/db</code>,</p>
<pre class="highlight"><code class="language-q">q)extr:{[t;r] select from t where (`$1#'string sym) within r}
q)/ day 1
q)t:.Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`ibm`t; p:101 17f)
q)q:.Q.en[`:/db;] ([] ti:09:29:59 09:29:59 09:30:00; sym:`ibm`t`ibm; p:100.5 17 101)
q)`:/am/2015.01.01/t/ set extr[t;`a`m]
_
q)`:/nz/2015.01.01/t/ set extr[t;`n`z]
_
q)`:/am/2015.01.01/q/ set extr[q;`a`m]
)
q)`:/nz/2015.01.01/q/ set extr[q;`n`z]
_

q)/ day 2
q)t:.Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`t`ibm; p:17.1 100.9)
q)q:.Q.en[`:/db;] ([] ti:09:29:59 09:29:59 09:30:00; sym:`t`ibm`t;p:17 100.8 17.1)
q)`:/am/2015.01.02/t/ set extr[t;`a`m]
_
q)`:/nz/2015.01.02/t/ set extr[t;`n`z]
_
q)`:/am/2015.01.02/q/ set extr[q;`a`m]
_
q)`:/nz/2015.01.02/q/ set extr[q;`n`z]
_
q)`:/db/par.txt 0: ("/am"; "/nz")
_

q)\l /db

q)dr:2015.01.01 2015.01.02
q)select from t where date within dr
_
q)select from q where date within dr
_</code></pre>
<p>Now let‚Äôs do the <code>aj</code>. We could be na√Øve and pull all requisite data into the workspace, but this would be inefficient in memory and slow, assuming it would fit.</p>
<pre class="highlight"><code class="language-q">q)aj[`date`sym`ti;select from t where date within dr;
 select from q where date within dr]
_</code></pre>
<p>Instead we start q with slaves and use <a href="https://code.kx.com/q/ref/peach/"><code>peach</code></a> to run things in parallel across the segmentation.</p>
<pre class="highlight"><code class="language-bash">$q -s 2
KDB+ ...</code></pre>
<pre class="highlight"><code class="language-q">q)aj1:{aj[`sym`ti;select from t where date=d; select from q where date=d]}
q)raze aj1 peach 2015.01.01 2015.01.02
_</code></pre>
<h3 id="1445-query-execution-against-segmented-tables">14.4.5 Query Execution against Segmented Tables</h3>
<p>The performance goal is to scale out by taking advantage of parallel I/O and concurrent processing. We would ideally like to achieve 100% saturation of the I/O channels and 100% utilization of each core. How do we approach these levels on a kdb+ server? The key insight in kdb+ design and tuning is that a vector calculation on in-memory data is much faster than retrieving data from storage. This suggests our first two design principles.</p>
<ol>
<li>
<p>Maximize the number of independent I/O channels to retrieve data in parallel.</p>
</li>
<li>
<p>Maximize server memory in order to allocate each slave thread as much memory as it needs.</p>
</li>
</ol>
<p>Suppose we can satisfy these two objectives by having storage devices attached to the kdb+ server over <em>n</em> independent I/O channels ‚Äì for example, the author‚Äôs laptop has SSD storage that appears as multiple independent I/O channels. In this scenario, we are led to our next observation.</p>
<ol start="3">
    <li>Create <em>n</em> segments to spread data retrieval across the <em>n</em> channels in order to maximize I/O parallelization.</li>
</ol>

<p>To ensure that data can be processed from all <em>n</em> channels simultaneously and that no two threads contend for data, we are led to our final objective.</p>
<ol start="4">
    <li>Have (at least) <em>n</em> slave threads</li>
</ol>

<p>The precise form of segmentation and number of slaves will depend on the actual data and queries.</p>
<p>Now assuming we have such an environment, does kdb+ execute a query against a segmented table in our scenario of <em>n</em> segments and <em>n</em> slaves.? Essentially, it decomposes a qualifying query into two steps via map-reduce:</p>
<ul>
<li>Map: a revised form of the original query that executes on each segment</li>
<li>Reduce: aggregate the segment results</li>
</ul>
<p>The use of map-reduce allows kdb+ to perform preliminary calculations as close to the data as possible and to perform aggregation centrally at the last step.</p>
<p>To begin, kdb+ compares the query‚Äôs requisite partitions to the segment layout in <code>par.txt</code> and determines the footprint of the target partitions on each segment. The result is a nested list, each item being the partition list for one segment.</p>
<p>To execute the map step, kdb+ creates a revised query containing the map sub-operation from the original query, which it dispatches to all <em>n</em> slaves via <code>peach</code>. Each slave is provided the partition list for one segment and computes the revised query for its segment. For example, the revised query for <code>avg</code> is:</p>
<blockquote>
<p>Compute the sum and count of the sublist</p>
</blockquote>
<p>With this knowledge, we examine execution <strong>within</strong> one slave, where the revised query is applied against a segment‚Äôs partition footprint. Here kdb+ <strong>sequentially</strong> applies the map sub-operations of the original query across the targeted partitions to obtain partition result tables that it then collects into a list representing one segment result.</p>
<p>Now we stand back and examine execution <strong>across</strong> the slaves by squinting to make partition detail disappear. At this level, the original query‚Äôs map step has <em>n</em> slaves retrieving segment data <strong>in parallel</strong> and calculating segment results. Once all slaves complete, the nested list of segment results is flattened and reordered by partition value.</p>
<p>Finally, kdb+ employs the original query reduce step to combine the full list of ordered partition results into the query result table. Whew!</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Kdb+ treats a vanilla partitioned table ‚Äì i.e., without a <code>par.txt</code> ‚Äì as having a single segment. The astute reader will realize that the description in <a href="#1433-creating-partitioned-tables">¬ß14.3.3</a> is actually the degenerate case of this section.</p>
</div>
<h3 id="1446-balancing-slaves-and-cores">14.4.6 Balancing Slaves and Cores</h3>
<p>In our quest to reach 100% saturation of I/O and CPU, we consider how to optimize the use of slaves and cores. As seen in the previous section, the query via map-reduce provides good progress toward our original objective of I/O saturation. The slaves can load data from all <em>n</em> channels in parallel without contention.</p>
<p>We now investigate channel and core utilization. Since kdb+ will only use as many slaves to process a query as there are segments in the query footprint, we consider two cases.</p>
<p><strong>I/O-bound</strong>: Assuming that the query has light calculation compared to data retrieval (common in kdb+), having <em>n</em> slaves on <em>n</em> cores is close to optimal: most of the time, all <em>n</em> slaves will be waiting for data. When a partition load completes, there will be a brief burst of computation, followed by another long load. So we conclude for this scenario:</p>
<p><em>n</em> channels =&gt; <em>n segments</em> =&gt; <em>n</em> slaves =&gt; <em>n</em> cores</p>
<p><strong>Balanced I/O-compute</strong>: Consider the scenario in which both the I/O and calculation are intensive. While one slave is waiting on data, another slave on the same core could be crunching; conversely, while one slave is crunching another slave on that core could be loading data. Thus to maximize channel and core utilization, we actually want <em>2n</em> slaves on <em>n</em> cores. We conclude that in this scenario we should have <em>2n</em> segments, two per channel. On average, there will be one slave per core loading data and one slave per core crunching the data it has just loaded.</p>
<p><em>n</em> channels =&gt; <em>2n segments</em> =&gt; <em>2n</em> slaves =&gt; <em>n</em> cores</p>
<p>These conclusions rely on many implicit assumptions that we have glossed over. In practice, you should view them as guidelines, with the goal of feeding data to kdb+ as fast as possible. The optimum configuration for your situation will depend on your particular query mix. For example, queries that do VWAP calculations are closer to the first scenario, whereas queries doing regression analysis are closer to the second.</p>
<p>A good strategy is to construct your initial configuration using one of the above scenarios. Then load a good approximation of your anticipated data and query mix, and simulate a realistic user load. Observe the I/O saturation and CPU utilization and adjust the number of slaves and cores allocated to the q process accordingly.</p>
<h3 id="1447-sample-performance-data">14.4.7 Sample Performance Data</h3>
<p>Our examples are based on simulated trade data randomly generated to match one month of US equity data spanning August and September 2014. The data is in the table <code>trade</code>, whose most significant columns <code>time</code>, <code>sym</code>, <code>tp</code> and <code>ts</code> represent respectively arrival time, instrument symbol, trade price and trade size columns. The trade data is partitioned by date.</p>
<p>The following output is generated from a version of kdb+ that has been instrumented to show the intermediate steps during query execution. The first example query shows how the simple aggregate <code>avg tp</code> is decomposed into the pair sum and count in the map step, followed by division of the sums of sums by the sum of counts for the reduce step. Here the data is not segmented ‚Äì i.e., there is no <code>par.txt</code> file.</p>
<p>The added instrumentation exposes 3 stages of execution of a query.</p>
<ol>
<li>
<p>Analyze query:</p>
<ul>
<li>
<p>Decompose query into map and reduce components (if appropriate)</p>
</li>
<li>
<p>Determine and apply partition constraints</p>
</li>
<li>
<p>Map query onto segments and partitions (query plan)</p>
</li>
</ul>
</li>
<li>
<p>Execute map step, if appropriate</p>
</li>
<li>
<p>Compute final result (reduce step)</p>
</li>
</ol>
<pre class="highlight"><code class="language-q">q)select avg tp from trade where date in -3#date
"--- map/reduce: input aggregates, map query, reduce query ---" (,`tp)!,(avg;`tp)
`0`1!((sum;($["f"];`tp));(#:;`i))
(,`tp)!,(%;(sum;`0);(sum;`1))

"--- query plan: segments/partitions ---" (`trade;();()!();`0`1!((sum;($["f"];`tp));(#:;`i)))
2014.09.24 2014.09.25 2014.09.28

"--- partition query: query, segment, partition, result ---" (`trade;();()!();`0`1!((sum;($["f"];`tp));(#:;`i)))
`:.
2014.09.24
+`0`1!(,1.419538e+10;,27914938)

"--- partition query: query, segment, partition, result ---" (`trade;();()!();`0`1!((sum;($["f"];`tp));(#:;`i)))
`:. 2014.09.25 +`0`1!(,1.419318e+10;,24485503)

"--- partition query: query, segment, partition, result ---" (`trade;();()!();`0`1!((sum;($["f"];`tp));(#:;`i)))
`:. 2014.09.28 +`0`1!(,1.388645e+10;,20162485)

"--- query plan result ---" (+`0`1!(,1.419538e+10;,27914938);+`0`1!(,1.419318e+10;,24485503); +`0`1!(,1.388645e+10;,20162485))

"--- final result ---" tp -------- 582.5979</code></pre>
<p>First note that <code>`0</code> and <code>`1</code> are used as intermediate columns. Observe that <code>avg tp</code> is decomposed into a map step.</p>
<pre class="highlight"><code class="language-q">`1:sum "f"$tp and `0:count i</code></pre>
<p>and a reduce step</p>
<pre class="highlight"><code class="language-q">tp:(sum `0)%sum `1.</code></pre>
<p>Also observe that expressions are displayed in their parse-tree format and that count is expressed as its k equivalent: the unary form of <code>#</code>.</p>
<p>The next example uses <code>par.txt</code> to segment the data into four segments: (<code>/d/d1/data</code>, <code>/d/d2/data</code>, <code>/d/d3/data</code>, <code>/d/d4/data</code>). It also uses a by-date clause to sidestep the need to break up the query into map and reduce components (our data is partitioned by date). For clarity, we execute the query only on the last 16 partitions as well as on a subset of symbols. Observe that the "query plan" contains more information than that of the previous example: the query, a list of all partitions, a list of all segments, and a nested list of partitions belonging to segments.</p>
<pre class="highlight"><code class="language-q">q)select avg tp by date from trade where date in -16#date,sym in syms

"--- query plan: segments/partitions ---" (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) 2014.08.18 2014.08.19 2014.08.20 2014.08.21 2014.08.24 2014.08.25 2014.08.26 2014.08.27 2014.08.28 2014.08.31 2014.09.01 2014.09.02 2014.09.03 2014.09.04 2014.09.08 2014.09.09 `:/d/d1/data`:/d/d2/data`:/d/d3/data`:/d/d4/data ((`:/d/d1/data;2014.08.21 2014.08.25 2014.09.02); (`:/d/d2/data;2014.08.18 2014.08.26 2014.09.03); (`:/d/d3/data;2014.08.19 2014.08.27 2014.08.31 2014.09.04 2014.09.08); (`:/d/d4/data;2014.08.20 2014.08.24 2014.08.28 2014.09.01 2014.09.09))

"--- partition query: query, segment, partition, result ---" (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d1/data
2014.08.21 +(,`tp)!,,15.42632

"--- partition query: query, segment, partition, result ---" (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d1/data
2014.08.25
+(,`tp)!,,15.04996

"--- partition query: query, segment, partition, result ---" (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d1/data
2014.09.02
+(,`tp)!,,14.16648

"--- partition query: query, segment, partition, result ---" (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d2/data 2014.08.18
+(,`tp)!,,14.16883</code></pre>
‚Ä¶ (some output removed for brevity) ‚Ä¶
<pre class="highlight"><code class="language-q">"--- partition query: query, segment, partition, result ---" (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d3/data
2014.09.08
+(,`tp)!,,15.59198

"--- partition query: query, segment, partition, result ---" (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d4/data 2014.08.20
+(,`tp)!,,15.2657

"--- partition query: query, segment, partition, result ---" (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d4/data
2014.08.24 +(,`tp)!,,14.75603

"--- partition query: query, segment, partition, result ---" (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d4/data 2014.08.28
+(,`tp)!,,14.37194

"--- partition query: query, segment, partition, result ---" (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d4/data 2014.09.01
+(,`tp)!,,13.25797

"--- partition query: query, segment, partition, result ---" (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d4/data 2014.09.09
+(,`tp)!,,14.98316

"--- query plan result ---" (+(,`tp)!,,14.16883;+(,`tp)!,,15.05272;+(,`tp)!,,15.2657;+(,`tp)!,,15.42632; +(,`tp)!,,14.75603;+(,`tp)!,,15.04996;+(,`tp)!,,15.69218;+(,`tp)!,,15.53095; +(,`tp)!,,14.37194;+(,`tp)!,,14.32488;+(,`tp)!,,13.25797;+(,`tp)!,,14.16648; +(,`tp)!,,15.58938;+(,`tp)!,,16.1427;+(,`tp)!,,15.59198;+(,`tp)!,,14.98316)

"--- final result ---"
date      | tp
----------| --------
2014.08.18| 14.16883
2014.08.19| 15.05272
2014.08.20| 15.2657
2014.08.21| 15.42632
2014.08.24| 14.75603
2014.08.25| 15.04996
2014.08.26| 15.69218
2014.08.27| 15.53095
2014.08.28| 14.37194
2014.08.31| 14.32488
2014.09.01| 13.25797
2014.09.02| 14.16648
2014.09.03| 15.58938
2014.09.04| 16.1427
2014.09.08| 15.59198
2014.09.09| 14.98316</code></pre>
<p>The previous example was run with no slaves ‚Äì i.e., on a single-threaded q process. Consequently, the queries run sequentially across segments and partitions.</p>
<p>Now observe what happens when we match the number of slaves to the number of segments in our database by invoking q with <code>-s 4</code>.</p>
<pre class="highlight"><code class="language-q">q)select avg tp by date from trade where date in -16#date,sym in syms

"--- query plan: segments/partitions ---" (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) 2014.08.18 2014.08.19 2014.08.20 2014.08.21 2014.08.24 2014.08.25 2014.08.26 2014.08.27 2014.08.28 2014.08.31 2014.09.01 2014.09.02 2014.09.03 2014.09.04 2014.09.08 2014.09.09 `:/d/d1/data`:/d/d2/data`:/d/d3/data`:/d/d4/data ((`:/d/d1/data;2014.08.21 2014.08.25 2014.09.02); (`:/d/d2/data;2014.08.18 2014.08.26 2014.09.03); (`:/d/d3/data;2014.08.19 2014.08.27 2014.08.31 2014.09.04 2014.09.08); (`:/d/d4/data;2014.08.20 2014.08.24 2014.08.28 2014.09.01 2014.09.09))

"--- partition query: query, segment, partition, result ---"
"--- partition query: query, segment, partition, result ---"
"--- partition query: query, segment, partition, result ---"
(`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d1/data
2014.08.21

"--- partition query: query, segment, partition, result ---" (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d4/data
2014.08.20 (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d3/data
2014.08.19 (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d2/data
2014.08.18
+(,`tp)!,,15.55121

"--- partition query: query, segment, partition, result ---" (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d3/data
2014.08.27
+(,`tp)!,,15.47055 +(,`tp)!,,15.21819

"--- partition query: query, segment, partition, result ---"
"--- partition query: query, segment, partition, result ---" (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d2/data
2014.08.26 (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d4/data
2014.08.24
+(,`tp)!,,14.81711
"--- partition query: query, segment, partition, result ---" (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d1/data
2014.08.25
+(,`tp)!,,14.92875

"--- partition query: query, segment, partition, result ---" +(,`tp)!,,16.07275
"--- partition query: query, segment, partition, result ---" (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d3/data
2014.08.31
+(,`tp)!,,15.55499 (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d4/data
2014.08.28

"--- partition query: query, segment, partition, result ---" (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d2/data
2014.09.03
+(,`tp)!,,13.43061 +(,`tp)!,,15.29159 +(,`tp)!,,12.64993

"--- partition query: query, segment, partition, result ---"
"--- partition query: query, segment, partition, result ---"
"--- partition query: query, segment, partition, result ---" (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d3/data
`:/d/d4/data
2014.09.04
2014.09.01
+(,`tp)!,,176.6311
`:/d/d1/data
2014.09.02
+(,`tp)!,,151.7784
+(,`tp)!,,13.67089

"--- partition query: query, segment, partition, result ---" (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d4/data
2014.09.09
+(,`tp)!,,179.799

"--- partition query: query, segment, partition, result ---" (`trade;,(in;`sym;`syms);(`symbol$())!`symbol$();(,`tp)!,(avg;`tp)) `:/d/d3/data
2014.09.08
+(,`tp)!,,193.7031
+(,`tp)!,,48.75286

"--- query plan result ---" (+(,`tp)!,,15.47055;+(,`tp)!,,15.55121;+(,`tp)!,,15.21819;+(,`tp)!,,14.81711; +(,`tp)!,,16.07275;+(,`tp)!,,15.29159;+(,`tp)!,,15.55499;+(,`tp)!,,14.92875; +(,`tp)!,,12.64993;+(,`tp)!,,13.43061;+(,`tp)!,,13.67089;+(,`tp)!,,151.7784; +(,`tp)!,,176.6311;+(,`tp)!,,179.799;+(,`tp)!,,193.7031;+(,`tp)!,,48.75286)

"--- final result ---"
date      | tp
----------| --------
2014.08.18| 15.47055
2014.08.19| 15.55121
2014.08.20| 15.21819
2014.08.21| 14.81711
2014.08.24| 16.07275
2014.08.25| 15.29159
2014.08.26| 15.55499
2014.08.27| 14.92875
2014.08.28| 12.64993
2014.08.31| 13.43061
2014.09.01| 13.67089
2014.09.02| 151.7784
2014.09.03| 176.6311
2014.09.04| 179.799
2014.09.08| 193.7031
2014.09.09| 48.75286</code></pre>
<p>Here the output from four slaves running concurrently is interleaved. One slave executes for each segment, with each slave executing the query on its segment sequentially across its partitions. We see how an appropriately configured server can take advantage of available I/O bandwidth to speed up query execution using segments and slaves.</p>
<h2 id="145-utilities-for-splaying-and-partitioning">14.5 Utilities for Splaying and Partitioning</h2>
<p>The <a href="https://code.kx.com/q/ref/dotq/"><code>.Q</code> namespace</a> contains useful functions for creating and maintaining splayed and partitioned tables. Although KX disclaims support for customer use, nearly everyone uses them and they have become <em>de facto</em> standard. In this section, we describe the more commonly used entries and demonstrate their use.</p>
<h3 id="1451-qqp">14.5.1 <code>.Q.qp</code></h3>
<p>The unary <a href="https://code.kx.com/q/ref/dotq/#qqp-is-partitioned"><code>.Q.qp</code></a> asks the residency of its table argument. It returns <code>1b</code> if its argument is a partitioned table mapped into memory, <code>0b</code> if it is splayed and 0 for anything else. In a fresh <code>/db</code>,</p>
<pre class="highlight"><code class="language-q">q)`:/db/tser set ([] c1:1 2 3; c2:1.1 2.2 3.3)
_
q)`:/db/tsplay/ set ([] c1:1 2 3; c2:1.1 2.2 3.3)
_
q)`:/db/2015.01.01/tpart/ set ([] c1:1 2 3; c2:1.1 2.2 3.3)
_
q)\l /db
q).Q.qp tser
0
q).Q.qp tsplay
0b
q).Q.qp tpart
1b</code></pre>
<h3 id="1452-qen">14.5.2 <code>.Q.en</code></h3>
<p>The binary <a href="https://code.kx.com/q/ref/dotq/#qen-enumerate-varchar-cols"><code>.Q.en</code></a> takes a symbolic file handle of a root directory as its first argument and a table as its second argument. As a side effect, it creates a list sym comprising the unique items across all symbol columns and writes it to an eponymous file in the specified directory. It returns a table obtained from the original table by enumerating its symbol column(s) over sym.</p>
<p>In a fresh <code>/db</code>,</p>
<pre class="highlight"><code class="language-q">q)sym
'sym
q).Q.en[`:/db;] ([] s:`a`b`v;v:10 20 30)
s v
----
a 10
b 20
v 30
q)sym
`a`b`v
q)get `:/db/sym
`a`b`v</code></pre>
<p>Here is more detail on the actual sequence of operations for <code>.Q.en</code>.</p>
<ul>
<li>The variable <code>sym</code> is created (in memory) by loading the file <code>sym</code> from the specified root, should such exist, or as the empty symbol list if not. An existing <code>sym</code> variable in the workspace is <strong>overwritten</strong> in this step.</li>
<li>All symbol columns of (a copy of) the table are conditionally enumerated over the sym list.</li>
<li>The <code>sym</code> variable is serialized to the specified root directory.</li>
<li>The enumerated table is returned from the function application.</li>
</ul>
<h3 id="1453-qpv">14.5.3 <code>.Q.pv</code></h3>
<p>The variable <a href="https://code.kx.com/q/ref/dotq/#qpv-modified-partition-values"><code>.Q.pv</code></a> is a list containing the values of the partition domain ‚Äì i.e., the values corresponding to the slice directories actually found in the root. This is useful if you need to iterate over all the partitions.</p>
<p>In a fresh <code>/db</code>,</p>
<pre class="highlight"><code class="language-q">q)`:/db/2015.01.01/t/ set ([] c1:1 2 3; c2:1.1 2.2 3.3)
_
q)`:/db/2015.01.03/t/ set ([] c1:4 5; 4.4 5.5)
`_
q)\l /db
q).Q.pv
2015.01.01 2015.01.03</code></pre>
<h3 id="1454-qind">14.5.4 <code>.Q.ind</code></h3>
<p>As we saw in <a href="#143-partitioned-tables">¬ß14.3</a>, the virtual column <code>i</code> reflects the <strong>relative</strong> row number in a partitioned table. That is, the value of <code>i</code> is the offset of the records within the partition slice. How to retrieve records by absolute within a partition or segmented?</p>
<p>A masochist might use a q expression to determine the partition and relative row for the absolute row number. It is less painful to use the binary <a href="https://code.kx.com/q/ref/dotq/#qind-partitioned-index"><code>.Q.ind</code></a>, whose first argument is a partitioned table and whose second argument is a <strong>list</strong> of long values representing absolute row numbers. The result is a table in memory. You must enlist a single index value.</p>
<p>In a fresh <code>/db</code>,</p>
<pre class="highlight"><code class="language-q">q)`:/db/2015.01.01/t/ set ([] c1:1 2 3; c2:1.1 2.2 3.3)
_
q)`:/db/2015.01.03/t/ set ([] c1:4 5; c2:4.4 5.5)
_
q)\l /db
q)select from t where date within 2015.01.01 2015.01.03
_
q).Q.ind[t;1 3]
date c1 c2
-----------------
2015.01.01 2 2.2
2015.01.03 4 4.4
q).Q.ind[t;enlist 2]
_</code></pre>
<h3 id="1455-qdpft">14.5.5 <code>.Q.dpft</code></h3>
<p>The utility <a href="https://code.kx.com/q/ref/dotq/#qdpft-save-table"><code>.Q.dpft</code></a> assists in creating partitioned and segmented tables by incorporating the functionality of <code>.Q.en</code> at a slightly higher level. It is convenient when partitions are loaded and written out iteratively.</p>
<p>The first parameter is the symbolic file handle of the database root directory. The second parameter is the q data value that will become the name of the partition subdirectory. The third parameter is the name of the field to which the <code>`p#</code> attribute is applied (usually <code>`sym</code> for trades and quotes). The last parameter is the table name.</p>
<p>The <code>.Q.dpft</code> function rearranges (a copy of) the named table so that the partition column is first and the parted column is second, and then splays it into the specified partition in the specified directory. When appropriate, it enumerates all symbol columns over <code>sym</code> and saves a sym list in the root. The result is the table name if the operation is successful.</p>
<p><strong>Notes</strong>:</p>
<ul>
<li>Because the final parameter is a table name, this function cannot be applied to a local variable.</li>
<li>The table columns must be simple or compound lists.</li>
<li>The source table cannot be a keyed table.</li>
</ul>
<p>We recycle our favorite example, using <code>.Q.dpft</code> to write it as a partitioned table into a fresh <code>/db</code>.</p>
<pre class="highlight"><code class="language-q">q)t:([] ti:09:30:00 09:31:00; sym:`ibm`msft; p:101.5 33.5)
q).Q.dpft[`:/db;2015.01.01;`sym;`t]
_
q)t:([] ti:09:31:00 09:32:00; sym:`ibm`msft; p:101 33f)
q).Q.dpft[`:/db;2015.01.02;`sym;`t]
_
q)\l /db
q)select from t where date in 2015.01.01 2015.01.02
_</code></pre>
<h3 id="1456-qfs">14.5.6 <code>.Q.fs</code></h3>
<p>In many cases, splayed tables (as well as partitioned or segmented slices) are too large to fit into memory. Thus, we face the dilemma of how to create such tables, since splaying requires the table to be in memory. The utility <a href="https://code.kx.com/q/ref/dotq/#qfs-streaming-algorithm"><code>.Q.fs</code></a> comes to the rescue by allowing us to process text files in "chunks."</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The chunk size used by <code>.Q.fs</code> is hard-coded. If this does not provide adequate performance may wish to use <a href="https://code.kx.com/q/ref/dotq/#qfsn-streaming-algorithm"><code>.Q.fsn</code></a>, which exposes the chunk size as an additional parameter. The optimal chunk size will vary for each application.</p>
</div>
<p>Loosely speaking, <code>.Q.fs</code> applies a function to the records of a text file in ‚Äúchunks‚Äù instead of processing the entire file in one gulp. It iterates the function over a number of bite-sized record lists. As a trivial warm-up, we create a text file containing the first 100000 non-negative integers, one per line and we chunk the calculation of their squares. (The call to <code>0N!</code> enables us to see the result of each chunk as it is processed.)</p>
<pre class="highlight"><code class="language-q">q)`:/data/L 0: string til 100000
_
q).Q.fs[{0N!x*x};`:/data/L]
0 1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 400 441 484..
560979225 561026596 561073969 561121344 561168721 561216100 561263481 5613108..
2071888324 2071979361 2072070400 2072161441 2072252484 2072343529 2072434576 ..
4536157201 4536291904 4536426609 4536561316 4536696025 4536830736 4536965449 ..
7953785856 7953964225 7954142596 7954320969 7954499344 7954677721 7954856100 ..
588890</code></pre>
<p>While chunking provides no material benefit in this trivial example, it is easily adaptable to larger problems. Assume we have a CSV file containing one day‚Äôs pseudo-trade records (here we manufacture one).</p>
<pre class="highlight"><code class="language-q">q)ct:00:00:00.000+(10*(til 100000))mod `int$24:00:00.000
q)ix:100000?til 2
q)cs:(`ibm`ms) ix
q)cp:(115 25@ix)+-1.+100000?1.
q)trade:([] ti:ct; sym:cs; px:cp)
q)save `:/data/trade.csv
_
q) read0 `:/data/trade.csv
"ti,sym,px"
"00:00:00.000,ibm,114.767"
"00:00:00.010,ibm,114.7566"
"00:00:00.020,ibm,114.1825"
‚Ä¶</code></pre>
<p>We intend to save this data into a kdb+ daily partition slice, but suppose that loading it all at once results in a WSFULL error because our q process has insufficient memory. We demonstrate how to read the CSV file and write out to the partition slice in chunks. For convenience, we wrap the read and symbol enumeration into a function <code>ldchunk</code>. Then we use <code>.Q.fs</code>to iterate <code>ldchunk</code> over the chunks, upserting each result to the partition directory. Again we instrument with <code>0N!</code> to see each chunk result.</p>
<pre class="highlight"><code class="language-q">q)ldchunk:{.Q.en[`:/db] flip `time`sym`price!("TSF";",") 0: x}
q).Q.fs[{0N!.[`:/db/2015.01.01/t/;();,;ldchunk x]}] `:/data/trade.csv
`:/db/2015.01.01/t/
`:/db/2015.01.01/t/
`:/db/2015.01.01/t/
‚Ä¶
2638673j</code></pre>
<p>We verify that the partition is properly written.</p>
<pre class="highlight"><code class="language-q">q)\l /db
q)select from t where date=2015.01.01
_</code></pre>
<p>When performance matters in the real world, we would proceed to sort the completed partition slice by time within sym and apply the <code>`p#</code> attribute to the <code>sym</code> column.</p>
<pre class="highlight"><code class="language-q">q)`sym`time xasc `:/db/2015.01.01/t
_
q)@[`:/db/2015.01.01/t; `sym; `p#]
_
q)\l /db
q)meta t
c    | t f a
-----| -----
date | d
time | t
sym  | s p
price| f</code></pre>
<h3 id="1457-qchk">14.5.7 <code>.Q.chk</code></h3>
<p>The utility <a href="https://code.kx.com/q/ref/dotq/#qchk-fill-hdb"><code>.Q.chk</code></a> is a unary function whose argument is the symbolic file handle of a root directory. It examines each partition sub-directory in the root and writes an empty splayed slice of the appropriate form wherever a table is missing in a partition.</p>
<p>We reconstruct our trades and quotes example, this time using <code>.Q.dpft</code>. In a fresh <code>/db</code>,</p>
<pre class="highlight"><code class="language-q">q)t:([] ti:09:30:00 09:31:00; sym:`ibm`msft; p:101 33f)
q).Q.dpft[`:/db;2015.01.01;`sym;`t]
_
q)t:([] ti:09:30:00 09:31:00; sym:`ibm`msft; p:101.5 33.5)
q).Q.dpft[`:/db;2015.01.02;`sym;`t]
_
q)q:([] ti:09:30:00 09:31:00; sym:`ibm`msft;b:100.75 32.75; a:101.25 33.25f)
q).Q.dpft[`:/db;2015.01.01;`sym;`q]
_
q)q:([] ti:09:30:00 09:31:00; sym:`ibm`msft;b:101.25 33.25; a:101.75 33.75)
q).Q.dpft[`:/db;2015.01.02;`sym;`q]
_</code></pre>
<p>Now we introduce two new partitions, each containing a slice for just one table.</p>
<pre class="highlight"><code class="language-q">q)q:([] ti:09:30:00 09:31:00; sym:`ibm`msft;b:101. 33.; a:101.5 34f)
q).Q.dpft[`:/db;2009.01.03;`sym;`q]
_
q) t:([] ti:09:30:00 09:31:00; sym:`ibm`msft; p:102 34f)
q).Q.dpft[`:/db;2009.01.04;`sym;`t]
_</code></pre>
<p>This will make the table <code>q</code> disappear since it is not in the most recent partition; also a query for <code>t</code> fail on 2015.01.03. We use <code>.Q.chk</code> to fix things.</p>
<pre class="highlight"><code class="language-q">q).Q.chk `:/db
()
()
,`:/db/2009.01.04
,`:/db/2009.01.03
q)select from t where date=2015.01.03
ti sym p
--------
q)select from q where date=2015.01.04
ti sym b a
----------</code></pre>
<p>Notice that <code>.Q.chk</code> tells you which partitions it is fixing but not which tables.</p>
<h3 id="1458-qview">14.5.8 <code>.Q.view</code></h3>
<p>The unary <a href="https://code.kx.com/q/ref/dotq/#qview-subview"><code>.Q.view</code></a> is handy when you are executing queries against partitioned or segmented tables. Recall that multiple tables can share the partitioning. The argument of <code>.Q.view</code> is a list of partition values that acts as a filter for all queries against any partitioned table in the database. Otherwise put, the practical effect of applying <code>.Q.view</code> is to add its argument as a constraint in the first sub-phrase of the where clause of every query. This can guard against runaway queries that ask for all historical data, for example.</p>
<p>In the following example, we create a daily partitioned table with three days of data in a fresh <code>/db</code>. By using <code>.Q.view</code> to restrict the view, we reign in the unqualified query.</p>
<pre class="highlight"><code class="language-q">q)`:/db/2015.01.01/t/ set ([] ti:09:30:00 09:31:00; p:101 102f)
`:/db/2015.01.01/t/
q)`:/db/2015.01.02/t/ set ([] ti:09:30:00 09:31:00; p:100 100f)
`:/db/2015.01.02/t/
q)`:/db/2015.01.03/t/ set ([] ti:09:30:00 09:31:00; p:103 104f)
`:/db/2015.01.03/t/

q)\l /db
q).Q.view 2015.01.02 2015.01.03
q)select from t / normally dangerous!
date       ti       p
-----------------------
2015.01.02 09:30:00 100
2015.01.02 09:31:00 100
2015.01.03 09:30:00 103
2015.01.03 09:31:00 104</code></pre>
<p>This is especially useful when you are testing or when you expose large historical databases to users who are prone to forget that they must qualify their queries by date. To reset the default view to all partitions, invoke <code>.Q.view</code> as a nullary.</p>
<pre class="highlight"><code class="language-q">q).Q.view[]
q)select from t / once again gets everything!
date       ti       p
-----------------------
2015.01.01 09:30:00 101
2015.01.01 09:31:00 102
2015.01.02 09:30:00 100
2015.01.02 09:31:00 100
2015.01.03 09:30:00 103
2015.01.03 09:31:00 104</code></pre>
<p>You can use the partition value variable <a href="https://code.kx.com/q/ref/dotq/#qpv-modified-partition-values"><code>.Q.pv</code></a> in the argument to <code>.Q.view</code>.</p>
<pre class="highlight"><code class="language-q">q).Q.view[]
q).Q.pv
2015.01.01 2015.01.02 2015.01.03
q).Q.view -2#.Q.pv
q)select from t / &lt;- normally dangerous
date       ti       p
-----------------------
2015.01.02 09:30:00 100
2015.01.02 09:31:00 100
2015.01.03 09:30:00 103
2015.01.03 09:31:00 104</code></pre>
<h2 id="146-kdb-database">14.6 Kdb Database</h2>
<p>Many kdb+ newcomers find the notion of a kdb+ database shrouded in mystery. In this section, we answer common qbie questions.</p>
<ul>
<li>What is a kdb+ database?</li>
<li>How is it different from an RDBMS?</li>
<li>How do I create a kdb+ database?</li>
<li>How do I startup a kdb+ database?</li>
<li>What happens at startup?</li>
</ul>
<h3 id="1461-comparing-kdb-to-an-rdbms">14.6.1 Comparing kdb+ to an RDBMS</h3>
<p>While q-sql makes certain aspects of a kdb+ database seem familiar to a SQL programmer, the two are quite different under the covers. Folks coming into the world of q and kdb+ from a traditional RDBMS environment may feel as if they have entered the Matrix after taking the red pill from Morpheus. The fundamental differences are:</p>
<ol>
<li>
<p>Kdb+ is based on lists, which are ordered collections allowing duplicates, whereas SQL is based on sets, which are unordered collections of distinct elements.</p>
</li>
<li>
<p>Kdb+ stores data as contiguous items in column lists, whereas an RDBMS stores data as fields within non-contiguous rows. Neo in kdb+ says, ‚ÄúThere are no rows.‚Äù</p>
</li>
<li>
<p>Kdb+ table operations are vector operations on columns, whereas SQL operates on individual fields and rows.</p>
</li>
</ol>
<p>We summarize the major differences between an RDBMS and kdb+ in the following chart.</p>
<table>
<thead>
<tr>
<th></th>
<th>Traditional RDBMS</th>
<th>Kdb+ Database</th>
</tr>
</thead>
<tbody>
<tr>
<td>Table Creation</td>
<td>Tables defined declaratively using DDL and created on disk.</td>
<td>Tables created functionally in the q language.</td>
</tr>
<tr>
<td>Data Persistence</td>
<td>Tables and related metadata held in an opaque repository. Tables are stored by row.</td>
<td>Serialized q entities stored in the O/S file system. No separate table metadata. Tables are stored by column.</td>
</tr>
<tr>
<td>Data Access</td>
<td>Access to stored information is via DDL for metadata and SQL for data. Must retrieve via a query into program.</td>
<td>Data directly accessible in q. q-sql provides query forms for table manipulation.</td>
</tr>
<tr>
<td>Memory Residency</td>
<td>Tables reside on disk; query result sets reside in program memory.</td>
<td>Tables live in memory but can be persisted to disk. Column subsets are page faulted into memory for mapped tables.</td>
</tr>
<tr>
<td>Data Format</td>
<td>Based on sets, which are unordered collection of distinct items. Data is stored in fields within rows, which are not contiguous.</td>
<td>Based on lists, which are ordered collections allowing duplicates. Data is stored as contiguous items in column lists.</td>
</tr>
<tr>
<td>Data Modification</td>
<td>Persisted table modifiable via SQL (<code>INSERT</code>, <code>UPDATE</code>, etc.)</td>
<td>Memory resident tables modifiable via q and q-sql. Persisted table modifiable only with append (<code>upsert</code>)</td>
</tr>
<tr>
<td>Data Programming</td>
<td>SQL is declarative relational. Programs, called stored procedures, written in proprietary procedural language.</td>
<td>Programs written in integrated vector functional language q. Tables are first class entities in q.</td>
</tr>
<tr>
<td>Transactions</td>
<td>Support for transactions via <code>COMMIT</code> and <code>ROLLBACK</code>.</td>
<td>No built-in transaction support.</td>
</tr>
</tbody>
</table>
<h3 id="1462-the-physical-layout-of-a-kdb-database">14.6.2 The Physical Layout of a kdb+ Database</h3>
<p>Here is a Zen koan: What is a kdb+ database? At the most basic level, a kdb+ database is a file system directory (and sub directories) holding q entities. This directory is the <em>root</em> of the database. All constituents of the database are simply q entities saved in files. Database entities either reside at some level under the root or are pointed to from <code>par.txt</code> under the root.</p>
<p>We describe the various kdb+ database components in this section and show examples in the following section. In our descriptions we use <code>/db</code> as our root, but this is arbitrary.</p>
<h3 id="14621-the-sym-file">14.6.2.1 The sym File</h3>
<p>The sym file is an optional serialized q data file containing a list of unique symbols used as the domain for symbol enumeration. Placing the sym file in the root guarantees that it will be loaded into memory at q startup.</p>
<pre class="highlight"><code class="language-txt">/db
    sym ‚Ä¶</code></pre>
<p>There is no strict requirement that there be only one enumeration domain, but conventionally all symbol columns from all tables are enumerated over a single domain sym. The <a href="https://code.kx.com/q/ref/dotq/"><code>.Q</code> utilities</a> that handle symbol enumeration assume this. If you choose to have multiple enumeration domains, be aware that symbols in the resulting enumerated values will act as expected under <code>=</code> but not with <code>~</code> since they have different types. You can resolve the enumerations with <code>value</code> if this is a problem.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Pay very careful attention to the sym file, as it is a single point of failure. Corrupting or losing it will result in all your symbol columns being irresolvable. Good practice is to use conditional enumeration ‚Äì e.g., <code>`:/db/sym?</code> ‚Äì when you enumerate symbols manually or use <code>.Q</code> utilities that do this for you. Always back up your database before operating on the sym file.</p>
</div>
<p>The sym file will not normally be a choke point when loading historical data from an external source into a kdb+ because conditional enumeration (and the <code>.Q</code> utilities) use file locking to mediate concurrent updates. Alternately, if the symbol domain is known in advance, you can load the sym list into memory and use non-conditional enumeration ‚Äì i.e., <code>`sym$</code>. For example, one approach is to create a preprocessing utility in Perl to extract all symbols from the source data, import this as a list in q and place the distinct items in sym. Then create the historical partitions running concurrent processes that use unconditional enumerations. Be mindful that unconditional enumeration fails for a symbol not in the domain.</p>
<h3 id="14622-other-serialized-files-in-root">14.6.2.2 Other Serialized Files in Root</h3>
<p>While it is seldom done in practice (perhaps because few kdb+ programmers are aware of the possibility), it is possible to place any serialized q entity into the root and have it loaded into an eponymous file. This can be a more efficient than using a script to initialize variables in the workspace.</p>
<div class="admonition tip">
<p class="admonition-title">If you use this, don‚Äôt go overboard. Also, it might break <code>.Q.en</code>.</p>
</div>
<pre class="highlight"><code class="language-txt">/db
    [sym]
    var1
    var2
    ‚Ä¶</code></pre>
<p>One type of serialized file that can be initialized in this fashion is a reference table (or keyed table) of modest size (up to millions of rows). Such a table will be loaded into memory in its entirety, so lookups or joins on it will be quite fast.</p>
<p>It is possible to (re)load the entire state of the root context automatically by serializing that directory and loading it in this fashion.</p>
<h3 id="14623-scripts">14.6.2.3 Scripts</h3>
<p>A script in the root can hold arbitrary q code that will be loaded upon startup. In particular, functions defined in such a script can be viewed as stored procedures for the database. While it is possible to have multiple q scripts in the root, you probably want precise control over the order in which the scripts are executed. Good practice is to keep in the root one startup script that loads scripts residing in libraries elsewhere.</p>
<pre class="highlight"><code class="language-txt">/db
    ‚Ä¶
    init.q</code></pre>
<h3 id="14624-splayed-tables">14.6.2.4 Splayed Tables</h3>
<p>Reference tables of intermediate size (up to tens of millions of rows) can be splayed under the root. <a href="https://code.kx.com/q/kb/splayed-tables/">Splayed table</a> directories must be immediately under the root.</p>
<pre class="highlight"><code class="language-txt">/db
    [sym]
    ‚Ä¶
    /splay1
    /splay2
    ‚Ä¶</code></pre>
<p>Because splayed tables are mapped and columns are page-faulted into memory as needed, no more than a few columns will be simultaneously resident in the workspace. Assuming that the server has adequate memory available to kdb+, q should expect to find recently accessed columns cached by the OS. In this scenario, performance of lookups against splayed tables can be close to that of in-memory tables.</p>
<h3 id="14625-partitioned-tables">14.6.2.5 Partitioned Tables</h3>
<p>The <a href="https://code.kx.com/q/kb/partition/">partition directories</a> of non-segmented tables must be immediately under the root. Every partition directory contains a subdirectory for each table sharing the partition; in each subdirectory is the splayed slice for that table's partition value. For example, for daily partitioned trades and quotes, a day‚Äôs directory would contain a splayed directory for that day‚Äôs trades and another splayed directory for that day‚Äôs quotes.</p>
<pre class="highlight"><code class="language-txt">/db
    [sym]
    ‚Ä¶
    /part1
        /trade
        /quote
    /part2
        /trade
        /quote ‚Ä¶</code></pre>
<p>There need not be a directory for every partition value but the partition directories must have a uniform structure. That is, a partition value having <strong>any</strong> entry must contain splayed directories for <strong>all</strong> tables in the partition. Splay an empty schema for a table having no records for a partition value.</p>
<h3 id="14626-segmented-tables">14.6.2.6 Segmented Tables</h3>
<p>In contrast to normal partitioned tables (i.e., non-segmented tables) in which all records live under the root, no records of a segmented table can reside under the root. Instead, the root contains a text file <code>par.txt</code> having one entry per line. Each entry represents an OS path for a segment directory containing the data in that segment; symlinks are permissible.</p>
<p>Each segment directory contains partition directories whose structure is completely analogous to that of a regular partitioned table. There is one directory per partition value and beneath that, one sub-directory per table. Note that depending on the nature of the segmentation, multiple segment directories may contain directories for the same partition value. The previous restriction about consistency across partition directories applies to segments.</p>
<pre class="highlight"><code class="language-txt">/db
    [sym]
    ‚Ä¶
    par.txt
    ‚Ä¶
== drive 1 =============
/seg1
    /part1
    /part2
    ‚Ä¶
== drive 2 =============
/seg2
    /parta
    /partb
    ‚Ä¶
== ‚Ä¶ =============</code></pre>
<h3 id="1463-creating-and-populating-a-kdb-database">14.6.3 Creating and Populating a kdb+ Database</h3>
<p>Here we demonstrate how to create and populate various kdb+ database configurations. Although the examples are simplistic, they cover most common situations.</p>
<p>There are no wizards for laying out and populating a kdb+ database. Instead, you must write each component in the correct form to the correct location. There are utilities to help with the process but it is your responsibility to ensure that everything is valid. Improperly structured directories or incorrectly written data files will generate run-time errors the first time q code attempts to access them.</p>
<p>Once you have created a kdb+ database, start a q process pointing at the root directory of the database to attach it to the session. Alternately, in a running q instance you can issue <code>\l</code> on the root directory.</p>
<h3 id="14631-what-happens-at-startup">14.6.3.1 What Happens at Startup?</h3>
<p>This question has a deceptively simple answer. When you point q at a directory or file, it applies a single rule:</p>
<p>Whatever it recognizes as its own, it does.</p>
<p>Thus, a serialized q entity is loaded; a splayed, partitioned or segmented table is mapped; a script is executed.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Almost anything that q does not recognize causes it to abort that portion of startup. In particular, if q discovers foreign or undecipherable files in splayed, partitioned or segmented directories, it will not map the tables contained there. Even unexpected hidden files (e.g., those written by the Mac OS Finder) will abort the map.</p>
</div>
<p>When you point q startup at a directory, that directory becomes the root directory for the kdb+ database and also the current working directory for the OS. We shall refer to this scenario as <em>kdb+ startup</em> to distinguish it from an arbitrary q session. We shall cover the items that Kdb+ startup finds in the order that it handles them.</p>
<ol>
<li>
<p>Serialized q entities</p>
</li>
<li>
<p>Splayed tables</p>
</li>
<li>
<p>Partitioned or segmented tables</p>
</li>
<li>
<p>Scripts</p>
</li>
</ol>
<div class="admonition info">
<p class="admonition-title">File handles that are not fully qualified ‚Äì i.e., relative paths ‚Äì are interpreted relative to the q home directory.</p>
</div>
<h3 id="14632-serialized-q-entities">14.6.3.2 Serialized q Entities</h3>
<p>When kdb+ startup recognizes a serialized q data file, it loads that data into an eponymous variable. The canonical example is the sym file in the root, containing the serialized list of (unique) symbols in the enumeration domain for (all) symbol columns. Multiple serialized entities are loaded in the order in which the OS file system lists them.</p>
<p>In our first example, we manually write out a sym file, exit q and then start kdb+ pointing at the root.</p>
<pre class="highlight"><code class="language-q">q)`:/db/sym set `a`b`c`z`x`y
`:/db/sym
q)\\</code></pre>
<pre class="highlight"><code class="language-bash">$q /db</code></pre>
<pre class="highlight"><code class="language-q">q)sym
`a`b`c`z`x`y</code></pre>
<p>Starting with a fresh <code>/db</code>, we place a defined ‚Äúconstant,‚Äù a utility function and a serialized keyed table in the root.</p>
<pre class="highlight"><code class="language-q">q) `:/db/LIFE set 42
`:/db/LIFE
q)`:/db/f set {x*y}
`:/db/f
q)`:/db/lookup set ([s:`a`b`c] v:1 2 3)
`:/db/lookup
q)\\</code></pre>
<pre class="highlight"><code class="language-bash">$q /db</code></pre>
<pre class="highlight"><code class="language-q">q)LIFE
_
q)f
_
q)lookup
_</code></pre>
<p>As of this writing (Sep 2015), q will not look for serialized data in directories other than the root. Nor will it automatically load serialized data whose file names have extensions. However, you can load such data files manually using <code>\l</code> or <code>get</code>.</p>
<h3 id="14633-splayed-tables">14.6.3.3 Splayed Tables</h3>
<p>When kdb+ startup finds a subdirectory immediately beneath the root that it recognizes as a splayed table, it maps the table into memory. All symbol columns must be enumerated for a table to be splayed. Ensure that the sym file is in the root directory if you do not use a built-in utility.</p>
<p>Starting with a fresh <code>/db</code>, we splay two tables under the root. The first does not have symbol columns; the second does.</p>
<pre class="highlight"><code class="language-q">q)`:/db/tref/ set ([] c1:1 2 3; c2:1.1 2.2 3.3)
_
q)`:/db/cust/ set .Q.en[`:/db;] ([] sym:`ibm`msft`goog; name:`oracle`microsoft`google)
_
q)\\</code></pre>
<pre class="highlight"><code class="language-bash">$q /db</code></pre>
<pre class="highlight"><code class="language-q">q)select from tref
c1 c2
_
q)select from cust
_</code></pre>
<h3 id="14634-partitioned-tables">14.6.3.4 Partitioned Tables</h3>
<p>If kdb+ startup finds subdirectories immediately beneath the root whose names constitute valid partition values, it examines them for splayed tables comprising partition slices. Valid partitioned tables are mapped. The presence of partitioned tables is independent of the presence of (plain) splayed tables. Partitioned tables and segmented tables are mutually exclusive.</p>
<div class="admonition tip">
<p class="admonition-title">All symbol columns in every partition slice must be enumerated, customarily over a file sym in the root. Ensure that the sym file is in the root directory if you do not use the built-in utilities.</p>
</div>
<p>We recreate the previous example in which multiple tables share a daily partition in a fresh <code>/db</code>.</p>
<pre class="highlight"><code class="language-q">q)`:/db/2015.01.01/t/ set .Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`ibm`msft; p:101 33f)
_
q)`:/db/2015.01.02/t/ set .Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`ibm`msft; p:101.5 33.5)
_
q)`:/db/2015.01.01/q/ set .Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`ibm`msft; b:100.75 32.75; a:101.25 33.25f)
_
q)`:/db/2015.01.02/q/ set .Q.en[`:/db;] ([] ti:09:30:00 09:30:00; sym:`ibm`msft; b:101.25 33.25; a:101.75 33.75)
_
q)\\</code></pre>
<pre class="highlight"><code class="language-bash">$ q /db</code></pre>
<pre class="highlight"><code class="language-q">q)\l /db
q
q)select from t where date within 2015.01.01 2015.01.02
-
q)select from q where date within 2015.01.01 2015.01.02
_</code></pre>
<h3 id="14635-segmented-tables">14.6.3.5 Segmented Tables</h3>
<p>When kdb+ startup finds a <code>par.txt</code> file in the root, it interprets each line as a segment location and it examines the locations for valid segments of partitioned tables. Valid tables are mapped.</p>
<div class="admonition tip">
<p class="admonition-title">Ensure that the segment directories are not located under the root; otherwise you will relive the table scene in the first <em>Alien</em> movie.</p>
</div>
<p>The presence of segmented tables is independent of the presence of plain splayed tables. Segmented tables and partitioned tables are mutually exclusive. All symbol columns in every segment must be enumerated. Ensure that the (common) sym file is in the root directory.</p>
<p>We recreate the previous example from <a href="#144-segmented-tables">¬ß14.4</a> in which multiple tables share segmentation by symbol range. In fresh directories <code>/am</code>, <code>/nz</code> and <code>/db</code>,</p>
<pre class="highlight"><code class="language-q">q)extr:{[t;r] select from t where (`$1#'string sym) within r}
q)t:.Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`ibm`t; p:101 17f)
q)q:.Q.en[`:/db;] ([] ti:09:29:59 09:29:59 09:30:00; sym:`ibm`t`ibm; b:100.75 16.9 100.8;a:101.25 17.1 101.1)

q)`:/am/2015.01.01/t/ set extr[t;`a`m]
_
q)`:/nz/2015.01.01/t/ set extr[t;`n`z]
_
q)`:/am/2015.01.01/q/ set extr[q;`a`m]
_
q)`:/nz/2015.01.01/q/ set extr[q;`n`z]
_
q)t:.Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`t`ibm; p:17.1 100.9)
q)q:.Q.en[`:/db;] ([] ti:09:29:59 09:29:59 09:30:00; sym:`t`ibm`t;b:17 100.7 17.1;a:17.2 101.25 17.25)

q)`:/am/2015.01.02/t/ set extr[t;`a`m]
_
q)`:/nz/2015.01.02/t/ set extr[t;`n`z]
_
q)`:/am/2015.01.02/q/ set extr[q;`a`m]
_
q)`:/nz/2015.01.02/q/ set extr[q;`n`z]
_
q)`:/db/par.txt 0: ("/am"; "/nz")
`:/db/par.txt
q)\\</code></pre>
<pre class="highlight"><code class="language-bash">$q</code></pre>
<pre class="highlight"><code class="language-q">q)\l /db
q)select from t where date within 2015.01.01 2015.01.02
_
q)select from q where date within 2015.01.01 2015.01.02
_</code></pre>
<h3 id="14636-scripts">14.6.3.6 Scripts</h3>
<p>Files with extension <code>.q</code> are interpreted as q scripts; those with extension <code>.k</code> as k scripts. Scripts found in the root are loaded and executed in alphabetical order. You will probably want better control over the order of execution, so it is best to have in the root a single script that loads other scripts in the desired sequence.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An invalid expression in a script causes the entire script load to abort. Locating the invalid entry can be non-trivial since by default console display is suppressed during load. Judicious use of <code>0N!</code> can be helpful. Sometimes using binary search using block comments is an effective approach to locating the offending line. Bottom line: keep scripts short!</p>
</div>
<p>In our first example, we initialize the workspace using a startup script <code>/db/init.q</code> that we create from q (because we can). You could do it in any text editor.</p>
<pre class="highlight"><code class="language-q">q)`:/db/init.q 0: ("LIFE:42";"f:{x*y}";"lookup:([s:`a`b`c] v:1 2 3)")
`:/db/init.q
q)\\
$q /db
q)LIFE
_
q)f
_
q)lookup
_</code></pre>
<p>Since scripts are loaded as the last step in kdb+ startup, any loaded script can rely on startup, serialized variables and mapped tables bring present. For example, in a fresh <code>/db</code> we create a splayed table and a startup script from within q and then run the script at startup.</p>
<pre class="highlight"><code class="language-q">q)`:/db/cust/ set .Q.en[`:/db;] ([] sym:`ibm`msft`goog;name:`oracle`microsoft`google)
_
q)`:/db/init.q 0: ("sym"; "show select from cust")
_
q)\\</code></pre>
<pre class="highlight"><code class="language-bash">$q /db</code></pre>
<pre class="highlight"><code class="language-q">`ibm`msft`goog`oracle`microsoft`google
sym  name
--------------
ibm  oracle
msft microsoft
goog google
q)</code></pre>
<p>Now we demonstrate a script that loads other scripts. Start with a fresh <code>/db</code>. We write out a script having a library function (you could do it in a text editor) and then load that script from <code>init.q</code> at startup.</p>
<pre class="highlight"><code class="language-q">q)`:/scripts/expr.q 0: enlist ".jab.lib.expr.subst:{x@y}"
_
q)`:/db/init.q 0: enlist "\\l /scripts/expr.q"
_
q)\\</code></pre>
<pre class="highlight"><code class="language-bash">$q /db</code></pre>
<pre class="highlight"><code class="language-q">q).jab.lib.expr.subst
{x@y}</code></pre>
<h2 id="147-putting-it-all-together">14.7 Putting It All Together</h2>
<p>In this section, we combine the various constituents of a kdb+ database demonstrated in the previous sections to give two archetypal examples. The first has partitioned tables; the second has segmented tables.</p>
<h3 id="1471-partitioned-database">14.7.1 Partitioned Database</h3>
<p>To construct our partitioned database, we combine the steps in previous sections to obtain the following meta-script. (We assume that the scripts in <code>/lib</code> already exist.)</p>
<pre class="highlight"><code class="language-q">/ create serialized variables
`:/db/LIFE set 42
`:/db/f set {x*y}
`:/db/lookup set ([s:`a`b`c] v:1 2 3)

/ create splayed tables
`:/db/tref/ set ([] c1:1 2 3; c2:1.1 2.2 3.3)
`:/db/cust/ set .Q.en[`:/db;] ([] sym:`ibm`msft`goog; name:`:/db/sym?`oracle`microsoft`google)

/create partitioned tables
`:/db/2015.01.01/t/ set .Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`ibm`msft; p:101 33f)
`:/db/2015.01.02/t/ set .Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`ibm`msft; p:101.5 33.5)
`:/db/2015.01.01/q/ set .Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`ibm`msft; b:100.75 32.75; a:101.25 33.25)
`:/db/2015.01.02/q/ set .Q.en[`:/db;] ([] ti:09:30:00 09:30:00; sym:`ibm`msft; b:101.25 33.25; a:101.75 33.75)

/ create load script
`:/db/init.q 0: ("TheUniverse:42";"\\l /lib/math.q";
 "\\l /lib/expr.q")</code></pre>
<p>Now execute this script to create the database. The resulting partitioned database has the following layout.</p>
<pre class="highlight"><code class="language-txt">/db
    sym
    LIFE
    F
    Lookup
    /tref
        .d
        c1
        c2
    /cust
        .d
        sym
        name
    /2009.01.01
        /t
            .d
            ti
            sym
            p
        /q
            .d
            ti
            sym
            b
            a
    /2009.01.02
        /t
            .d
            ti
            sym
            p
        /q
            .d
            ti
            sym
            b
            a
    init.q</code></pre>
<h3 id="1472-segmented-database">14.7.2 Segmented Database</h3>
<p>To construct a segmented database, we combine previous steps to obtain the following meta-script. (We again assume that the scripts in <code>/lib</code> already exist.)</p>
<pre class="highlight"><code class="language-q">/ create serialized variables
`:/db/LIFE set 42
`:/db/f set {x*y}
`:/db/lookup set ([s:`a`b`c] v:1 2 3)

/ create splayed tables
`:/db/tref/ set ([] c1:1 2 3; c2:1.1 2.2 3.3)
`:/db/cust/ set .Q.en[`:/db;] ([] sym:`ibm`msft`goog; name:`oracle`microsoft`google)

/ create segmented tables
extr:{[t;r] select from t where (`$1#'string sym) within r}
t:.Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`ibm`t; p:101 17f)
q:.Q.en[`:/db;] ([] ti:09:29:59 09:29:59 09:30:00; sym:`ibm`t`ibm; b:100.75 16.9 100.8; a:101.25 17.1 101.1)
`:/am/2015.01.01/t/ set extr[t;`a`m]
`:/nz/2015.01.01/t/ set extr[t;`n`z]
`:/am/2015.01.01/q/ set extr[q;`a`m]
`:/nz/20015.01.01/q/ set extr[q;`n`z]
t:.Q.en[`:/db;] ([] ti:09:30:00 09:31:00; sym:`t`ibm; p:17.1 100.9)
q:.Q.en[`:/db;] ([] ti:09:29:59 09:29:59 09:30:00; sym:`t`ibm`t; b:17 100.7 17.1;a:17.2 101.25 17.25)
`:/am/2015.01.02/t/ set extr[t;`a`m]
`:/nz/2015.01.02/t/ set extr[t;`n`z]
`:/am/2015.01.02/q/ set extr[q;`a`m]
`:/nz/2015.01.02/q/ set extr[q;`n`z]

`:/db/par.txt 0: ("/am"; "/nz")

/ create load script
`:/db/init.q 0: ("TheUniverse:6*7"; "\\l /lib/math.q"; "\\l /lib/expr.q")</code></pre>
<p>Now execute this script to create the database. The resulting partitioned database has the following layout.</p>
<pre class="highlight"><code class="language-txt">/db
    sym
    LIFE
    F
    Lookup
    /tref
        .d
        c1
        c2
    /cust
        .d
        sym
        name
    par.txt
    init.q
== drive 1 ==
/am
    /2009.01.01
        /t
            .d
            ti
            sym
            p
        /q
            .d
            ti
            sym
            b
            a
    /2009.01.02
        /t
            .d
            ti
            sym
            p
        /q
            .d
            ti
            sym
            b
            a
== drive 2 ==
/nz
    /2009.01.01
        /t
            .d
            ti
            sym
            p
        /q
            .d
            ti
            sym
            b
            a
    /2009.01.02
        /t
            .d
            ti
            sym
            p
        /q
            .d
            ti
            sym
            b
            a</code></pre>
<h2 id="148-theres-no-place-like-qhome">14.8 There‚Äôs No Place Like <code>QHOME</code></h2>
<p>We discuss how kdb+ interacts with the OS environment when it looks for files.</p>
<h3 id="1481-the-environment-variables">14.8.1 The Environment Variables</h3>
<p>Three environment variables <code>QHOME</code>, <code>QLIC</code> and <code>QINIT</code> are used by kdb+ at startup.</p>
<p>The environment variable <code>QHOME</code> specifies the directory where kdb+ expects to find the bootstrap file <code>q.k</code>. By default, it also looks there for the license file <code>k4.lic</code>. If <code>QHOME</code> is not defined, kdb+ falls back to <code>$HOME/q</code> for Unix-based systems and <code>c:\q</code> for Windows.</p>
<p>The environment variable <code>QLIC</code> overrides the default location for the license file. If <code>QLIC</code> is not defined, kdb+ falls back to <code>QHOME</code> (or its fallback).</p>
<p>The environment variable <code>QINIT</code> specifies the name of the file that is executed immediately after the load of <code>q.k</code>. If <code>QINIT</code> is not defined, kdb+ attempts to load the file <code>q.q</code> from <code>QHOME</code>. If <code>QHOME</code> is not defined or <code>q.q</code> is not found, no error is reported.</p>
<div class="admonition info">
<p class="admonition-title">The file in <code>QINIT</code> is executed in the root context (i.e., <code>\d</code>).</p>
</div>
<h3 id="1482-q-in-da-hood">14.8.2 q in da hood</h3>
<p>Upon startup, the current directory is the directory from which the q session was started.</p>
<p>After startup, an easy way to see where in the file system the q executable resides is to use a function such as the nullary <code>whereami</code> below. Recall that the command <code>\cd</code> acts like the OS <code>cd</code> command by returning the current working directory.</p>
<pre class="highlight"><code class="language-q">whereami:{-1 "cd ~ ",system "cd";}</code></pre>
<p>Loading a script that resides elsewhere does not in itself change the current directory; of course, if that script executes a <code>\cd</code> then the current directory may change. In particular, the current directory is not temporarily changed to the location of the target script.</p>
<p>Loading a database, either as part of the startup invocation or via a <a href="https://code.kx.com/q/basics/syscmds/#l-load-file-or-directory"><code>\l</code></a> command, changes the current directory to the database root. All subsequent relative access is based from there. This is important when starting q with <a href="https://code.kx.com/q/basics/cmdline/#-u-usr-pwd-local"><code>-u</code></a> as it determines the file hierarchy visibility.</p>
<p>When asked to load a file whose name is not fully qualified, q first searches the current directory. If the file is not found, it then searches <code>QHOME</code> if it is defined and <code>$HOME</code> otherwise.</p>
                


                
              
              
                


              
            </article>
            
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))for(var set of document.querySelectorAll("[data-tabs]")){var labels=set.querySelectorAll(":scope > label");e:for(var tab of tabs)for(var label of labels)if(label.innerText.trim()===tab){var input=label.previousElementSibling;input.checked=!0;break e}}</script>

          </div>
        </div>
        
          
        
      
                </div>
            </section>
        
            <section class="chapter" id="chapter-7">
                <div class="chapter-header">
                    <h1 class="chapter-title">2. Basic Data Types: Atoms¬∂</h1>
                    <div class="chapter-meta">
                        <span>üìñ Source: <a href="https://code.kx.com/q4m3/2_Basic_Data_Types_Atoms/">https://code.kx.com/q4m3/2_Basic_Data_Types_Atoms/</a></span>
                        <span>üìù 4190 words</span>
                        
                    </div>
                </div>
                <div class="chapter-content">
                    
        <div class="md-main__inner md-grid">
          
            
              
              
            
            
              
              
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                
                <h1 id="2-basic-data-types-atoms">2. Basic Data Types: Atoms</h1>
<h2 id="20-overview">2.0 Overview</h2>
<p>All data is ultimately built from atoms. An <em>atom</em> is an irreducible value of a specific <a href="https://code.kx.com/q/basics/datatypes/">data type</a>. The basic data types in q correspond mostly to those of traditional programming languages with additional date- and time-related types that facilitate time series. The tables below summarize the basic data types, giving the corresponding types in SQL, Java and C#. Other data types, including enumerations and functions, will be covered when they are discussed in later sections.</p>
<table>
<thead>
<tr>
<th>Q</th>
<th>SQL</th>
<th>Java</th>
<th>.Net</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>Boolean</td>
<td>Boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>guid</td>
<td></td>
<td>UUID</td>
<td>GUID</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
<td>Byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Smallint</td>
<td>Short</td>
<td>Int16</td>
</tr>
<tr>
<td>int</td>
<td>Int</td>
<td>Integer</td>
<td>Int32</td>
</tr>
<tr>
<td>long</td>
<td>Bigint</td>
<td>Long</td>
<td>Int64</td>
</tr>
<tr>
<td>real</td>
<td>Real</td>
<td>Float</td>
<td>Single</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
<td>Double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Char(1)</td>
<td>Character</td>
<td>Char</td>
</tr>
<tr>
<td>symbol</td>
<td>Varchar</td>
<td>String</td>
<td>(String)</td>
</tr>
<tr>
<td>date</td>
<td>Date</td>
<td>Date</td>
<td></td>
</tr>
<tr>
<td>timestamp</td>
<td></td>
<td>Timestamp</td>
<td>DateTime</td>
</tr>
<tr>
<td>timespan</td>
<td></td>
<td>Timespan</td>
<td>TimeSpan</td>
</tr>
<tr>
<td>minute</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>second</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>time</td>
<td>Time</td>
<td>Time</td>
<td>TimeSpan</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="admonition-title">Type names</p>
<p>The words under the q heading ‚Äì boolean, short, int, etc. ‚Äì are not reserved in q, so they are not displayed in a special font in this text. They do have special meaning when used as name arguments in some operators, so do not use them as names.</p>
</div>
<p>The next table collects the important information about q data types. We shall refer to this in subsequent sections.</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Size</th>
<th>CharType</th>
<th>NumType</th>
<th>Notation</th>
<th>Null Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>1</td>
<td>b</td>
<td>1</td>
<td><code>1b</code></td>
<td><code>0b</code></td>
</tr>
<tr>
<td>byte</td>
<td>1</td>
<td>x</td>
<td>4</td>
<td><code>0x26</code></td>
<td><code>0x00</code></td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>h</td>
<td>5</td>
<td><code>42h</code></td>
<td><code>0Nh</code></td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>i</td>
<td>6</td>
<td><code>42i</code></td>
<td><code>0Ni</code></td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>j</td>
<td>7</td>
<td><code>42j</code></td>
<td><code>0Nj</code></td>
</tr>
<tr>
<td>real</td>
<td>4</td>
<td>e</td>
<td>8</td>
<td><code>4.2e</code></td>
<td><code>0Ne</code></td>
</tr>
<tr>
<td>float</td>
<td>8</td>
<td>f</td>
<td>9</td>
<td><code>4.2</code></td>
<td><code>0n</code></td>
</tr>
<tr>
<td>char</td>
<td>1</td>
<td>c</td>
<td>10</td>
<td><code>"z"</code></td>
<td><code>" "</code></td>
</tr>
<tr>
<td>symbol</td>
<td>*</td>
<td>s</td>
<td>11</td>
<td><code>`zaphod</code></td>
<td><code>`</code></td>
</tr>
<tr>
<td>timestamp</td>
<td>8</td>
<td>p</td>
<td>12</td>
<td><code>2015.01.01T00:00:00.000000000</code></td>
<td><code>0Np</code></td>
</tr>
<tr>
<td>month</td>
<td>4</td>
<td>m</td>
<td>13</td>
<td><code>2006.07m</code></td>
<td><code>0Nm</code></td>
</tr>
<tr>
<td>date</td>
<td>4</td>
<td>d</td>
<td>14</td>
<td><code>2006.07.21</code></td>
<td><code>0Nd</code></td>
</tr>
<tr>
<td>(datetime)</td>
<td>8</td>
<td>z</td>
<td>15</td>
<td><code>2006.07.21T09:13:39</code></td>
<td><code>0Nz</code></td>
</tr>
<tr>
<td>timespan</td>
<td>8</td>
<td>n</td>
<td>16</td>
<td><code>12:00:00.000000000</code></td>
<td><code>0Nn</code></td>
</tr>
<tr>
<td>minute</td>
<td>4</td>
<td>u</td>
<td>17</td>
<td><code>23:59</code></td>
<td><code>0Nu</code></td>
</tr>
<tr>
<td>second</td>
<td>4</td>
<td>v</td>
<td>18</td>
<td><code>23:59:59</code></td>
<td><code>0Nv</code></td>
</tr>
<tr>
<td>time</td>
<td>4</td>
<td>t</td>
<td>19</td>
<td><code>09:01:02.042</code></td>
<td><code>0Nt</code></td>
</tr>
<tr>
<td>enumeration</td>
<td></td>
<td></td>
<td>20+</td>
<td><code>`sym$`kx</code></td>
<td></td>
</tr>
<tr>
<td>table</td>
<td></td>
<td></td>
<td>98</td>
<td><code>([] c1:`a`b`c; c2:10 20 30)</code></td>
<td></td>
</tr>
<tr>
<td>dictionary</td>
<td></td>
<td></td>
<td>99</td>
<td><code>`a`b`v!10 20 30</code></td>
<td></td>
</tr>
<tr>
<td>function</td>
<td></td>
<td></td>
<td>100</td>
<td><code>{x}</code></td>
<td></td>
</tr>
<tr>
<td>nil item</td>
<td></td>
<td></td>
<td>101</td>
<td><code>::</code></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="21-integer-data">2.1 Integer Data</h2>
<p>Integer data types are ubiquitous in programming. There are three integer types in q.</p>
<h3 id="211-long">2.1.1 long</h3>
<p>In q versions 3.0 and later, the basic integer type is a signed eight-byte integer, called <em>long</em>. A literal is identified as a long by the fact that it contains only numeric digits, with an optional leading minus sign, and <strong>no</strong> decimal point. It may also have an optional trailing type indicator <code>j</code> indicating it is a long and not another integer type. Here is a typical long integer value.</p>
<pre class="highlight"><code class="language-q">q)42
42</code></pre>
<p>Observe that the type indicator <code>j</code> is accepted but redundant.</p>
<pre class="highlight"><code class="language-q">q)42j
42</code></pre>
<div class="admonition important">
<p class="admonition-title">Default integer type</p>
<p>In q versions 2.8 and earlier the default integer type when no type indicator was given was the four-byte int. Any 2.* long values given with <code>j</code> will carry over to 3.* but if you intend a four-byte value you must now explicitly include the type indicator <code>i</code>.</p>
</div>
<h3 id="212-short-and-int">2.1.2 short and int</h3>
<p>The two smaller signed integer data types are <em>short</em> and <em>int</em>. The short type represents a two-byte signed integer and requires the trailing type indicator <code>h</code>. For example,</p>
<pre class="highlight"><code class="language-q">q)-123h
_</code></pre>
<p>Similarly, the int type represents a four-byte signed integer and requires the trailing type indicator <code>i</code>.</p>
<pre class="highlight"><code class="language-q">q)1234567890i
_</code></pre>
<div class="admonition important">
<p class="admonition-title">Type promotion</p>
<p>Type promotion is performed automatically in arithmetic operations. However, for a homogenous list of atoms of "wide" type, should a narrower type be presented for update or append in place, the narrow type will not be automatically promoted and an error will result. This may be unintuitive in the context of other type promotion, but it will make sense for table columns.</p>
</div>
<h2 id="22-floating-point-data">2.2 Floating Point Data</h2>
<p>Single- and double-precision floating-point data types are supported. Double precision is more common.</p>
<h3 id="221-float">2.2.1 float</h3>
<p>The <em>float</em> type represents an IEEE standard eight-byte floating-point number, often called "double" in traditional languages. A float can hold (at least) 15 decimal digits of precision. It is denoted by optionally signed numeric digits with either a decimal point or an optional trailing type indicator <code>f</code>. Observe that the console shortens the display of floats with no significant digits to the right of the decimal.</p>
<pre class="highlight"><code class="language-q">q)3.14159265
_
q)1f
_
q)1.0
_</code></pre>
<p>A float can also be specified in scientific notation. Here the <code>e</code> standards for "exponent" ‚Äì i.e., a power of 10 ‚Äì and should not be confused with a type indicator. To the right of the <code>e</code> is a two digit signed exponent. The <code>+</code> and leading <code>0</code> for a positive exponent are optional.</p>
<pre class="highlight"><code class="language-q">q)1.234e07
_
q)1.234e7
_
q)1.234e-7
1.234e-07</code></pre>
<h3 id="222-real">2.2.2 real</h3>
<p>The real type represents a single-precision, four-byte floating-point number and is denoted by numeric digits containing a decimal point and a trailing type indicator <code>e</code>. Be mindful that this type is called 'float' in some languages. A real can hold at least 6 decimal digits of precision.</p>
<div class="admonition note">
<p class="admonition-title">Real datatype</p>
<p>The real type is basically useless in finance since it does not provide enough precision for quantities expressed in currencies such as Yen. We recommend always using float.</p>
</div>
<p>The scientific notation of reals is awkward, given the presence of <code>e</code> both for the exponent and the type indicator.</p>
<pre class="highlight"><code class="language-q">q)12.34e
_
q)1.234e7e
_</code></pre>
<h3 id="223-floating-point-display">2.2.3 Floating Point Display</h3>
<p>The q console display defaults to seven decimal digits of accuracy for float and real values by rounding the display in the seventh significant digit, even though more digits are stored.</p>
<pre class="highlight"><code class="language-q">q)f:1.23456789e-10
q)r:1.2345678e-10e
q)f
1.234568e-010
q)r
1.234568e+010e</code></pre>
<p>You can change this by using the <code>\P</code> command (note upper case) to specify a display width up to 16 digits. If you issue <code>\P 0</code> the console will display all 17 decimal digits of the underlying binary representation, although the last digit is unreliable.</p>
<pre class="highlight"><code class="language-q">q)f12:1.23456789012
q)f16:1.234567890123456
q)\P 12
q)f12
1.23456789012
q)f16
1.23456789012
q)\P 16
q)f12
1.23456789012
q)f16
1.234567890123456
q)\P 0
q)1%3
0.33333333333333331</code></pre>
<h2 id="23-binary-data">2.3 Binary Data</h2>
<p>Binary data can be represented as bit or byte values.</p>
<h3 id="231-boolean">2.3.1 boolean</h3>
<p>The <em>boolean</em> type uses one byte to store a bit and is denoted by the bit value with the trailing type indicator <code>b</code>. There are <strong>no</strong> keywords for 'true' or 'false', nor are there separate logical operators for booleans.</p>
<pre class="highlight"><code class="language-q">q)0b
_
q)1b
_</code></pre>
<p>Binary values are implicitly promoted to unsigned integers when participating in arithmetic expressions or comparisons. For example, the following yields an integer.</p>
<pre class="highlight"><code class="language-q">q)42+1b
_</code></pre>
<p>The following yields a float.</p>
<pre class="highlight"><code class="language-q">q)3.1415+0b
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">The ability of booleans to participate in arithmetic can be useful in eliminating conditionals.</p>
<pre><code class="language-q">
q)flag:1b
q)base:100
q)base+flag*42
142
</code></pre>
</div>
<h3 id="232-byte">2.3.2 byte</h3>
<p>The <em>byte</em> type uses one byte to store an unsigned 8-bit value and is denoted by the <strong>leading</strong> type indicator <code>0x</code> followed by two hexadecimal digits. Upper or lower case can be used for the alpha hex digits but lower case is customary.</p>
<pre class="highlight"><code class="language-q">q)0x2a
_
q)0x2A
_</code></pre>
<p>As with boolean, a byte participates in arithmetic via type promotion to signed int.</p>
<pre class="highlight"><code class="language-q">q)1+0x29
_</code></pre>
<h3 id="233-guid">2.3.3 GUID</h3>
<p>The <em>guid</em> type was introduced in q3.0. A GUID (globally unique identifier) is a 16-byte binary value that is unique across time and space (well, nearly so). It is ideally suited for locally generating a globally unique identifier without resorting to a central control mechanism ‚Äì e.g., transaction IDs. It can be used as a table key or in joins and is preferred to strings or symbols in such situations.</p>
<p>The guid type does not have a literal form since it is generated for you by a process that guarantees uniqueness. Applying <code>?</code> to the null guid value <code>0Ng</code> generates a list of guids.</p>
<pre class="highlight"><code class="language-q">q)1?0Ng
,61f35174-90bc-a48a-d88f-e15e4a377ec8
q)2?0Ng
_
q)-1?0Ng
_
q)-2?0Ng
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Sign of the left argument</p>
<p>The difference between using a positive integer vs. a negative integer to generate a list of GUIDs is that the positive case uses the same initial seed in each new q session whereas the negative case uses a random seed. The former is useful for reproducible results during testing but only the latter should be used in production; otherwise, your "GUIDs" will not be unique across q sessions.</p>
</div>
<p>You can import a guid generated elsewhere by parsing a string of 16 hex digits.</p>
<pre class="highlight"><code class="language-q">q)"G"$"61f35174-90bc-a48a-d88f-e15e4a377ec8"
_</code></pre>
<p>You can also convert from a list of 16 bytes using an overload of <a href="https://code.kx.com/q/ref/sv/"><code>sv</code></a>.</p>
<pre class="highlight"><code class="language-q">q)0x0 sv 16?0xff
_</code></pre>
<div class="admonition warning">
<p class="admonition-title">Unless these values have been constructed from a legitimate GUID creation process, there is no guarantee they will be unique.</p>
</div>
<p>The only operations available for guids are <code>~</code>, <code>=</code>, <code>&lt;</code>, <code>&gt;</code> and <code>null</code>.</p>
<h2 id="24-text-data">2.4 Text Data</h2>
<p>There are two atomic text types in q. They are more akin to the SQL types <code>CHAR</code> and <code>VARCHAR</code> than the character types of traditional languages.</p>
<h3 id="241-char">2.4.1 char</h3>
<p>A <em>char</em> holds an individual ASCII or 8-bit Unicode character that is stored in one byte. It corresponds to a SQL <code>CHAR</code>. It is denoted by a single character enclosed in double quotes.</p>
<pre class="highlight"><code class="language-q">q)"q"
_</code></pre>
<p>Some keyboard characters ‚Äì e.g., the double-quote ‚Äì cannot be entered directly into a char since they have special meaning in the q console. As in C, special characters are escaped with a preceding back-slash <code>\</code>. The console display somewhat confusingly displays the escape, but the following are all actually single characters.</p>
<pre class="highlight"><code class="language-q">q)"\"" / double-quote
"\""
q)"\\" / back-slash
_
q)"\n" / newline
_
q)"\r" / return
_
q)"\t" / horizontal tab
_</code></pre>
<p>Also as in C, you can escape any ASCII character by specifying its underlying numeric value as three octal digits.</p>
<pre class="highlight"><code class="language-q">q)"\142"
"b"</code></pre>
<h3 id="242-symbol">2.4.2 symbol</h3>
<p>A symbol is an atom holding text. It is denoted by a leading back-quote, read "back tick" in q-speak.</p>
<pre class="highlight"><code class="language-q">q)`q
_
q)`zaphod
_</code></pre>
<div class="admonition important">
<p class="admonition-title">Symbols are used for names in q. All names are symbols but not all symbols are names.</p>
</div>
<p>A symbol is akin to a SQL <code>VARCHAR</code>, in that it can hold an arbitrary number of characters, but is different in that it is atomic. The char <code>"q"</code> and the symbol <code>`kdb</code> are both atomic entities. A symbol is irreducible, meaning that the individual characters that comprise it are <strong>not</strong> directly accessible.</p>
<p>A symbol is <strong>not</strong> a string. We shall see in Chapter 3 that there is an analogue of strings in q, namely a list of char. While a list of char is a kissing cousin to a symbol, we emphasize that a symbol is <strong>not</strong> a collection of char. The symbol <code>`a</code> and the char <code>"a"</code> are not the same, as we can see by asking q if they are identical.</p>
<pre class="highlight"><code class="language-q">q)`a~"a"
0b</code></pre>
<div class="admonition advanced">
<p class="admonition-title">Advanced</p>
<p>A symbol can include arbitrary text, including text that cannot be directly entered from the console ‚Äì e.g., embedded blanks and special characters such as back-tick. You can manufacture a symbol from any text by casting the corresponding list of char to a symbol. (You will need to escape special characters into the string.) See <a href="https://code.kx.com/q4m3/6_Functions/#615-we-dont-need-no-stinkin-brackets">¬ß6.1.5</a> for more on casting.</p>
<pre><code class="language-q">
q)`$"A symbol with blanks and `"
`A symbol with blanks and `
</code></pre>
</div>
<h2 id="25-temporal-data">2.5 Temporal Data</h2>
<p>In the real world, time is measured in a system of units determined by calendars and clocks. A calendar measures multiples of days whereas a clock subdivides a day into smaller units. The notion of "telling time" associates a time to a number in the system of units provided by some choice of calendar and clock. We call such a value a <em>temporal type</em>.</p>
<p>Astronomers know that it is most convenient to put the calendar and clock together to have a single measure of time on all scales ‚Äì i.e., UTC. In common practice, calendar and clock measurements can be made separately where the full scale is not needed.</p>
<p>Our system of calendars and clocks is a hodge-podge based on early astronomy. We measure days by counting rotations of the earth on its axis and years by counting revolutions of the Earth. Months evolved from lunar cycles tracking the changes in the phase of the moon.</p>
<p>Imposed on this is a sexagesimal counting system originated by the ancient Sumerians, who were evidently fond of 12. There were (almost) 360 days in a year and exactly 12 hours of daylight and darkness at equinox. There are 60 minutes in an hour. This was good enough for farmers and astronomers to predict sun and moon cycles 4000 years ago. Increased accuracy of clocks has forced us to adopt leap years, leap seconds and other adjustments to make things come out right. Social and legal customs result in differentiating days into various categories such as business days and holidays. Time zones attempt to make clock time correspond to sunlight and the legislative lunacy of daylight savings time shifts clocks with no actual benefit.</p>
<p>Computer systems have tried to map this mess into the ordered world of bits with varying levels of success. With the advent of nanosecond-based temporal types, time measurement in q is now logical and consistent in that all temporal values are integral counts. These counts are offsets from millennium and midnight, not some point in the 1970s when a system designer realized something had to be done about time.</p>
<p>Q handles time series and relational data in a consistent and efficient manner. It extends the basic SQL date and time data types to facilitate temporal operations, which are minimal in SQL and can be clumsy in traditional languages (e.g., Java's original date library and its time zones).</p>
<h3 id="251-date">2.5.1 date</h3>
<p>A <em>date</em> is stored as a four-byte signed integer and is denoted by <em>yyyy.mm.dd</em>, where <em>yyyy</em> represents the year, <em>mm</em> the month and <em>dd</em> the day. The underlying value is the count of days from Jan 1, 2000 ‚Äì positive for post-millennium and negative for pre.</p>
<pre class="highlight"><code class="language-q">q)2015.01.01
_
q)2000.01.01=0
1b
q)2000.01.02=1
_
q)1999.12.31=-1
_</code></pre>
<p>Since real-world months and days begin at 1 (not zero), January is <code>01</code>. Leading zeroes in months and days are required; their omission causes an error.</p>
<pre class="highlight"><code class="language-q">q)2015.1.1
'2015.1.1</code></pre>
<div class="admonition tip">
<p class="admonition-title">The underlying day count can be obtained by casting.</p>
<pre><code class="language-q">
q)`int$2000.02.01
_
</code></pre>
</div>
<h3 id="252-time-types">2.5.2 Time Types</h3>
<p>There are two versions of time, depending on the resolution required. If milliseconds are sufficient, use the <em>time</em> type, which stores the count of milliseconds from midnight in a 32-bit signed integer. It is denoted by <em>hh:mm:ss.uuu</em> where <em>hh</em> represents hours on the 24-hour clock, <em>mm</em> represents minutes, <em>ss</em> represents seconds, and <em>uuu</em> represents milliseconds.</p>
<pre class="highlight"><code class="language-q">q)12:34:56.789
_
q)12:00:00.000=12*60*60*1000
1b</code></pre>
<p>Leading zeroes are required in all constituents of a time value. The underlying millisecond count can be obtained by casting to an int.</p>
<pre class="highlight"><code class="language-q">q)`int$12:00:00.000
_</code></pre>
<p>If milliseconds are not sufficient, use the <em>timespan</em> type, which stores the count of nanoseconds from midnight as a long integer.</p>
<p>It is denoted by <em>0Dhh:mm:ss.nnnnnnnnn</em> where <em>hh</em> represents hours on the 24-hour clock, <em>mm</em> represents minutes, <em>ss</em> represents seconds, and <em>nnnnnnnnn</em> represents nanoseconds. Observe that the leading <code>0D</code> is optional.</p>
<pre class="highlight"><code class="language-q">q)12:34:56.123456789
0D12:34:56.123456789
q)12:34:56.123456 / microseconds become nanos
0D12:34:56.123456000</code></pre>
<p>Leading zeroes in constituents are again required.</p>
<p>The underlying nanosecond count can be obtained by casting to a long.</p>
<pre class="highlight"><code class="language-q">q)`long$12:34:56.123456789
_</code></pre>
<h3 id="253-date-time-types">2.5.3 Date-Time Types</h3>
<p>There are two date-time types. The first is deprecated and should not be used; we include it here in case you encounter it in older q code.</p>
<p>A <em>datetime</em> (deprecated) is the lexical combination of a date and a time, separated by <code>T</code> as in the ISO standard format. A datetime value stores in a float the fractional day count from midnight Jan 1, 2000.</p>
<pre class="highlight"><code class="language-q">q)2000.01.01T12:00:00.000
_
q)2000.01.02T12:00:00.000=1.5
1b</code></pre>
<p>The underlying fractional day count can be obtained by casting to float.</p>
<pre class="highlight"><code class="language-q">q)`float$2000.01.02T12:00:00.000
_</code></pre>
<p>Extract the date and time portions from a datetime by casting.</p>
<pre class="highlight"><code class="language-q">q)`date$2000.01.02T12:00:00.000
_
q)`time$2000.01.02T12:00:00.000
_</code></pre>
<div class="admonition warning">
<p class="admonition-title">Do <em>not</em> use a datetime for a key or in a join since the underlying float value is fuzzy and may give unexpected results.</p>
</div>
<p>The preferred type is <em>timestamp</em>, which is the lexical combination of a date and a timespan, separated by <code>D</code>. The underlying timestamp value is a long representing the count of nanoseconds since the millennium. Post-millennium is positive and pre- is negative.</p>
<pre class="highlight"><code class="language-q">q)2014.11.22D17:43:40.123456789
_</code></pre>
<p>The underlying nanosecond count can be obtained by casting to long.</p>
<pre class="highlight"><code class="language-q">q)`long$2014.11.22D17:43:40.123456789
_</code></pre>
<p>Extract the date and timespan constituents from a timestamp by casting.</p>
<pre class="highlight"><code class="language-q">q)`date$2014.11.22D17:43:40.123456789
_
q)`timespan$2014.11.22D17:43:40.123456789
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Use a timestamp instead of a datetime for a key column or in a join. Or separate into date and time columns.</p>
</div>
<h3 id="254-month">2.5.4 month</h3>
<p>The <em>month</em> type is stored as a 32-bit signed integer and is denoted by <em>yyyy.mm</em> with a trailing type indicator <code>m</code>. A month value is the count of months since the beginning of the millennium. Post-milieu is positive and pre is negative.</p>
<pre class="highlight"><code class="language-q">q)2015.11m
_
q)2001.01m=12
1b</code></pre>
<div class="admonition warning">
<p class="admonition-title">Leaving off the type indicator <code>m</code> yields a float. This is a common qbie error.</p>
</div>
<pre class="highlight"><code class="language-q"> q)2014.11 / this is a float!
 2014.11</code></pre>
<p>The underlying month count can be obtained by casting to int.</p>
<pre class="highlight"><code class="language-q">q)`int$2015.01m
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Despite that fact that a month type counts months since the millennium and a date type counts days since the millennium, the first day of the month is equal to the month.</p>
<pre><code class="language-q">
q)2015.07m=2015.07.01
1b
</code></pre>
</div>
<h3 id="255-minute">2.5.5 minute</h3>
<p>The <em>minute</em> type is stored as a 32-bit signed integer and is denoted by <em>hh:mm</em>. A minute value counts the number of minutes from midnight.</p>
<pre class="highlight"><code class="language-q">q)12:30
_
q)12:00=12*60
1b</code></pre>
<p>The underlying minute count can be obtained by casting to int.</p>
<pre class="highlight"><code class="language-q">q)`int$12:00
_</code></pre>
<p>A minute equals its equivalent time and timestamp counterparts.</p>
<pre class="highlight"><code class="language-q">q)12:00=12:00:00.000
1b
q)12:00=12:00:00.000000000
_</code></pre>
<h3 id="256-second">2.5.6 second</h3>
<p>The <em>second</em> type is stored as 32-bit signed integer and is denoted by <em>hh:mm:ss</em>. A second value counts the number of seconds from midnight.</p>
<pre class="highlight"><code class="language-q">q)23:59:59
_
q)23:59:59=-1+24*60*60
1b</code></pre>
<p>The representation of the second type makes it look like an ordinary time value, and it can function as that if you only need resolution to the second. However, a q time value is a count of milliseconds or nanoseconds from midnight, so the underlying values are different.</p>
<pre class="highlight"><code class="language-q">q)`int$12:34:56
45296i
q)`int$12:34:56.000
_
q)`long$12:34:56.000000000
_</code></pre>
<p>Nevertheless, these values are equal in the eyes of q ‚Äì as they should be, since they are merely representations in different units of the same position on a clock.</p>
<pre class="highlight"><code class="language-q">q)12:34:56=12:34:56.000
1b
q)12:34:56.000=12:34:56.000000000
_</code></pre>
<h3 id="257-constituents-and-dot-notation">2.5.7 Constituents and Dot Notation</h3>
<p>The constituents of compound temporal types can be extracted using dot notation. For example, the field values of a date are named <code>year</code>, <code>mm</code> and <code>dd</code>; similarly for time and other temporal types.</p>
<pre class="highlight"><code class="language-q">q)dt:2014.01.01
q)dt.year
2014i
q)dt.mm
_
q)dt.dd
_
q)ti:12:34:56.789
q)ti.hh
12i
q)ti.mm
_
q)ti.ss
_</code></pre>
<div class="admonition warning">
<p class="admonition-title">Unfortunately, at the time of this writing (Sep 2015) dot notation for extraction (still) does not work inside functions.</p>
</div>
<p>Thus we recommend avoiding dot notation altogether and using <a href="https://code.kx.com/q/ref/cast/">Cast</a> instead, as it always works for any meaningful temporal extraction or conversion. In addition to the individual field values, you can also extract higher-order constituents.</p>
<pre class="highlight"><code class="language-q">q)`dd$dt
1i
q)`mm$dt
_
q)`dd$dt
_
q)`month$dt
2014.01m</code></pre>
<div class="admonition tip">
<p class="admonition-title">To extract milliseconds or nanoseconds from a time type, cast to the underlying integer and <code>mod</code> the result by 1000 or 1000000000.</p>
<pre><code class="language-q">
q)(`int$12:34:56.789) mod 1000
789
q)(`long$12:34:56.123456789) mod 1000000000
_
</code></pre>
</div>
<h2 id="26-arithmetic-infinities-and-nulls">2.6 Arithmetic Infinities and Nulls</h2>
<p>Types whose underlying values are integer or floating point have special lexical forms representing values that lie outside the "normal" domain. We list the basic ones in the following table. The others are obtained by appending the appropriate type suffices.</p>
<table>
<thead>
<tr>
<th>Literal</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>0w</td>
<td>Positive float infinity</td>
</tr>
<tr>
<td>-0w</td>
<td>Negative float infinity</td>
</tr>
<tr>
<td>0n</td>
<td>Null float&nbsp;; NaN, or not a number</td>
</tr>
<tr>
<td>0W</td>
<td>Positive long infinity</td>
</tr>
<tr>
<td>-0W</td>
<td>Negative long infinity</td>
</tr>
<tr>
<td>0N</td>
<td>Null long</td>
</tr>
</tbody>
</table>
<p>Observe the distinction between lower case <code>w</code> in the float literals and upper case <code>W</code> in the integer literals. The character <code>w</code> was chosen for its resemblance to the infinity symbol. Seriously.</p>
<p>In q, division of numeric values always results in a float.</p>
<p>In mathematics, division of a positive value by 0 results in positive infinity and division of a negative value by zero results in negative infinity. So it is in q, with the funky symbols <code>0w</code> and <code>-0w</code> for positive and negative float infinity respectively.</p>
<p>In mathematics, division of zero by zero is undefined. So it is in q, with <code>0n</code> representing NaN ‚Äì i.e., an undefined float. The float infinities perform exactly as they should in arithmetic and comparison operations, since they are required to do so by the IEEE spec.</p>
<p>The q philosophy is that any valid arithmetic expression will produce a result rather than a runtime error. Therefore, dividing by 0 produces a special float value rather than throwing an exception. You can perform a complex sequence of calculations without worrying about things blowing up in the middle or having to insert cumbersome exception trapping.</p>
<p>The integral infinities and nulls cannot be produced via division on normal integer values, since the result of division in q is always a float. Moreover, while integral nulls propagate as nulls should, the integral infinities do <strong>not</strong> perform as you would expect in arithmetic operations. The integral infinities <strong>do</strong> produce the correct results in comparisons; in fact, this is their <em>raison d‚Äô√™tre</em>.</p>
<pre class="highlight"><code class="language-q">q)42&lt;0W
1b
q)-0W&lt;42
_</code></pre>
<p>To understand the integral nulls and infinities, realize that they are actually valid bit patterns for their corresponding types. Here are the long versions.</p>
<table>
<thead>
<tr>
<th>q</th>
<th>C Equivalent</th>
<th>Numeric</th>
</tr>
</thead>
<tbody>
<tr>
<td>0N</td>
<td>MIN_INT</td>
<td>-9223372036854775808</td>
</tr>
<tr>
<td>-0W</td>
<td>MIN_INT+1</td>
<td>-9223372036854775807</td>
</tr>
<tr>
<td>0W</td>
<td>MAX_INT</td>
<td>+9223372036854775807</td>
</tr>
</tbody>
</table>
<p>Consequently, ordering on integers is,</p>
<p><code>0N</code> &lt; <code>-0W</code> &lt; normal integer &lt; <code>0W</code></p>
<p>This explains some oddities.</p>
<pre class="highlight"><code class="language-q">q)9223372036854775806+1
0W
q)-0W-1
0N
q)-0W+1
-9223372036854775806</code></pre>
<div class="admonition tip">
<p class="admonition-title">Q does not trap overflow</p>
<p>The fact that q does not trap overflow explains the equally bizarre looking
</p><pre><code class="language-q">
q)0W+1
0N
q)0W+2
-0W
q)0W+3
-9223372036854775806
</code></pre>
</div>
<p>Implementing proper arithmetic on integer infinities would entail expensive tests in the arithmetic operators and an unacceptable slow-down for normal arithmetic.</p>
<h2 id="27-nulls">2.7 Nulls</h2>
<h3 id="270-overview-of-nulls">2.7.0 Overview of Nulls</h3>
<p>The concept of a null value generally indicates missing data. This is an area in which q differs from both traditional programming languages and SQL.</p>
<p>In such languages as C++, Java and C#, the concept of a null value applies to complex entities (i.e., objects) that are allocated on the heap and accessed by pointer or reference. A null pointer corresponds to an unallocated entity, meaning that it has not been assigned the address of an initialized block of memory. (Tony Hoare, who introduced the concept of null pointer, calls it his "billion dollar mistake.") There is no concept of null for entities that are of value type. For those types that admit null, you test for null by asking if the value is equal to a special null marker.</p>
<p>The <code>NULL</code> value in SQL indicates that data is not present. The <code>NULL</code> value is distinct from any value that can actually be contained in a field and it does not have '=' semantics. That is, you do not test a field for null with <code>= NULL</code>. Instead, you ask if it <code>IS NULL</code>. Because <code>NULL</code> is a separate value, Boolean fields, for example, actually have three states: <code>0</code>, <code>1</code> and <code>NULL</code>.</p>
<p>The q situation is more interesting. There are no references or pointers, so the notion of an unallocated entity does not arise. Most types have null values that are distinct from "normal" values and occupy the same amount of storage. Some types do not designate a distinct null value because there is no available bit pattern ‚Äì i.e., for boolean, byte and char all underlying bit patterns are meaningfully employed. In this case, the value with no information content serves as a proxy for null.</p>
<p>The following table summarizes the way nulls are handled.</p>
<table>
<thead>
<tr>
<th>type</th>
<th>null</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean*</td>
<td>0b</td>
</tr>
<tr>
<td>guid*</td>
<td>0Ng (00000000-0000-0000-0000-000000000000)</td>
</tr>
<tr>
<td>byte*</td>
<td>0x00</td>
</tr>
<tr>
<td>short</td>
<td>0Nh</td>
</tr>
<tr>
<td>Int</td>
<td>0N</td>
</tr>
<tr>
<td>long</td>
<td>0Nj</td>
</tr>
<tr>
<td>real</td>
<td>0Ne</td>
</tr>
<tr>
<td>float</td>
<td>0n</td>
</tr>
<tr>
<td>char*</td>
<td>" "</td>
</tr>
<tr>
<td>sym</td>
<td>`</td>
</tr>
<tr>
<td>timestamp</td>
<td>0Np</td>
</tr>
<tr>
<td>month</td>
<td>0Nm</td>
</tr>
<tr>
<td>date</td>
<td>0Nd</td>
</tr>
<tr>
<td>datetime</td>
<td>0Nz</td>
</tr>
<tr>
<td>timespan</td>
<td>0Nn</td>
</tr>
<tr>
<td>minute</td>
<td>0Nu</td>
</tr>
<tr>
<td>second</td>
<td>0Nv</td>
</tr>
<tr>
<td>time</td>
<td>0Nt</td>
</tr>
</tbody>
</table>
<h3 id="271-binary-nulls">2.7.1 Binary Nulls</h3>
<p>The binary types have no null values. There is no room since every bit pattern is a legitimate value.</p>
<h3 id="272-numeric-and-temporal-nulls">2.7.2 Numeric and Temporal Nulls</h3>
<p>The numeric and temporal types have their own designated null values. Here the situation is similar to SQL, in that you can distinguish missing data from data whose underlying value is zero. In contrast, there is no universal null value and q nulls take the same space as non-nulls.</p>
<p>An advantage of the q approach is that the null values act like other values in expressions. The tradeoff is that you must use the correct null value in type-checked situations.</p>
<h3 id="273-text-nulls">2.7.3 Text Nulls</h3>
<p>Considering a symbol as variable length text justifies that the symbol null is the empty symbol, designated by a naked back-tick <code>`</code>.</p>
<p>The null value for the char type is the blank character <code>" "</code>. As with binary data, you cannot distinguish between a missing char value and a blank value. Again, this is not seriously limiting in practice, but you should ensure that your application does not rely on this distinction.</p>
<div class="admonition tip">
<p class="admonition-title">The value <code>""</code> is <em>not</em> a null char. It is an empty list of char.</p>
</div>
<h3 id="274-testing-for-null">2.7.4 Testing for Null</h3>
<p>You could test for null using <code>=</code> but this requires a null literal of correct type. Because q is dynamically typed, this can result in problems if a variable changes type during program execution.</p>
<p>Always use the unary <a href="https://code.kx.com/q/ref/null/"><code>null</code></a> to test a value for null, as opposed to <code>=</code>, as it provides a type-independent check. Also, you don't have to remember the funky null literals.</p>
<pre class="highlight"><code class="language-q">q)null 42
_
q)null `
_
q)null " "
_
q)null ""</code></pre>
                


                
              
              
                


              
            </article>
            
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))for(var set of document.querySelectorAll("[data-tabs]")){var labels=set.querySelectorAll(":scope > label");e:for(var tab of tabs)for(var label of labels)if(label.innerText.trim()===tab){var input=label.previousElementSibling;input.checked=!0;break e}}</script>

          </div>
        </div>
        
          
        
      
                </div>
            </section>
        
            <section class="chapter" id="chapter-8">
                <div class="chapter-header">
                    <h1 class="chapter-title">3. Lists¬∂</h1>
                    <div class="chapter-meta">
                        <span>üìñ Source: <a href="https://code.kx.com/q4m3/3_Lists/">https://code.kx.com/q4m3/3_Lists/</a></span>
                        <span>üìù 6172 words</span>
                        
                    </div>
                </div>
                <div class="chapter-content">
                    
        <div class="md-main__inner md-grid">
          
            
              
              
            
            
              
              
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                
                <h1 id="3-lists">3. Lists</h1>
<h2 id="30-overview">3.0 Overview</h2>
<p>All data structures in q are ultimately built from lists: a dictionary is a pair of lists; a table is a special dictionary; a keyed table is a pair of tables. Thus it is important to have a thorough grounding in lists.</p>
<p>All lists are equal but some lists are more equal than others. These are the lists of atoms of homogenous type, called <em>simple lists</em> ‚Äì known in mathematics as vectors. They have optimum storage and performance characteristics.</p>
<p>While q‚Äôs list operations are similar to those in other functional languages, lists are stored and processed quite differently.</p>
<ul>
<li>They are not stored as singly-linked lists under the covers. Simple lists occupy contiguous storage and general lists are pointers in contiguous storage.</li>
<li>Appending items to the end rather than ‚Äúcons‚Äù-ing to the front.</li>
<li>Efficient direct item access is available via indexing.</li>
<li>A general list can hold items of different type without resorting to a union (sum) type.</li>
</ul>
<p>It may be instructive to think of q lists as dynamically allocated arrays.</p>
<h2 id="31-introduction-to-lists">3.1 Introduction to Lists</h2>
<p>A list is an ordered collection. ‚ÄúA collection of what?‚Äù you ask. More precisely, a list is recursively defined as an ordered collection of atoms and other lists. We pay special attention to the case in which the list comprises atoms of uniform type.</p>
<h3 id="311-list-definition-and-assignment">3.1.1 List Definition and Assignment</h3>
<p>A (<em>general</em>) <em>list</em> is an ordered collection of q data. The members of the collection are its <em>items</em>. The notation for a general list encloses its items within matching parentheses and separates them with semi-colons.</p>
<div class="admonition tip">
<p class="admonition-title">Whitespace in list notation is optional. In what follows, we shall often insert optional whitespace after the semicolon separators for readability.</p>
</div>
<pre class="highlight"><code class="language-q">q)(1; 1.1; `1)
_
q)(1;2;3)
_
q)("a";"b";"c";"d")
_
q)(`Life;`the;`Universe;`and;`Everything)
_
q)(-10.0; 3.1415e; 1b; `abc; "z")
_
q)((1; 2; 3); (4; 5))
_
q)((1; 2; 3); (`1; "2"; 3); 4.4)
_</code></pre>
<p>If you diligently entered each of these examples in your console, you have noticed that q does not always echo what you type. The initial and last three lists are <em>general</em> lists, meaning they are not homogenous atoms. This could mean atoms of mixed type, nested lists of uniform type, or atoms and nested lists of mixed type.</p>
<p>Items in a list are sequenced from left to right, providing an inherent order. The lists <code>1;2</code> and <code>2;1</code> are different. SQL is based on sets, which are inherently unordered. This distinction leads to some subtle differences between the semantics of queries on q tables versus the analogous SQL queries. The inherent ordering of lists makes large time series processing natural and fast in q, while it is cumbersome and slow in standard SQL due to the need to place things in order.</p>
<p>Lists can be assigned to variables exactly like atoms.</p>
<pre class="highlight"><code class="language-q">q)L1:(1;2;3)
q)L2:("z";"a";"p";"h";"o";"d")
q)L3:((1; 2; 3); (`1; "2"; 3); 4.4)</code></pre>
<h3 id="312-count">3.1.2 count</h3>
<p>The number of items in a list is its <em>count</em>. You obtain the count of a list by asking for it with the unary function <a href="https://code.kx.com/q/ref/count/"><code>count</code></a>.</p>
<pre class="highlight"><code class="language-q">q)count (1; 2; 3)
3
q)count L1
_</code></pre>
<p>This is our first encounter with a q function (or keyword), which we will learn about in Chapters 4 and 5. For now, we need only understand that <code>count</code> returns a long equal to the number of items in the list to its right.</p>
<div class="admonition tip">
<p class="admonition-title">The maximum number of items for a list in q3.* is 2<sup>64</sup>-1. In q2.* it was 2 billion.</p>
</div>
<p>Observe that the count of an atom is 1 even though an atom is not a list.</p>
<pre class="highlight"><code class="language-q">q)count 42
1
q)count `zaphod
_</code></pre>
<p>Other useful operations are provided by <a href="https://code.kx.com/q/ref/last/"><code>first</code> and <code>last</code></a> that return the first and last item in a list, respectively.</p>
<pre class="highlight"><code class="language-q">q)first (1; 2; 3)
1
q)last (1; 2; 3)
3</code></pre>
<h2 id="32-simple-lists">3.2 Simple Lists</h2>
<p>A list of atoms of a uniform type, called a <em>simple</em> list, corresponds to the mathematical notion of a <em>vector</em>. Such lists are treated specially in q. They have a simplified notation, take less storage and compute faster than general lists.</p>
<div class="admonition tip">
<p class="admonition-title">You can always use general list notation, even for simple lists.</p>
</div>
<p>Whenever q recognizes that the items of a list are homogenous atoms, it dynamically converts to a simple list without asking for permission. In most cases, the storage and performance advantages justify the imposition. However, in some cases ‚Äì such as deletion of an outlier item of non-uniform type ‚Äì this can cause a programming headache because the list will no longer allow appends or updates with items that do not conform to the resulting uniform type.</p>
<h3 id="321-simple-integer-lists">3.2.1 Simple Integer Lists</h3>
<p>The console display of a simple list of any numeric type omits the enclosing parentheses and replaces the separating semi-colons with (required) blanks. The following two expressions define the same list, as q verifies by testing for identity using <a href="https://code.kx.com/q/ref/match/" title="Match"><code>~</code></a>.</p>
<pre class="highlight"><code class="language-q">q)(100;200;300)
_
q)100 200 300
_
q)100 200 300~(100; 200 ; 300)
1b</code></pre>
<p>The console display of the first expression demonstrates the automatic conversion to simple lists previously mentioned.</p>
<p>Similar notation, with the addition of a single trailing type indicator, is used for simple lists of short and int.</p>
<pre class="highlight"><code class="language-q">q)(1h; 2h; 3h)
1 2 3h
q)(100i; 200i; 300i)
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Trailing type indicator</p>
<p>The trailing type indicator in the console display of a simple list applies to the entire list and not just the last item of the list; otherwise, the list would not be simple and would be displayed in general form:</p>
<pre class="highlight"><code>q)(1; 2; 3h)
1
2
3h
</code></pre>
</div>
<h3 id="322-simple-floating-point-lists">3.2.2 Simple Floating Point Lists</h3>
<p>Simple lists of float and real are notated the same as integral lists.</p>
<pre class="highlight"><code class="language-q">q)(123.4567; 9876.543; 99.0)
123.4567 9876.543 99
q)123.4567 9876.543 99
_</code></pre>
<p>Observe that the q console suppresses the decimal point when displaying a float having zero(es) to the right of the decimal; but the value is not an integer. This notational efficiency for float display means that a list of floats having no decimal parts displays with a trailing ‚Äòf‚Äô.</p>
<pre class="highlight"><code class="language-q">q)1.0 2.0 3.0
1 2 3f
q)1 2 3f~1.0 2.0 3.0
_</code></pre>
<p>Also observe that if you include what appears to be an integer in a list of float, q assumes that you are following its convention by merely omitting redundant data to the right of the decimal. That is, you get a list of float and not a general list.</p>
<pre class="highlight"><code class="language-q">q)1.1 2 3.3~1.1 2.0 3.3
_</code></pre>
<h3 id="323-simple-binary-lists">3.2.3 Simple Binary Lists</h3>
<p>The abbreviated notation for a simple list of boolean or byte data juxtaposes the individual data values together with <strong>no</strong> whitespace between. The <code>b</code> type indicator for boolean trails the list.</p>
<pre class="highlight"><code class="language-q">q)(0b;1b;0b;1b;1b)
01011b
q)01011b
_</code></pre>
<div class="admonition detail">
<p class="admonition-title">Storage for a simple boolean list</p>
<p>A simple list of boolean atoms requires the same number of bytes to store as it has atoms. While the simplified notation is suggestive of a bit mask, multiple bits are not compressed to fit inside a single byte. The boolean list above uses 5 bytes of storage.</p>
</div>
<p>The <code>0x</code> indicator for a simple list of byte precedes the list.</p>
<pre class="highlight"><code class="language-q">q)(0x20;0xa1;0xff)
0x20a1ff
q)0x20a1ff~(0x20;0xa1;0xff)
_</code></pre>
<p>The display of a simple list of GUIDs is the same is that of integers ‚Äì i.e., the values are separated by spaces.</p>
<pre class="highlight"><code class="language-q">q)3?0Ng
_</code></pre>
<h3 id="324-simple-symbol-lists">3.2.4 Simple Symbol Lists</h3>
<p>The abbreviated notation for simple lists of symbols juxtaposes the individual atoms with no intervening whitespace.</p>
<pre class="highlight"><code class="language-q">q)(`Life;`the;`Universe;`and;`Everything)
`Life`the`Universe`and`Everything
q)`Life`the`Universe`and`Everything
_</code></pre>
<p>Inserting spaces between symbol atoms causes an error.</p>
<pre class="highlight"><code class="language-q">q)`bad `news
'bad</code></pre>
<h3 id="325-simple-char-lists-and-strings">3.2.5 Simple char Lists and Strings</h3>
<p>The simplified notation for a list of char looks just like a string in most languages, with the juxtaposed sequence of characters enclosed in double quotes.</p>
<pre class="highlight"><code class="language-q">q)("s"; "t"; "r"; "i"; "n"; "g")
"string"
q)"string"
_</code></pre>
<p>A simple list of char is actually called a <em>string</em>; however, it does not have the atomic semantics of a string in most languages. Since it is a list of char, <strong>not</strong> an atom, you cannot ask if two strings of different lengths are equal. You <strong>can</strong> ask if they are identical (as you can with any two q entities).</p>
<pre class="highlight"><code class="language-q">q)"string"="text"
'length
q)"string"~"text"
0b</code></pre>
<h3 id="326-lists-of-temporal-data">3.2.6 Lists of Temporal Data</h3>
<p>Since they are really integers, the abbreviated form for simple temporal lists separates items with a space.</p>
<pre class="highlight"><code class="language-q">q)(2000.01.01; 2001.01.01; 2002.01.01)
_
q)(00:00:00.000; 00:00:01.000; 00:00:02.000)
_</code></pre>
<p>Specifying a list of mixed temporal types has a different behavior from that of a list of mixed numeric types. In this case, the list takes the type of the first item in the list; other items are widened or narrowed to match.</p>
<details class="error">
<summary>Mixed lists cannot be written in the vector notation</summary>
<p>The paragraph above is in error. </p>
<p>By definition, vectors have uniform type. The temporal vector notation allows items to be written in the notation of a narrower type, which the parser silently widens. The next example demonstrates this. ‚Äî <em>Editor</em></p>
</details>
<pre class="highlight"><code class="language-q">q)12:34 01:02:03
12:34:00 01:02:03
q)01:02:03 12:34
_</code></pre>
<p>To force the type of a mixed list of temporal values, append a type specifier.</p>
<pre class="highlight"><code class="language-q">q)01:02:03 12:34 11:59:59.999u
01:02 12:34 11:59</code></pre>
<h2 id="33-empty-and-singleton-lists">3.3 Empty and Singleton Lists</h2>
<p>Lists with one or zero items merit special consideration, especially since q‚Äôs notation and display are not exactly intuitive.</p>
<h3 id="331-the-general-empty-list">3.3.1 The General Empty List</h3>
<p>It is useful to have lists with no items. A pair of parentheses enclosing nothing (except optional whitespace) denotes the general empty list, which (annoyingly) has no console display.</p>
<pre class="highlight"><code class="language-q">q)()
q)</code></pre>
<p>We shall see in <a href="https://code.kx.com/q4m3/7_Transforming_Data/#74-creating-typed-empty-lists">¬ß7.4</a> that it is possible to define an empty list with a specific type, so that only items of that type can be added to it.</p>
<div class="admonition advanced">
<p class="admonition-title">Advanced</p>
<p>If you want to force the display of an empty list, use the q utility <a href="https://code.kx.com/q/ref/dotq/#qs1-string%20representation"><code>.Q.s1</code></a>, which converts any q entity into a string suitable for display. Perhaps this utility should be called the ‚Äúwizard of Oz‚Äù operator since it reveals what‚Äôs behind the curtain.</p>
<pre class="highlight"><code>q)L:()
q)L
q).Q.s1 L
"()"
</code></pre>
</div>
<h3 id="332-singleton-lists">3.3.2 Singleton Lists</h3>
<p>A <em>singleton</em> is a list containing a single item. As any postal clerk will tell you, an item in a box is not the same as an unboxed item. So an atom and a singleton containing that atom are different.</p>
<p>The syntax of a singleton presents a notational conundrum for q. We might expect to write the singleton list containing 42 as <code>(42)</code> but we cannot. The issue arises from q‚Äôs use of parentheses both for list demarcation and for the usual mathematical grouping in expressions. The latter leads to the following sequence of arithmetic reductions.</p>
<p><code>(40+2)</code> <code>(42)</code> <code>42</code></p>
<p>This forces <code>(42)</code> to be the <strong>atom</strong> 42.</p>
<p>Unfortunately, there is no way to type a singleton literal. Singletons are created by the function <a href="https://code.kx.com/q/ref/enlist/"><code>enlist</code></a>, which ‚Äúboxes‚Äù its argument into a list with one item. Note that it manages to avoid the usual q predilection for aggressively short names.</p>
<pre class="highlight"><code class="language-q">q)enlist 42
,42</code></pre>
<p>Observe that the console display of a singleton list uses the k form of enlist ‚Äì i.e., unary <code>,</code>. Don‚Äôt be fooled: we can‚Äôt use this in q.</p>
<div class="admonition warning">
<p class="admonition-title">Single-character strings</p>
<p>A string with a single character cannot be written syntactically as ‚Äúa‚Äù ‚Äì this is a character atom. Use <code>enlist</code>. This is a common error for qbies.</p>
<pre class="highlight"><code>q)"a"
_
q)enlist "a"
_
</code></pre>
</div>
<p>A singleton need not contain an atom as its sole item; it can be any q entity.</p>
<pre class="highlight"><code class="language-q">q)enlist 1 2 3
1 2 3
q)enlist (10 20 30; `a`b`c)
10 20 30 a b c</code></pre>
<p>Observe that the console display is not consistent with showing <code>,</code> and sometimes is downright confusing.</p>
<h2 id="34-indexing">3.4 Indexing</h2>
<p>A list is sequenced from left-to-right in the position of its items. The offset of an item from the beginning of the list is called its <em>index</em>. The initial item has index 0, the second item has index 1, etc. Thus a list of count <em>n</em> has items at indices 0 through <em>n</em> - 1.</p>
<div class="admonition warning">
<p class="admonition-title">There is no item at index <code>n</code>. This is a common qbie mistake.</p>
</div>
<h3 id="341-index-notation">3.4.1 Index Notation</h3>
<p>To access the item at index <em>i</em> in a list, follow the list immediately with <code>[i]</code>. This is called <em>item indexing</em>. For example,</p>
<pre class="highlight"><code class="language-q">q)(100; 200; 300)[0]
100
q)100 200 300[0]
100
q)L:100 200 300
q)L[0]
100
q)L[1]
_
q)L[3] / index out of bounds returns null value
_
q)L[2]
_</code></pre>
<h3 id="342-indexed-assignment">3.4.2 Indexed Assignment</h3>
<p>Items in a list can also be assigned via item indexing. Thus,</p>
<pre class="highlight"><code class="language-q">q)L:1 2 3
q)L[1]:42
q)L
1 42 3</code></pre>
<div class="admonition warning">
<p class="admonition-title">Index assignment into a simple list</p>
<p>Index assignment into a simple list enforces strict type matching with no type promotion. Otherwise put, when you assign an item into a simple list, the type must match exactly ‚Äì i.e., a narrower type is not widened.</p>
<pre><code class="language-q">
q)L:100 200 300
q)L[1]:42h
'type
</code></pre>
</div>
<p>This may come as a surprise if you are accustomed to numeric values always being promoted in a dynamically typed language ‚Äì e.g., q itself.</p>
<div class="admonition warning">
<p class="admonition-title">Should you find exceptions to this in some releases of q3.*, do not count on them being there in future releases!</p>
</div>
<h3 id="343-indexing-domain">3.4.3 Indexing Domain</h3>
<p>Providing an invalid data type for the index results in an error.</p>
<pre class="highlight"><code class="language-q">q)L:(-10.0; 3.1415e; 1b; `abc; "z")
q)L[1.0]
'type</code></pre>
<p>In contrast, if you index outside the proper bounds of the list, the result is <strong>not</strong> an error. Instead you get a null value, indicating ‚Äúmissing data.‚Äù Specifically, indexing outside the range of 0 to <code>(count L) ‚Äì 1</code> yields a null of the type of the item at index 0. This is the most efficient thing to return in the case of a general list where there is no canonical item type.</p>
<pre class="highlight"><code class="language-q">q)L1:1 2 3 4
q)L1[4]
0N
q)L2:1.1 2.2 3.3
q)L2[-1]
0n
q)L3:(`1; 2; 3.3)
q)L3[0W]
`</code></pre>
<div class="admonition tip">
<p class="admonition-title">Pay special attention to the first example above that indexes the list at its count. Indexing one position past the end of the list is easy for qbies, especially if you‚Äôre not accustomed to indexing relative to 0.</p>
</div>
<h3 id="344-empty-index-and-null-item">3.4.4 Empty Index and Null Item</h3>
<p>An omitted index returns the entire list.</p>
<pre class="highlight"><code class="language-q">q)L:10 20 30 40
q)L[]
10 20 30 40</code></pre>
<p>An omitted index is <strong>not</strong> the same as indexing with an empty list. The latter returns an empty list, so we use the <code>.Q.s1</code> utility to reveal its display.</p>
<pre class="highlight"><code class="language-q">q).Q.s1 L[()]
"()"</code></pre>
<p>The syntactic form double-colon <code>::</code> denotes the nil item, which allows explicit notation or programmatic generation of an empty index.</p>
<pre class="highlight"><code class="language-q">q)L[::]
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Including the nil item in a list</p>
<p>The type of the nil item does not match any other type in q. Consequently, inclusion of the nil item in a list forces the list to be general.</p>
<pre><code class="language-q">
q)L:(::; 1 ; 2 ; 3)
q)type L
0h
q).Q.s1 L[0]
"::"
</code></pre>
</div>
<p>This is one way to avoid a nasty surprise when q would otherwise automatically convert a list to simple type. A simple case is when you reassign the only non-conforming item in the list.</p>
<pre class="highlight"><code class="language-q">q)L:(1; 2; 3; `a)
q)L[3]:4
q)L
1 2 3 4
q)L[3]:`a
'type</code></pre>
<p>After the reassignment you can no longer assign <code>`a</code> back into the list in its original position. One way to avoid this is by placing <code>::</code> in the list as a guard.</p>
<pre class="highlight"><code class="language-q">q)L:(::; 1 ; 2 ; 3; `a)
q)L[4]:4
q)L[4]:`a
q)</code></pre>
<p>A drawback of this technique is that you must avoid passing <code>::</code> on to expressions that use the actual data in the list.</p>
<h3 id="345-lists-with-expressions">3.4.5 Lists with Expressions</h3>
<p>Any valid q expression can occur in list construction.</p>
<pre class="highlight"><code class="language-q">q)a:42
q)b:43
q)(a; b)
42 43
q)L1:1 2 3
q)L2:40 50
q)(L1; L2)
q)(count L1; sum L2)
_</code></pre>
<div class="admonition warning">
<p class="admonition-title">You cannot use the abbreviated notation of simple lists with variables.</p>
<pre><code class="language-q">
q)a:42
q)b:43
q)a b
': Bad file descriptor|
</code></pre>
</div>
<p>The reason for this cryptic error message will be apparent when we deal with files later.</p>
<h2 id="35-combining-lists">3.5 Combining Lists</h2>
<h3 id="351-joining-with">3.5.1 Joining with <code>,</code></h3>
<p>We scoop the presentation on operators in the next chapter to describe the <a href="https://code.kx.com/q/ref/join/">Join</a> operator <code>,</code>. Its result is a new list in which (a copy of) the right operand is appended to the end of (a copy of) the left operand. Join accepts an atom in either argument ‚Äì i.e., as if the corresponding singleton had been supplied.</p>
<pre class="highlight"><code class="language-q">q)1 2 3,4 5
1 2 3 4 5
q)1,2 3 4
1 2 3 4
q)1 2 3,4
1 2 3 4</code></pre>
<p>Observe that if the arguments are not of uniform type, the result is a general list.</p>
<pre class="highlight"><code class="language-q">q)1 2 3,4.4 5.5
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Ensuring a list</p>
<p>To ensure that a q entity  becomes a list, use either <code>(),x</code> or <code>x,()</code>. This leaves a list unchanged but effectively enlists an atom. Such a seemingly trivial expression is actually useful and is our first example of a q idiom. You cannot use <code>enlist x</code> for the same purpose. Why not?</p>
</div>
<h3 id="352-merging-with">3.5.2 Merging with <code>^</code></h3>
<p>Another way to combine two lists of the same length is by coalescing them with <a href="https://code.kx.com/q/ref/coalesce/" title="Coalesce"><code>^</code></a>. The result is given by the rule that the right item prevails over the corresponding left item except when the right item is null.</p>
<pre class="highlight"><code class="language-q">q)L1:10 0N 30
q)L2:100 200 0N
q)L1^L2
100 200 30</code></pre>
<h2 id="36-lists-as-maps">3.6 Lists as Maps</h2>
<p>Thus far, we have considered a list as data ‚Äì i.e., a static collection of its items. We can also view it as a mathematical mapping provided by item indexing. Specifically, a list provides a map whose domain is integers and whose codomain is the collection of its items (supplemented with a null value). The list map assigns the output value <code>L[i]</code> to the input value <code>i</code>.</p>
<p>i | ‚Äì &gt; L[i]</p>
<p>Here are the I/O tables for some basic lists.</p>
<pre class="highlight"><code class="language-q">101 102 103 104</code></pre>
<table>
<thead>
<tr>
<th><em>I</em></th>
<th><em>O</em></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>101</td>
</tr>
<tr>
<td>1</td>
<td>102</td>
</tr>
<tr>
<td>2</td>
<td>103</td>
</tr>
<tr>
<td>3</td>
<td>104</td>
</tr>
</tbody>
</table>
<pre class="highlight"><code class="language-q">(`a; 123.45; 1b)</code></pre>
<table>
<thead>
<tr>
<th><em>I</em></th>
<th><em>O</em></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>`a</td>
</tr>
<tr>
<td>1</td>
<td>123.45</td>
</tr>
<tr>
<td>2</td>
<td>1b</td>
</tr>
</tbody>
</table>
<pre class="highlight"><code class="language-q">(1 2; 3 4)</code></pre>
<table>
<thead>
<tr>
<th><em>I</em></th>
<th><em>O</em></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1 2</td>
</tr>
<tr>
<td>1</td>
<td>3 4</td>
</tr>
</tbody>
</table>
<p>The codomains of the first two examples are collection of atoms. The last example has a codomain comprised of lists.</p>
<p>A list not only acts like a map, it <strong>is</strong> a unary map whose notation is the same as function application. This is a useful way of looking at things. We shall see in <a href="https://code.kx.com/q4m3/4_Operators/">Chapter 4</a> that a nested list can be viewed as a multivalent map.</p>
<p>From the perspective of lists as maps, the fact that indexing outside the bounds of a list returns a null means the map is implicitly extended to the domain of all integers with null output value outside the list proper.</p>
<h2 id="37-nesting">3.7 Nesting</h2>
<p>Data complexity is built by using lists as items of lists.</p>
<h3 id="371-depth">3.7.1 Depth</h3>
<p>Now that we‚Äôre comfortable with simple lists, we return to general lists. <em>Nested</em> lists have item(s) that are themselves lists. The number of levels of nesting for a list is called its <em>depth</em>. Informally, the depth measures how much repeated indexing is necessary to arrive at only atoms. Atoms have depth 0 and simple lists have depth 1.</p>
<p>The notation of complex lists is reflected in nested parentheses. For pedagogical purposes, in this section only, we shall often use general notation to define even simple lists since the parentheses make things manifest. However, the console always displays lists in the most concise form.</p>
<p>Following is a list of depth 2 that has three items, the first two being atoms and the last a list. We also show its simplified notation.</p>
<pre class="highlight"><code class="language-q">q)L:(1;2;(100;200))
q)count L
_
q)L:(1;2;100 200)
_
q)count L
3
q)L[0]
_
q)L[1]
_
q)L[2]
100 200</code></pre>
<h3 id="372-pictorial-representation">3.7.2 Pictorial Representation</h3>
<p>We present a pictorial representation that may help in visualizing levels of nesting. An atom is represented as a circle containing its value. A list is represented as a box containing its items. A general list is a box containing boxes and atoms.</p>
<p><img alt="Atoms and lists" src="https://code.kx.com/q4m3/img/qfm002.png"></p>
<!-- FIXME 
illustration should show (1; (42; "z"); ((42; "z"); (1.4; `ab)))

Best
Borong Liu
 -->

<h3 id="373-examples">3.7.3 Examples</h3>
<p>Following is a list of depth 2 with two elements, each of which is a simple list.</p>
<pre class="highlight"><code class="language-q">q)L2:((1;2;3);(`ab;`c))
q)count L2
_</code></pre>
<p>Following is a list of depth 2 having three elements, two of which are general lists and one is an atom.</p>
<pre class="highlight"><code class="language-q">q)L3:((1; 2h; 3j); ("a"; `bc`de); 1.23)
q)count L3
_
q)L3[1]
_
q)count L3[1]
_</code></pre>
<p>Following is a list of depth 2 having one item that is a simple list.</p>
<pre class="highlight"><code class="language-q">q)L4:enlist 1 2 3 4
q)count L4
_
q)count L4[0]
_</code></pre>
<p>Following is a ‚Äúrectangular‚Äù list that can be thought of as the 3√ó4 matrix its display resembles.</p>
<pre class="highlight"><code class="language-q">q)m:((11; 12; 13; 14); (21; 22; 23; 24); (31; 32; 33; 34))
q)m
11 12 13 14
21 22 23 24
31 32 33 34
q)m[0]
_
q)m[1]
_
q)m[1][0]</code></pre>
<h2 id="38-iterated-indexing-and-indexing-at-depth">3.8 Iterated Indexing and Indexing at Depth</h2>
<p>In the examples above, we saw that the display of nested lists suggests arrays from other languages. You can indeed think of them as ‚Äúragged‚Äù arrays, as long you are careful about the iterated indexing. Indexing at depth is an alternate notation that suggests nested lists can also be viewed as higher-dimensional arrays.</p>
<h3 id="381-iterated-item-indexing">3.8.1 Iterated Item Indexing</h3>
<p>Retrieving an item in a nested list via a single index retrieves a top-most item.</p>
<pre class="highlight"><code class="language-q">q)L:(1; (100; 200; (1000; 2000; 3000; 4000)))
q)L[0]
_
q)L[1]
100
200
1000 2000 3000 4000</code></pre>
<p>Interpreting list indexing as function application for positional retrieval, we can read the last line,</p>
<blockquote>
<p>Retrieve the item at index 1 from L</p>
</blockquote>
<p>Since the result <code>L[1]</code> is itself a list, we can also retrieve its items via indexing. For example,</p>
<pre class="highlight"><code class="language-q">q)L[1][2]
1000 2000 3000 4000</code></pre>
<p>Read this as,</p>
<blockquote>
<p>Retrieve the item at index 2 from the item at index 1 in L</p>
</blockquote>
<p>We can once again index into this result.</p>
<pre class="highlight"><code class="language-q">q)L[1][2][0]
1000</code></pre>
<p>Read this as,</p>
<blockquote>
<p>Retrieve the item at index 0 from the item at index 2 in the item at index 1 in L</p>
</blockquote>
<h3 id="382-indexing-at-depth">3.8.2 Indexing at Depth</h3>
<p>There is an alternate notation for iterated indexing into a nested list. It is strictly syntactic sugar and amounts to the same thing under the covers. This notation is called <em>indexing at depth</em> and it looks exactly like application of a multi-valent function (which, in fact, it is). The previous retrieval can also be written as,</p>
<pre class="highlight"><code class="language-q">q)L[1;2;0]
_</code></pre>
<p>From one point of view, indexing at depth simplifies the notation for retrieval of inner items from a nested list.</p>
<div class="admonition warning">
<p class="admonition-title">Semicolons in indexing</p>
<p>The semicolons in indexing at depth notation might make it appear that the collection of indices is a list. It is not, although we shall see later a way to perform indexing at depth in which the indices are a list. Also, don‚Äôt confuse the semicolons with commas, which is a common qbie mistake.</p>
</div>
<p>Assignment via index at depth works but assignment does <strong>not</strong> work with iterated indexing.</p>
<pre class="highlight"><code class="language-q">q)L:(1; (100; 200; (1000 2000 3000 4000)))
q)L[1; 2; 0]: 999
q)L
_
q)L[1][2][0]:42
'assign</code></pre>
<p>The last expression fails essentially because the intermediate retrievals are ephemeral ‚Äì i.e., they not addressable entities.</p>
<p>To confirm that the notation for indexing at depth is reasonable, we return to our ‚Äúmatrix‚Äù example.</p>
<pre class="highlight"><code class="language-q">q)m:((11; 12; 13; 14); (21; 22; 23; 24); (31; 32; 33; 34))
q)m
_
q)m[0][0]
11
q)m[0; 0]
11
q)m[0; 1]
_
q)m[1; 2]
_</code></pre>
<p>The indexing at depth notation suggests thinking of <code>m</code> as a multi-dimensional matrix, whereas repeated single indexing suggests thinking of it as an array of arrays. <em>Chacun √† son go√ªt</em>.</p>
<div class="admonition tip">
<p class="admonition-title">Take specifying only number of rows (or columns)</p>
<p>It is possible to create a (possibly ragged) array of a given number of rows or columns from a flat list using the reshape operator <code>#</code> by specifying <code>0N</code> (missing data) for the number of rows or columns in the left operand.</p>
<pre><code class="language-q">
q)2 0N#til 10
0 1 2 3 4
5 6 7 8 9
q)0N 3#til 10
0 1 2
3 4 5
6 7 8
,9
</code></pre>
</div>
<h2 id="39-indexing-with-lists">3.9 Indexing with Lists</h2>
<p>As a vector language, q prefers to deal with lists whenever possible. To this end, there is no reason to restrict list retrieval to one item at a time. Instead, we can ask for a list of items by passing a list of indices.</p>
<h3 id="391-retrieving-multiple-items">3.9.1 Retrieving Multiple Items</h3>
<p>In this section, we begin to see the power of q as a vector language. We start with,</p>
<pre class="highlight"><code class="language-q">q)L:100 200 300 400</code></pre>
<p>We know how to index single items of the list.</p>
<pre class="highlight"><code class="language-q">q)L[0]
100
q)L[2]
_</code></pre>
<p>By extension, we can retrieve a list of multiple items via multiple indices. For simplicity we use simple list notation for the indices.</p>
<pre class="highlight"><code class="language-q">q)L[0 2]
100 300</code></pre>
<p>The indices can be in any order, or even be duplicated and the corresponding items are retrieved. The shape of the output conforms to the input.</p>
<pre class="highlight"><code class="language-q">q)L[3 2 0 1]
_
q)L[0 2 0]
_</code></pre>
<p>Here are some examples of indexing into literal lists.</p>
<pre class="highlight"><code class="language-q">q)01101011b[0 2 4]
011b
q)"beeblebrox"[0 7 8]
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Getting the semi-colons right</p>
<p>Using a list as an index demonstrates why getting the semi-colon separators right is essential when indexing at depth. Leaving them out or using commas effectively specifies multiple indices, and you will get a corresponding list of values from the top level.</p>
</div>
<h3 id="392-indexing-via-a-variable">3.9.2 Indexing via a Variable</h3>
<p>When retrieving items via multiple indices, the indices can live in a variable.</p>
<pre class="highlight"><code class="language-q">q)L
100 200 300 400
q)I:0 2
q)L[I]
100 300</code></pre>
<h3 id="393-indexing-with-nested-lists">3.9.3 Indexing with Nested Lists</h3>
<p>Observe that in our examples of list indexing, the result of index retrieval has the same shape as the index. If the index is an atom the result is an atom. When the index list was a simple list, the result was a list of the same count.</p>
<p>More generally, we can retrieve via an arbitrary collection of indices. The retrieved list has the same shape as the index list.</p>
<pre class="highlight"><code class="language-q">q)L:100 200 300 400
q)L[(0 1; 2 3)]
100 200
300 400</code></pre>
<p>Do not confuse this with indexing at depth. In the present case all items are retrieved at the top level only</p>
<div class="admonition detail">
<p class="admonition-title">Advanced: result conforms to index</p>
<p>More precisely, the result of indexing via a list conforms to the index list. </p>
<p>The notion of <em>conformability</em> of lists is defined recursively. All atoms conform. Two lists conform if they have the same number of items and each of their corresponding items conform. In plain language, two lists conform if they have the same shape.</p>
</div>
<h3 id="394-assignment-with-list-indexing">3.9.4 Assignment with List Indexing</h3>
<p>Recall that a list item can be (re)assigned via item indexing,</p>
<pre class="highlight"><code class="language-q">q)L:100 200 300 400
q)L[0]:100
q)L
_</code></pre>
<p>Assignment via index extends to indexing via a simple list with the proviso that the index list and value list conform.</p>
<pre class="highlight"><code class="language-q">q)L[1 2 3]:2000 3000 4000
q)L
_</code></pre>
<p>Assignment via a simple index list is processed in sequence ‚Äì i.e., from left-to-right. Thus,</p>
<pre class="highlight"><code class="language-q">q)L[3 2 1]:999 888 777
is equivalent to,
q)L[3]:999
q)L[2]:888
q)L[1]:777</code></pre>
<p>Consequently, in the case of a repeated item in the index list (not a swell idea), the right-most assignment prevails.</p>
<pre class="highlight"><code class="language-q">q)L:100 200 300 400
q)L[0 1 0 3]:1000 2000 3000 4000
q)L
_</code></pre>
<p>You can assign a single value to multiple items in a list by using an atom for the assignment value. This is an example of a general phenomenon in q in which an atom is extended to conform to a list.</p>
<pre class="highlight"><code class="language-q">q)L:100 200 300 400
q)L[1 3]:999
q)L
_</code></pre>
<h3 id="395-juxtaposition">3.9.5 Juxtaposition</h3>
<p>Now that we‚Äôre familiar with retrieving and assigning via an index list, we introduce a simplified notation that is common in functional programming. It is permissible to leave out the brackets and juxtapose the list and index with separating whitespace (usually just a blank). Some examples follow.</p>
<pre class="highlight"><code class="language-q">q)L:100 200 300 400
q)L[0]
100
q)L 0
100
q)L[2 1]
_
q)L 2 1
_
q)I:2 1
q)L I
_
q)L ::
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">In the colloquial, ‚ÄúWe don‚Äôt need no stinkin‚Äô brackets!‚Äù</p>
</div>
<p>Which notation you use is a matter of personal preference. In this tutorial, we initially use brackets, since this notation is probably most comfortable for qbies coming from traditional programming. Experienced q programmers often use prefix syntax since it reduces notational density, although brackets can eliminate some parentheses.</p>
<h3 id="396-find">3.9.6 Find (<code>?</code>)</h3>
<p>The <a href="https://code.kx.com/q/ref/find/">Find</a> operator is (an overload of) binary <code>?</code> that returns the index of the first occurrence of the right operand in the left operand.</p>
<pre class="highlight"><code class="language-q">q)1001 1002 1003?1002
1</code></pre>
<div class="admonition tip">
<p class="admonition-title">Since Find maps an item to its index, it is inverse to indexing ‚Äì i.e., list positional retrieval thought of as a mapping.</p>
</div>
<p>If you try to find an item that is not in the list, the result is an integer equal to the count of the list.</p>
<pre class="highlight"><code class="language-q">q)1001 1002 1003?1004
3</code></pre>
<p>One way to think of this result is that the position of an item that is not in the list is one past the end of the list, which is where it would be if you were to append it to the list.</p>
<p>Find is atomic in the right operand meaning that it extends to lists.</p>
<pre class="highlight"><code class="language-q">q)1001 1002 1003?1003 1001
_</code></pre>
<h2 id="310-elided-indices">3.10 Elided Indices</h2>
<h3 id="3101-eliding-indices-for-a-matrix">3.10.1 Eliding Indices for a Matrix</h3>
<p>We return to the situation of indexing at depth for nested lists. For simplicity, we start with a rectangular list that displays as a matrix.</p>
<pre class="highlight"><code class="language-q">q)m:(1 2 3 4; 100 200 300 400; 1000 2000 3000 4000)
q)m
_</code></pre>
<p>Analogy with traditional matrix notation suggests that we could retrieve a row or column from <code>m</code> by providing a ‚Äúpartial‚Äù index at depth. This indeed works because eliding an index in any slot is equivalent to specifying all legitimate indices for that slot.</p>
<pre class="highlight"><code class="language-q">q)m[1;]
100 200 300 400
m[;3]
4 400 4000</code></pre>
<p>Observe that eliding the last index reduces to item indexing at the top level.</p>
<pre class="highlight"><code class="language-q">q)m[1;]~m[1]
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Because of this correspondence, it is permissible to drop the trailing semicolon. We recommend against this practice as it makes the purpose of code less evident.</p>
</div>
<p>The situation of eliding the first index is more interesting. It essentially retrieves a ‚Äúcolumn‚Äù as a slice through the top-level lists ‚Äì i.e., a row.</p>
<h3 id="3102-eliding-indices-for-deeply-nested-lists">3.10.2 Eliding Indices for Deeply Nested Lists</h3>
<p>Let‚Äôs tackle three levels of nesting. Here we can elide one or two indices in any slots.</p>
<pre class="highlight"><code class="language-q">q)L:((1 2 3;4 5 6 7);(`a`b`c`d;`z`y`x`;`0`1`2);("now";"is";"the"))
q)L
(1 2 3;4 5 6 7)
(`a`b`c`d;`z`y`x`;`0`1`2)
("now";"is";"the")
q)L[;1;]
4 5 6 7
`z`y`x`
"is"
q)L[;;2]
3 6
`c`x`2
"w e"</code></pre>
<p>Interpret <code>L[;1;]</code> as,</p>
<blockquote>
<p>Retrieve all items at index 1 of each top level list</p>
</blockquote>
<p>Interpret <code>L[;;2]</code> as,</p>
<blockquote>
<p>Retrieve the items at index 2 for each list at the second level</p>
</blockquote>
<p>Observe that in <code>L[;;2]</code> the attempt to retrieve the item at index 2 of the string <code>"is"</code> was out of bounds and so resulted in the null value <code>" "</code>. This is the source of the blank in <code>"w e"</code> of the result.</p>
<p>As the final exam for this section, let‚Äôs combine an elided index with indexing by lists to retrieve a cross-section of <code>L</code>. Try to predict the result before entering the expression into your console session.</p>
<pre class="highlight"><code class="language-q">q)L[0 2;;0 1]
_</code></pre>
<p>Interpret this as,</p>
<blockquote>
<p>Retrieve the items at positions 0 and 1 from all columns in rows 0 and 2</p>
</blockquote>
<div class="admonition tip">
<p class="admonition-title">Style Recommendation</p>
<p>In general, it is permissible to elide all trailing semicolons arising from elided indices. We consider this bad practice. Looking at the notation below, would you guess that the expression after the comment arose from that to the left of it? We didn‚Äôt think so.</p>
<pre><code class="language-q">
L[1;;] / instead of L[1]
L[;1;] / instead of L[;1]
</code></pre>
</div>
<h2 id="311-rectangular-lists-and-matrices">3.11 Rectangular Lists and Matrices</h2>
<h3 id="3111-rectangular-lists">3.11.1 Rectangular Lists</h3>
<p>In this section, we further investigate matrix-like nested lists. A rectangular list is a list of lists all having the same count. This does not mean that a rectangular list is necessarily a traditional matrix, since there can be additional levels of nesting.</p>
<pre class="highlight"><code class="language-q">q)L:(1 2 3; (10 20; 100 200; 1000 2000))
q)L
1 2 3
10 20 100 200 1000 2000</code></pre>
<p>A rectangular list can be transposed with <a href="https://code.kx.com/q/ref/flip/"><code>flip</code></a>, meaning that the rows and columns are reflected across the diagonal. When <code>flip</code> is applied to a rectangular list, it physically transposes the data ‚Äì i.e., it allocates new storage and copies the original data in column order.</p>
<pre class="highlight"><code class="language-q">q)L:(1 2 3; 10 20 30; 100 200 300)
q)L
1 2 3
10 20 30
100 200 300
q)flip L
1 10 100
2 20 200
3 30 300</code></pre>
<p>This effectively reverses the first and second slots in indexing at depth.</p>
<pre class="highlight"><code class="language-q">q)L:(1 2 3; 10 20 30; 100 200 300)
q)M:flip L
q)L[1;2]
30
q)M[2;1]
30</code></pre>
<h3 id="3112-formal-definition-of-matrices">3.11.2 Formal Definition of Matrices</h3>
<p>Matrices are a special case of rectangular lists and are defined recursively. A matrix of dimension 0 is a scalar. A matrix of dimension 1 is a simple list ‚Äì i.e., a vector. The count of a vector is usually called its length or dimension in mathematics. Some functional programming languages have tuples, which can be thought of as coordinates of fixed-dimension vectors with respect to a basis; q does not.</p>
<p>In q, vectors do not need to be of numeric type.</p>
<pre class="highlight"><code class="language-q">q)v1:1 2 3 / vector of integers
q)v2:98.60 99.72 100.34 101.93 / float vector
q)v3:`so`long`and`thanks`for`all`the`fish / symbol vector</code></pre>
<p>For <em>n</em>&gt;1, we define a <em>matrix of dimension n</em> as a list of matrices of dimension <em>n</em> - 1 all having the same size. Thus, a matrix of dimension 2 is a list of vectors, all having the same size. If all atoms in a matrix have the same type, we call this the <em>type</em> of the matrix.</p>
<h3 id="3113-two-and-three-dimensional-matrices">3.11.3 Two- and Three-Dimensional Matrices</h3>
<p>Let <code>m</code> be a two-dimensional matrix as defined in the previous section. The items of <code>m</code> are its <em>rows</em>. As we have already seen, the <em>i<sup>th</sup></em> row of <code>m</code> can be obtained via item indexing as <code>m[i]</code>. Equivalently, we can use an elided index with indexing at depth to obtain the <em>i<sup>th</sup></em> row as <code>m[i;]</code>.</p>
<p>The console display of <code>m</code> in tabular form motivates defining the list <code>m[;j]</code> as the <em>j</em><sup>th</sup> <em>column</em> of m. The notations <code>m[i][j]</code> and <code>m[i;j]</code> both retrieve the same item ‚Äì namely, the item in row <em>i</em> and column <em>j</em>.</p>
<p>We make one final observation. Matrices are nested lists stored in row order. When the rows are simple, each occupies contiguous storage. This makes row retrieval very fast. On the other hand, columns must be picked out of the rows, so column operations are slower.</p>
<div class="admonition advanced">
<p class="admonition-title">Advanced</p>
<p>By convention we consider a matrix to be a collection of rows. It would be equally valid to consider each vector as a column and a two dimensional array as a collection of columns. As we shall see in <a href="https://code.kx.com/q4m3/8_Tables/">Chapter 8</a>, a table is a collection of columns that are logically (not physically) transposed for ease of indexing. The constraints and calculations of q-sql operate on table column lists, so they are fast, especially when the columns are simple lists. In particular, a simple time series can be represented by two parallel lists, one holding temporal values and the other holding the associated values. Retrieving and manipulating the columns in vector operations is faster by orders of magnitude than performing the same operations in an RDBMS that stores data in rows with undefined order.</p>
</div>
<p>Higher-dimensional matrices occur less frequently in q than in its ancestors. For completeness, here is an example of a three-dimensional 2√ó3√ó2 matrix ‚Äì i.e., each of the two top-level items is a 3√ó2 matrix. Observe that the console display of <code>mm</code> is unenlightening.</p>
<pre class="highlight"><code class="language-q">q)mm:((1 2;3 4;5 6);(10 20;30 40;50 60))
q)mm
_
q)mm[0]
_
q)mm[1]
_</code></pre>
<h2 id="3114-matrix-flexibility">3.11.4 Matrix Flexibility</h2>
<p>We have seen that although there is no separate construct for matrices in q, rectangular lists look and act like their mathematical matrix counterparts. However, they have features not available in simple mathematical notation or in most traditional languages. We have seen that a rectangular list can be viewed and manipulated both as a multi-dimensional array (i.e., indexing at depth) and as an array of arrays (repeated item indexing). In addition, we can extend individual item indexing with indexing via lists.</p>
<pre class="highlight"><code class="language-q">q)m:(1 2; 10 20; 100 200; 1000 2000)
q)m 0 2
_</code></pre>
<h2 id="312-useful-list-operations">3.12 Useful List Operations</h2>
<p>In this section we demonstrate basic use cases for some list operations that are frequently used in following chapters.</p>
<h3 id="3121-til">3.12.1 <code>til</code></h3>
<p>The unary <a href="https://code.kx.com/q/ref/til/"><code>til</code></a> takes a non-negative integer n and returns a list of n consecutive natural numbers starting at 0. It is useful for constructing regular lists of integers.</p>
<pre class="highlight"><code class="language-q">q)til 10
0 1 2 3 4 5 6 7 8 9
q)1+til 10
_
q)2*til 10
_
q)1+2*til 10
_
q)-5+4*til 3
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">If your code includes constructs of the form <em>function</em> <code>each til count ‚Ä¶</code>you are almost certainly writing loopy ‚Äì i.e., non-vector ‚Äì code, otherwise known as VBQ.</p>
</div>
<h3 id="3122-distinct">3.12.2 <code>distinct</code></h3>
<p>The unary function <a href="https://code.kx.com/q/ref/distinct/"><code>distinct</code></a> returns the unique items in its list argument, in order of first occurrence.</p>
<pre class="highlight"><code class="language-q">q)distinct 1 2 3 2 3 4 6 4 3 5 6
1 2 3 4 6 5</code></pre>
<h3 id="3123-where">3.12.3 <code>where</code></h3>
<p>The basic form of <a href="https://code.kx.com/q/ref/where/"><code>where</code></a> returns the indices of <code>1b</code> in a boolean list ‚Äì i.e., it reports where the ones are.</p>
<pre class="highlight"><code class="language-q">q)where 101010b
0 2 4</code></pre>
<p>This is useful to operate at positions that are indentified by a predicate.</p>
<pre class="highlight"><code class="language-q">q)L:10 20 30 40 50
q)L[where L&gt;20]:42
q)L
_</code></pre>
<h3 id="3124-group">3.12.4 <code>group</code></h3>
<p>The unary function <a href="https://code.kx.com/q/ref/group/"><code>group</code></a> takes a list and returns a dictionary in which each distinct item of the argument is mapped to the indices of its occurrences, in order of occurrence.</p>
<pre class="highlight"><code class="language-q">q)group "i miss mississippi"
i| 0 3 8 11 14 17
 | 1 6
m| 2 7
s| 4 5 9 10 12 13
p| 15 16</code></pre>
                


                
              
              
                


              
            </article>
            
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))for(var set of document.querySelectorAll("[data-tabs]")){var labels=set.querySelectorAll(":scope > label");e:for(var tab of tabs)for(var label of labels)if(label.innerText.trim()===tab){var input=label.previousElementSibling;input.checked=!0;break e}}</script>

          </div>
        </div>
        
          
        
      
                </div>
            </section>
        
            <section class="chapter" id="chapter-9">
                <div class="chapter-header">
                    <h1 class="chapter-title">4. Operators¬∂</h1>
                    <div class="chapter-meta">
                        <span>üìñ Source: <a href="https://code.kx.com/q4m3/4_Operators/">https://code.kx.com/q4m3/4_Operators/</a></span>
                        <span>üìù 5157 words</span>
                        
                    </div>
                </div>
                <div class="chapter-content">
                    
        <div class="md-main__inner md-grid">
          
            
              
              
            
            
              
              
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                
                <h1 id="4-operators">4. Operators</h1>
<h2 id="40-operators-and-keywords-are-functions">4.0 Operators and Keywords Are Functions</h2>
<!-- 
Purists call the q operators _verbs_. Reading the expression `2+3` right-to-left as ‚Äú3 added to 2,‚Äù the operand `3` is a noun (subject), the operator `+` is a verb and the operand `2` is a noun (object). They are really just built-in functions. We shall use all three terminologies ‚Äì _operator_, _function_, and _verb_ ‚Äì interchangeably.
 -->

<h3 id="401-function-notation">4.0.1 Function Notation</h3>
<p>Operators are built-in functions which can be used with in-fix notation. We examine functions in depth in <a href="https://code.kx.com/q4m3/5_Dictionaries/">Chapter 5</a>, but cover some salient points here. There are two main differences between the functions we can write and built-in functions.</p>
<ul>
<li>Our functions must have alphanumeric names whereas q functions can have purely symbolic names.</li>
<li>Our functions can only be used in prefix notation whereas q functions can be used prefix or infix.</li>
</ul>
<p>Function application in q uses square brackets to enclose the arguments, and semicolons to separate multiple arguments. Thus the output value of a unary function <code>f</code> for the input <code>x</code> is written <code>f[x]</code> We can omit the brackets for unary application and write <code>f x</code>. Application of a binary function <code>g</code> on arguments <code>x</code> and <code>y</code> is written <code>g[x;y]</code> in prefix or <code>x g y</code> in infix.</p>
<p>An <em>atomic</em> function acts recursively on data structures. For example, applying it to a list is the same as applying it to each item in the list.</p>
<h3 id="402-primitives-verbs-and-functional-notation">4.0.2 Primitives, Verbs and Functional Notation</h3>
<p>The normal way of writing addition in mathematics and most programming 
languages uses an operator with infix notation ‚Äì e.g., addition is written with a plus symbol between the two operands.</p>
<pre class="highlight"><code class="language-q">2+3</code></pre>
<p>In q, we can write addition this way and read it right-to-left as ‚Äúadd 3 to 2.‚Äù.</p>
<pre class="highlight"><code class="language-q">q)2+3
_</code></pre>
<!-- 
A q binary function written with infix notation is also called a *verb*. This terminology arises from thinking of the operands as nouns that the functions act on. Although some purists are strict in using this terminology, we shall not be.
 -->
<p>The <em>primitive operators</em> are built-in functions, including the basic arithmetic, relation and comparison operators. Some are represented by a single ASCII symbol such as <code>+</code>, <code>-</code>, <code>=</code>, and <code>&lt;</code>. Others use compound symbols, such as <code>&lt;=</code>, <code>&gt;=</code>, and <code>&lt;&gt;</code>. Keywords have names such as <code>not</code> or <code>neg</code>.</p>
<p>Operators and keywords can also be used with ordinary function notation. For example, we can also use <code>+</code> as a binary function that takes two numeric arguments and returns a numeric result. You probably wouldn't think twice at seeing <code>sum[a;b]</code> but you might blink at the following perfectly logical equivalent.</p>
<pre class="highlight"><code class="language-q">q)+[2;3]
_</code></pre>
<p>Qbies will definitely need to get accustomed to,</p>
<pre class="highlight"><code class="language-q">q)=[2;3]
_</code></pre>
<p>It is even possible to apply an operator using a combination of infix and functional notation. This may look strange, even to initiates.</p>
<pre class="highlight"><code class="language-q">q)(2+)[3]
5
q)(2+)3
_</code></pre>
<h3 id="403-extension-of-atomic-functions">4.0.3 Extension of Atomic Functions</h3>
<p>A fundamental feature of atomic functions is that their action extends automatically to the items in a list. Of course, if you want to combine two lists they must be of the same length.</p>
<pre class="highlight"><code class="language-q">q)neg 1 2 3
-1 -2 -3
q)1 2 3+10 20 30
11 22 33
q)1 2 3+10 20 30 40
'length</code></pre>
<p>This applies to nested lists as well, provided they conform in shape for multivalent functions.</p>
<pre class="highlight"><code class="language-qq">q)neg (1 2 3; 4 5)
-1 -2 -3
-4 -5
q)(1 2 3; 4 5)+(100 200 300; 400 500)
101 202 303
404 505</code></pre>
<p>Another fundamental property of atomic operators is that they implicitly extend atom arguments to match lists.</p>
<pre class="highlight"><code class="language-q">q)100+1 2 3
101 102 103
q)1 2 3+100
_</code></pre>
<p>Atom extension also applies with nested lists.</p>
<pre class="highlight"><code class="language-q">q)100+(1 2 3; 4 5)
101 102 103
104 105
q)(1 2 3; 4 5)+100
_</code></pre>
<h2 id="41-operator-precedence">4.1 Operator Precedence</h2>
<p>There is none.</p>
<h3 id="411-traditional-operator-precedence">4.1.1 Traditional Operator Precedence</h3>
<p>Mathematical operators and most programming languages have a concept of operator precedence, which attempts to resolve ambiguities in the evaluation of arithmetic and logical operations in expressions. The arithmetic precedence rules were drummed into you in elementary school: multiplication and division are equal and come before addition and subtraction, etc. There are similar precedence rules for =, &lt;, &gt;, ‚Äòand‚Äô and ‚Äòor‚Äô.</p>
<h3 id="412-left-of-right-evaluation">4.1.2 Left-of-Right Evaluation</h3>
<p>Although the traditional notion of operator precedence has the weight of incumbency (not to mention the imprecations of your fifth grade math teacher), it‚Äôs time to throw the bum out. As mentioned in <a href="https://code.kx.com/q4m3/1_Q_Shock_and_Awe/">Chapter 1</a>, q has no rules for operator precedence. Instead, it has one simple rule for evaluating any expression:</p>
<p>Expressions are evaluated left-<strong>of</strong>-right</p>
<p>which equates to</p>
<p>Expressions are evaluated right-<strong>to</strong>-left</p>
<p>Please review the <a href="https://code.kx.com/q4m3/0_Overview/#02-mathematics-refresher">Mathematics Refresher</a> if the notion of left-of-right is new to you. The short version is that the composite <em>f(g(x))</em>, read ‚Äúf of g of x‚Äù is evaluated by first substituting <em>x</em> into <em>g</em> and then substituting that result into <em>f</em>. Evaluating the inner function first actually becomes right-to-left. Thinking functionally makes ‚Äúof‚Äù a paradigm not just a preposition.</p>
<p>The adoption of left-of-right evaluation frees q to treat expression evaluation simply and uniformly without redundant parentheses getting in the way. Infix or prefix notation can be used as suits the occasion. Left-of-right expression evaluation also means that there is no ambiguity in any expression ‚Äì from the compiler‚Äôs perspective if not yours. Parentheses can always be used to group terms and override the default evaluation order but there will be far fewer once you abandon old (bad) habits.</p>
<div class="admonition tip">
<p class="admonition-title">Arrange your expressions with the goal of placing parentheses and brackets on the endangered species list. Most are just programming noise unless you insist on writing Lisp.</p>
</div>
<h3 id="413-the-gotcha-of-left-of-right-evaluation">4.1.3 The Gotcha of Left-of-Right Evaluation</h3>
<p>Due to left-of-right evaluation, parentheses <strong>are</strong> needed to isolate the result of an expression that is the left operand of an infix operator. Let‚Äôs take a closer look at this.</p>
<p>In any language you might have seen, the following expression evaluates to 10 but not in q. You can parenthesize or rearrange to get 10.</p>
<pre class="highlight"><code class="language-q">q)2*3+4
14
q)(2*3)+4
10
q)4+2*3
10</code></pre>
<p>In some cases parentheses are simply unavoidable.</p>
<pre class="highlight"><code class="language-q">q)(2+3)*3+4
35</code></pre>
<p>This is the one (and only) situation in which parentheses are necessary in q.</p>
<blockquote>
<p>If the left operand of an operator is an expression it <strong>must</strong> be parenthesized, otherwise the operator will bind to the right-most element of the expression.</p>
</blockquote>
<div class="admonition tip">
<p class="admonition-title">Redundant parentheses</p>
<p>These parentheses on the left are often not needed in traditional programming and their omission in an overzealous extermination campaign is a common error for qbies. Please don‚Äôt overreact by putting parentheses around all operands ‚Äúto be safe.‚Äù Spend five seconds and think about it. Eventually it will be second nature.</p>
</div>
<h3 id="414-rationale-for-no-operator-precedence">4.1.4 Rationale for No Operator Precedence</h3>
<p>Operator precedence as normally encountered in programming languages is feeble. It requires all the components of an expression to be analyzed before anything can be evaluated. Moreover, it often results in the use of parentheses to override the very rules that are purportedly there to help.</p>
<p>Even more damning is that operator precedence forces complexity. Some programming languages (not q) allow user-written binary functions to be operators. This would entail the extension of precedence levels to cover user functions, even those as yet unborn. If you‚Äôve worked in such a language, you eventually run out of precedence levels (and patience) and end up needing parentheses with operators of the same precedence!</p>
<h2 id="42-match">4.2 Match <code>~</code></h2>
<p>The non-atomic binary <a href="https://code.kx.com/q/ref/match/" title="Match">Match</a> operator <code>~</code> applies to any two q entities, returning the boolean result <code>1b</code> if they are identical and <code>0b</code> otherwise. For two entities to match, they must have the same shape, the same type and the same value(s), but they may occupy separate storage locations. Colloquially, clones are considered identical in q.</p>
<p>This differs from the notion of identity in many traditional languages having pointers or objects. For example, in OO languages of C ancestry, objects are equal if and only if their underlying pointers address the same memory location. Identical twins are <strong>not</strong> equal. You must write your own method to determine if one object is a deep copy of another.</p>
<p>There are no restrictions as to the type or shape of the two operands for Match. Try to predict each of the following results of Match as you enter them into your console session.</p>
<pre class="highlight"><code class="language-q">q)42~40+2
_
q)42~42h
_
q)42f~42.0
_
q)42~`42
_
q)`42~"42"
_
q)4 2~2 4
_
q)42~(4 2;(1 0))
_
q)(4 2)~(4;2*1)
_
q)(())~enlist ()
_
q)(1; 2 3 4)~(1; (2; 3; 4))
_
q)(1 2;3 4)~(1;2 3 4)
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Use Match to test</p>
<p>While learning or debugging q (except for the q gods who write perfect q code every time), applying Match can be an effective way to determine if you have what you intended. For example, qbies often trip over the following, thinking the latter is a singleton list.
</p><pre><code class="language-q">
q)42~(42)
1b 
</code></pre>
</div>
<h2 id="43-equality-and-relational-operators">4.3 Equality and Relational Operators</h2>
<p>It comes as a surprise to many who are new to vector programming that relational operators are atomic functions that return boolean values. Relational operations do not require the types of their operands to match, but they must be compatible.</p>
<h3 id="431-equality-and-disequality">4.3.1 Equality <code>=</code> and Disequality &lt;&gt;</h3>
<p>The <a href="https://code.kx.com/q/ref/equal/" title="Equal">equality operator</a> <code>=</code> differs from Match <code>~</code> in that it is atomic in both operands, meaning it tests its operands atom-wise instead of in entirety. All atoms of numeric, temporal or char type are mutually compatible for equality, but symbols are compatible only with symbols.</p>
<p>Equality tests whether two compatible atoms represent the same value, without regard to type.</p>
<pre class="highlight"><code class="language-q">q)42=42i
_
q)42=42.0
_
q)42=0x42
_
q)42="*"
_</code></pre>
<p>That last one may come as a surprise. It simply reflects that the underlying bit pattern of the ASCII char <code>*</code> is the same as the underlying bit pattern for the integer 42.</p>
<p>For temporal types the comparison is between the points on the calendar/clock rather than the underlying counts.</p>
<pre class="highlight"><code class="language-q">q)2000.01.01=2000.01.01D00:00:00.000000000
1b
q)2015.01.01&lt;2015.02m
1b
q)12:00:00=12:00:00.000
1b</code></pre>
<p>A symbol and a character are not compatible and an error results from the test,</p>
<pre class="highlight"><code class="language-q">q)`a="a"
'type</code></pre>
<p>The <a href="https://code.kx.com/q/ref/not-equal/" title="Not Equal">not-equal primitive is</a> <code>&lt;&gt;</code>.</p>
<pre class="highlight"><code class="language-q">q)42&lt;&gt;0x42
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">The test ‚Äúnot equal‚Äù can also be achieved by applying <code>not</code> to the result of testing with <code>=</code>. This what <code>&lt;&gt;</code> actually does.</p>
<pre><code class="language-q">
q)not 42=98.6
_ 
</code></pre>
</div>
<p>When comparing floats, q uses multiplicative tolerance for non-zero values, which makes floating point arithmetic give reasonable results. At the time of this writing (Sep 2015) the tolerance is <span class="arithmatex">\(10^{-14}\)</span>.</p>
<pre class="highlight"><code class="language-q">q)r:1%3
q)r
0.3333333
q)2=r+r+r+r+r+r
1b</code></pre>
<h3 id="432-not-zero-not">4.3.2 Not Zero <code>not</code></h3>
<p>The unary, atomic keyword <a href="https://code.kx.com/q/ref/not/"><code>not</code></a> differs from its equivalent in some traditional languages. It returns a boolean result and has domain of all numeric, temporal and character types; it is not defined for symbols. The <code>not</code> keyword generalizes the reversal of true and false bits to any entity having an underlying numeric value. It answers the Hamletonian question: to be, or not to be, zero.</p>
<p>The test against zero yields the expected results for boolean arguments.</p>
<pre class="highlight"><code class="language-q">q)not 0b
_
q)not 1b
_</code></pre>
<p>The test against zero applies for any type with underlying numeric value.</p>
<pre class="highlight"><code class="language-q">q)not 0b
_
q)not 1b
_
q)not 42
_
q)not 0
_
q)not 0xff
_
q)not 98.6
_</code></pre>
<p>For char values, <code>not</code> returns <code>0b</code> except for the character representing the underlying value of 0.</p>
<pre class="highlight"><code class="language-q">q)not "*"
_
q)not " "
_
q)not "\000"
_</code></pre>
<p>For temporal values, an underlying 0 corresponds to the stroke of midnight at the millennium for types including a date and simply midnight for time-only types.</p>
<pre class="highlight"><code class="language-q">q)not 2000.01.01
_
q)not 2014.01.01
_
q)not 2000.01.01T00:00:00.000000000
_
q)not 2000.01m
_
q)not 00:00:00
_
q)not 12:00:00.000000000
_</code></pre>
<h3 id="433-order">4.3.3 Order: &lt;, &lt;=, &gt;, &gt;=</h3>
<p><a href="https://code.kx.com/q/basics/comparison/#six-comparison-operators">Less Than <code>&lt;</code>, Greater Than <code>&gt;</code> Up To <code>&lt;=</code> and At Least <code>&gt;=</code></a> are atomic and are defined for all compatible atom types. Numeric and char types are mutually compatible, but symbols are only compatible with symbols. As with equality, comparison for numeric and char types is based on underlying numeric value, independent of type.</p>
<pre class="highlight"><code class="language-q">q)4&lt;42
_
q)4h&gt;0x2a
_
q)-1.4142&lt;99i
_</code></pre>
<p>As with equality, the comparison for temporal types is between the points on the calendar/clock rather than the underlying counts.</p>
<pre class="highlight"><code class="language-q">q)2000.01.01&lt;2000.01.01D00:00:00.000000001
1b
q)2015.01.01&lt;2015.02m
_
q)12:00:01&gt;12:00:00.000
_</code></pre>
<p>For char atoms, comparing the underlying numeric value follows the ASCII collation sequence.</p>
<pre class="highlight"><code class="language-q">q)"A"&lt;"Z"
_
q)"a"&lt;"Z"
_
q)"A"&lt;"O"
_
q)"?"&lt;"?"
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">To see the entire ASCII collation sequence in compact form</p>
<pre><code class="language-q">
q)16 16#"c"$til 256
_
</code></pre>
</div>
<p>Symbol comparison is based on lexicographic order.</p>
<pre class="highlight"><code class="language-q">q)`a&lt;`b
_
q)`abc&lt;`aba
_</code></pre>
<p>Now that we are familiar with relational operations on atoms, let‚Äôs examine their item-wise extensions to simple lists. Notice the simple boolean list returned.</p>
<pre class="highlight"><code class="language-q">q)2 1 3=1 2 3
_
q)10 20 30&lt;=30 20 10
_
q)2=1 2 3
_
q)"zaphod"="Arthur"
_
q)`a`b`a`d=`a`d`a`b
_</code></pre>
<h2 id="44-basic-arithmetic-">4.4 Basic Arithmetic: <code>+</code>, <code>-</code>, <code>*</code>, <code>%</code></h2>
<p>The arithmetic operators are atomic and come in binary and unary flavors. We begin with the four operations of elementary arithmetic. Arithmetic operations are defined for all numeric and temporal types, and all numeric types are compatible.</p>
<table>
<thead>
<tr>
<th><em>Symbol</em></th>
<th><em>Name</em></th>
<th><em>Example</em></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>+</code></td>
<td>Add</td>
<td><code>42+67</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td>Subtract</td>
<td><code>42.0-5.3456</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>Multiply</td>
<td><code>2h*3h</code></td>
</tr>
<tr>
<td><code>%</code></td>
<td>Divide By</td>
<td><code>42%6</code></td>
</tr>
</tbody>
</table>
<p>Arithmetic looks pretty much like other programming languages, except that division is represented by <code>%</code> since <code>/</code> is used to delimit comments. Simon Garland of KX points out that this is actually closer to <code>√∑</code> (division) the way God meant it to be written.</p>
<pre class="highlight"><code class="language-q">q)2+3
_
q)a:6
q)b:7
q)b-a
_
q)a*b
_
q)4%2
2f</code></pre>
<div class="admonition info">
<p class="admonition-title">The result of division is always a float.</p>
</div>
<p>The major learning adjustment in q arithmetic expressions is due to left-of-right evaluation and the absence of precedence.</p>
<pre class="highlight"><code class="language-q">q)6*3+4
42</code></pre>
<p>Type promotion for arithmetic operators follows two rules:</p>
<ul>
<li>Binary types are promoted to int</li>
<li>The result type of an operation is the narrowest type that will accommodate both operands.</li>
</ul>
<p>Here are examples of binary data promotion. Note that arithmetic on booleans is <strong>not</strong> performed modulo 2.</p>
<pre class="highlight"><code class="language-q">q)1b+1b
2i
q)42*1b
42
q)5i*0x2a
210i</code></pre>
<div class="admonition warning">
<p class="admonition-title">Overflow and underflow are not trapped on arithmetic operations on integer types.</p>
<pre><code class="language-q">
q)9223372036854775806+4
-9223372036854775806
q)2*5223372036854775800
-8000000000000000016
q)-9223372036854775806-4
9223372036854775806
</code></pre>
</div>
<p>When a floating-point type occurs in an expression, the result is a float.</p>
<pre class="highlight"><code class="language-q">q)6+7.0
13f
q)1.0+1b
2f
q)6.0*7.0e
42f</code></pre>
<div class="admonition tip">
<p class="admonition-title">The symbols for arithmetic operators are  binary.</p>
<p>In particular, while <code>-</code> is used as a lexical marker to denote a negative number, there is no unary function <code>-</code> to negate a numeric value. Its attempted use for such generates an error. Use the operator <code>neg</code> instead
</p><pre><code class="language-q">
q)42
42
q)-42
-42
q)a:42
q)-a / error
'-
q)neg a
-42
</code></pre>
</div>
<p>Being atomic, arithmetic operators and their type promotion are performed atom-wise on lists.</p>
<pre class="highlight"><code class="language-q">q)1.0+10 20 30
_
q)10 20 30%1 2 3
_
q)100 200 300+1b
_
q)1+(100 200;1000 2000)
_</code></pre>
<h2 id="45-greater-and-lesser">4.5 Greater <code>|</code> and Lesser &amp;</h2>
<p>These atomic binary operators follow the same type promotion and compatibility rules as arithmetic operators. They are defined for all values with underlying numeric values but are not defined for symbols and GUIDs.</p>
<p>The <a href="https://code.kx.com/q/ref/greater/">Greater</a> operator <code>|</code> returns the larger of its operands; this reduces to logical ‚Äúor‚Äù for binary operands. The <a href="https://code.kx.com/q/ref/lesser/">Lesser</a> operator <code>&amp;</code> returns the smaller of its operands, which reduces to logical ‚Äúand‚Äù for binary operands.</p>
<pre class="highlight"><code class="language-q">q)42|43
_
q)98.6&amp;101.9
9_
q)0b|1b
_
q)1b&amp;0b
_
q)42|0x2b
_
q)"a"|"z"
"_
q)`a|`z / error
_</code></pre>
<p>Being atomic they operate item-wise on lists.</p>
<pre class="highlight"><code class="language-q">q)2|0 1 2 3 4
_
q)11010101b&amp;01100101b
_
q)"zaphod"|"arthur"
_</code></pre>
<p>For readability of logical operations on binary data, <code>|</code> can also be written as <code>or</code> and <code>&amp;</code> can be written as <code>and</code>.</p>
<pre class="highlight"><code class="language-q">q)1b or 0b
_
q)1b and 0b
_
q)42 or 43
_</code></pre>
<h2 id="46-amend">4.6 Amend <code>:</code></h2>
<p>An overload of <code>:</code> that is ‚Äúassign in place.‚Äù</p>
<h3 id="461-amend-in-c-language">4.6.1 Amend in C Language</h3>
<p>We are familiar with the basic form of assignment.</p>
<pre class="highlight"><code class="language-q">q)a:42</code></pre>
<p>Programmers from languages with C heritage are familiar with expressions such as,</p>
<pre class="highlight"><code class="language-c">x += 2; // C expression that assigns in place</code></pre>
<p>This has the same effect as the following but can be more efficiently implemented at the machine instruction level.</p>
<pre class="highlight"><code class="language-c">x = x + 2; // C expression</code></pre>
<p>Reading the first statement succinctly as <em>add 2 to x in place</em> motivates the interpretation of the operation as ‚Äúamend‚Äù. To wit, the value assigned to <code>x</code> is amended by applying the operation <code>+</code> with the supplied operand 2.</p>
<h3 id="462-simple-q-amend">4.6.2 Simple q Amend</h3>
<p>Transliterating the above C expression to q yields the <code>+:</code> operation to amend a variable in place.</p>
<pre class="highlight"><code class="language-q">q)x:42
q)x+:1
q)x
_</code></pre>
<p>There is nothing special about <code>+</code> here. <a href="https://code.kx.com/q/basics/syntax/#colon">Amend</a> can be used with any symbolic operator having compatible signature.</p>
<pre class="highlight"><code class="language-q">q)a:43
q)a-:1
q)a
_
q)a&amp;:21
q)a
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">In spite of the linguistic dissonance, a q variable can be amended even if it has not been previously assigned.</p>
<p>In a fresh q session:</p>
<pre><code class="language-q">
q)x
'x
q)x+:42
q)x
_
</code></pre>
</div>
<h3 id="463-amend-with-lists">4.6.3 Amend with Lists</h3>
<p>The capability to modify in place extends to lists and indexing.</p>
<pre class="highlight"><code class="language-q">q)L:100 200 300 400
q)L[1]+:99
q)L
_
q)L[1 3]-:1
q)L
_
q)L1:(1 2 3; 10 20 30)
q)L1[;2]+:100
q)L1
_</code></pre>
<p>A very useful idiom is <code>,:</code> which appends to a list in place.</p>
<pre class="highlight"><code class="language-q">q)L:1 2 3
q)L,:4
q)L
_
q)L,:100 200
q)L
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Amend does type promotion based on the operator it is combined with, except for <code>,:</code> which requires exact type match.</p>
<pre><code class="language-q">
q)L:1.1 2 2 3.3
q)L[1]+:100
q)L,:100
'type
</code></pre>
</div>
<h2 id="47-exponential-primitives-sqrt-exp-log-xexp-xlog">4.7 Exponential Primitives: <code>sqrt</code>, <code>exp</code>, <code>log</code>, <code>xexp</code>, <code>xlog</code></h2>
<h3 id="471-sqrt">4.7.1 <code>sqrt</code></h3>
<p>The atomic unary <a href="https://code.kx.com/q/ref/sqrt/"><code>sqrt</code></a> has as domain all numeric values and returns a float representing the square root of its input. It returns null when the square root is not defined.</p>
<pre class="highlight"><code class="language-q">q)sqrt 2
_
q)sqrt 42.4
_
q)sqrt 1b
_
q)sqrt -2
_</code></pre>
<h3 id="472-exp">4.7.2 <code>exp</code></h3>
<p>The atomic unary <a href="https://code.kx.com/q/ref/exp/"><code>exp</code></a> has as domain all numeric values and returns a float representing the base <em>e</em> raised to the power of its input.</p>
<pre class="highlight"><code class="language-q">q)exp 1
_
q)exp 4.2
_
q)exp -12i
_</code></pre>
<div class="admonition warning">
<p class="admonition-title">Do not confuse the <code>e</code> used in the display of base-10 scientific notation with the mathematical base of exponentials and natural logarithms.</p>
<pre><code class="language-q">
q)1e10 / this is ten billion
1e+10 
</code></pre>
</div>
<h3 id="473-log">4.7.3 <code>log</code></h3>
<p>The atomic unary <a href="https://code.kx.com/q/ref/log/"><code>log</code></a> has as domain all numeric values and returns a float representing the natural logarithm of its input. It returns null when the logarithm is not defined.</p>
<pre class="highlight"><code class="language-q">q)log 1
_
q)log 42.0
_
q)log .0001
_
q)log -1
_</code></pre>
<h3 id="474-xexp">4.7.4 <code>xexp</code></h3>
<p>The atomic binary <a href="https://code.kx.com/q/ref/xexp/"><code>xexp</code></a> has as domain all numeric values in both operands and returns a float representing the left operand raised to the power of the right operand. When the mathematical operation is undefined, the result is null.</p>
<pre class="highlight"><code class="language-q">q)2 xexp 5
_
q)-2 xexp .5
_</code></pre>
<div class="admonition detail">
<p class="admonition-title">A q naming convention</p>
<p>We point out here, since it is our first encounter, a q naming convention. A unary function ‚Äì e.g., <code>exp</code> ‚Äì sometimes has a binary version ‚Äì <code>xexp</code> ‚Äì with an <code>x</code> prepended to its name. </p>
<p>In classic Arthurian fashion, the rationalization is that the additional parameter is ‚Äòx‚Äô.</p>
</div>
<h3 id="475-xlog">4.7.5 <code>xlog</code></h3>
<p>The atomic binary <a href="https://code.kx.com/q/ref/xlog/"><code>xlog</code></a> has as domain all numeric values in both operands and returns a float representing the logarithm of the right operand with respect to the base of the left operand. When the mathematical operation is undefined the result is null.</p>
<pre class="highlight"><code class="language-q">q)2 xlog 32
-</code></pre>
<pre class="highlight"><code class="language-q">q)2 xlog -1
-</code></pre>
<h2 id="48-more-numeric-primitives">4.8 More Numeric Primitives</h2>
<h3 id="481-integer-division-div-and-modulus-mod">4.8.1 Integer Division <code>div</code> and Modulus <code>mod</code></h3>
<p>The atomic binary <a href="https://code.kx.com/q/ref/div/"><code>div</code></a> is atomic in both operands, which are numeric values. The result is the integer quotient of the left operand (<em>dividend</em>) by the (positive) right operand (<em>divisor</em>), which is equal to the result of normal division rounded <strong>down</strong> to the next lower integer. The operation returns null for non-positive divisor.</p>
<pre class="highlight"><code class="language-q">q)7 div 2
3
q)7 div 2.5
2
q)-7 div 2
-4
q)-7 div 2.5
_
q)7 div -2       / returns -4 in later versions
0N
q)3 4 5 div 2
_
q)7 div 2 3 4
_
q)3 4 5 div 2 3 4
_</code></pre>
<p>The binary <a href="https://code.kx.com/q/ref/mod/"><code>mod</code></a> is atomic in both operands, which are numeric values. The result is the remainder of the integer quotient of the left operand (<em>dividend</em>) by the positive right operand (<em>divisor</em>). It is equal to</p>
<p><em>dividend</em> ‚Äì (<em>dividend</em> div <em>divisor</em>)</p>
<p>The result is null for non-positive divisor.</p>
<pre class="highlight"><code class="language-q">q)7 mod 2
1
q)7 mod 2.5
_
q)-7 mod 2
1
q)-7 mod 2.5
_
q)7 mod -2
_
q)3 4 5 mod 2
_
q)7 mod 2 3 4
_
q)3 4 5 mod 2 3 4
_</code></pre>
<div class="admonition warning">
<p class="admonition-title">Many languages use <code>%</code> for modulus, but it is division in q. This is a common mistake of qbies.</p>
</div>
<h3 id="482-sign-signum">4.8.2 Sign <code>signum</code></h3>
<p>The atomic unary <a href="https://code.kx.com/q/ref/signum/"><code>signum</code></a> has domain all numeric and temporal types and returns an int representing the sign of its input, where <code>1i</code> represents positive, <code>-1i</code> represents negative and <code>0i</code> represents a zero.</p>
<pre class="highlight"><code class="language-q">q)signum 42
1i
q)signum -42.0
_
q)signum 1b
_
q)signum 0
_</code></pre>
<p>Temporal types are treated as their underlying offsets.</p>
<pre class="highlight"><code class="language-q">q)signum 1999.12.31
_
q)signum 12:00:00.000000000
_</code></pre>
<h3 id="483-reciprocal">4.8.3 <code>reciprocal</code></h3>
<p>The atomic unaryÀõ<a href="https://code.kx.com/q/ref/reciprocal/"><code>reciprocal</code></a> has as domain all numeric types and returns the float result of 1.0 divided by the input. It returns the appropriately signed infinity for the reciprocal of 0.</p>
<pre class="highlight"><code class="language-q">q)reciprocal 0.02380952
42.00001
q)reciprocal 0.0
0w
q)reciprocal -0.0
-0w</code></pre>
<h3 id="484-floor-and-ceiling">4.8.4 <code>floor</code> and <code>ceiling</code></h3>
<p>The atomic unary <a href="https://code.kx.com/q/ref/floor/"><code>floor</code></a> has as domain integer and floating-point types and returns a long representing the largest integer that is less than or equal to its argument.</p>
<pre class="highlight"><code class="language-q">q)floor 4.2
4
q)floor 4
_
q) floor -4.2
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">The <code>floor</code> operator can be used to truncate or round floating-point values to a specific number of digits to the right of the decimal.</p>
<pre><code class="language-q">
q)x:4.242
q)0.01*floor 100*x
4.24
</code></pre>
</div>
<p>Analogous to <code>floor</code>, the atomic unary <a href="https://code.kx.com/q/ref/ceiling/"><code>ceiling</code></a> has as domain numeric types and returns the smallest long that is greater than or equal to its argument.</p>
<pre class="highlight"><code class="language-q">q)ceiling 4.2
5
q)ceiling 4
_
q)ceiling -4.2
_</code></pre>
<div class="admonition warning">
<p class="admonition-title">For reasons known only to the q gods, <code>floor</code> and <code>ceiling</code> do not apply to short types.</p>
<pre><code class="language-q">
q)floor 4h
'type 
</code></pre>
<p>(Later versions of kdb+ include shorts in their domains. <em>[Ed.]</em> )</p>
</div>
<h3 id="485-absolute-value-abs">4.8.5 Absolute Value <code>abs</code></h3>
<p>The atomic unary <a href="https://code.kx.com/q/ref/abs/"><code>abs</code></a> has domain all integer and floating-point types. The result is the input when it is greater than or equal to zero and its negation otherwise. The result of <code>abs</code> has the same type as the argument except for binary types, which are type promoted to int.</p>
<pre class="highlight"><code class="language-q">q)abs 42
_
q)abs -42
_
q)abs 1b
_</code></pre>
<h2 id="49-operations-on-temporal-values">4.9 Operations on Temporal Values</h2>
<p>Because all q time values are integral offsets from canonical base points, properties and operations on temporal types are simple. For example, one value of a temporal type comes before another value of the same type just when the same is true of their underlying integer values. When dealing with temporal values of different types, q implicitly promotes to the wider type and then proceeds as just described.</p>
<p>Moreover, basic temporal arithmetic is integer arithmetic. The difference of two (absolute) temporal values of the same type is the span given by the difference of their underlying integer counts. Conversely, given a temporal value, adding an integer to it (i.e., to its underlying integer count) yields a temporal value of the same type.</p>
<p>Casting reveals the underlying integer count of any temporal value.</p>
<pre class="highlight"><code class="language-q">q)`int$1999.12.31
-1i
q)`int$2013.01m
_
q)`int$12:00:00.123
_
q)`long$12:00:00.123456789
_</code></pre>
<div class="admonition note">
<p class="admonition-title">There is no concept of time zone in q temporal values. Those of us who wrestled with Java‚Äôs original time implementation are thankful.</p>
</div>
<h3 id="491-temporal-comparison">4.9.1 Temporal Comparison</h3>
<p>Comparison <strong>within</strong> a temporal type amounts to simple comparison of the underlying integral offsets. Comparison <strong>across</strong> temporal types recognizes that the underlying values express different units and realizes them in common units.</p>
<p>For example, midnight on the second day of the millennium should be equal to the second day, but a na√Øve comparison of the underlying counts will not tell us.</p>
<pre class="highlight"><code class="language-q">q)2000.01.02=2000.01.02D00:00:00.000000000
1b
q)`int$2000.01.02
1i
q)`long$2000.01.02D02:00:00.000000000
93600000000000</code></pre>
<p>Values of different types should be compared in the same units, which effectively amounts to converting to the most granular units. The Cast operator has the logic for such conversions built-in.</p>
<pre class="highlight"><code class="language-q">q)`timestamp$2001.01.02
2001.01.02D00:00:00.000000000</code></pre>
<p>To compare temporal values of different types, q converts to the most granular type and then does a straight comparison of the underlying values.</p>
<pre class="highlight"><code class="language-q">q)2000.01.01&lt;2000.01.01D12:00:00.000000000
_</code></pre>
<h3 id="492-temporal-arithmetic">4.9.2 Temporal Arithmetic</h3>
<p>In contrast to many traditional languages, expressions involving temporal types and numerical types that should make sense actually work as expected. For example, temporal values <strong>are</strong> their underlying offsets for equality and comparison testing against numeric values.</p>
<pre class="highlight"><code class="language-q">q)2000.01.01=0
1b
q)12:00:00=12*60*60
_
q)1999.12.31&lt;0
_</code></pre>
<p>Adding an integral value to a temporal value works because it is just added to the underlying offset.</p>
<pre class="highlight"><code class="language-q">q)2014.12.31+1
_
q)2015.01.01+til 31 / all days in January
_
q)12:00:00+1</code></pre>
<p>Adding a temporal value to another causes it to be viewed as a span, as you would want.</p>
<pre class="highlight"><code class="language-q">q)12:00:00+01:00:00
_</code></pre>
<p>One important case is adding a timespan to a date to yield a timestamp. There is actually some calculation under the covers to make this work.</p>
<pre class="highlight"><code class="language-q">q)2015.01.01+12:00:00.000000000
2015.01.01D12:00:00.000000000</code></pre>
<p>The difference between two values of a temporal type that counts days is the int difference of their underlying day counts.</p>
<pre class="highlight"><code class="language-q">q)2001.01.01-2000.01.01
366i
q)2015.06m-2015.01m
_</code></pre>
<p>The difference between two values of a type with time is the difference of the underlying offsets, expressed as the same type ‚Äì i.e., as a span.</p>
<pre class="highlight"><code class="language-q">q)2015.01.01D00:00:00.000000000-2014.01.01D00:00:00.000000000
365D00:00:00.000000000
q)12:00:00-11:00:00
_
q)12:00-11:00
_</code></pre>
<h2 id="410-operations-on-infinities-and-nulls">4.10 Operations on Infinities and Nulls</h2>
<p>Here we summarize the various behaviors of nulls and infinities in one place.</p>
<p>The float infinities and nulls act in the mathematically correct fashion in numeric expressions and comparisons. Integer infinities act correctly in comparisons and act as their underlying (finite) values in other operations.</p>
<p>The bit patterns of the integral nulls and infinities are legitimate base-2 integral representations with the high-order bit being the sign.</p>
<table>
<thead>
<tr>
<th><em>Value</em></th>
<th><em>Bit Representation</em></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0Wh</code></td>
<td><code>0111111111111111b</code></td>
</tr>
<tr>
<td><code>-0Wh</code></td>
<td><code>1000000000000001b</code></td>
</tr>
<tr>
<td><code>0Wi</code></td>
<td><code>01111111111111111111111111111111b</code></td>
</tr>
<tr>
<td><code>-0Wi</code></td>
<td><code>10000000000000000000000000000001b</code></td>
</tr>
<tr>
<td><code>0W</code></td>
<td><code>0111111111111111111111111111111111111111111111111111111111111111b</code></td>
</tr>
<tr>
<td><code>-0W</code></td>
<td><code>1000000000000000000000000000000000000000000000000000000000000001b</code></td>
</tr>
</tbody>
</table>
<p>The same type-promotion rules apply to a null as for a normal value of that type.</p>
<p>An infinity value equals or matches only itself. All nulls are equal (they represent missing data), but different type nulls do not match (type matters).</p>
<p>In contrast to some languages, such as C, separate instances of NaN are equal.</p>
<pre class="highlight"><code class="language-q">q)(0%0)=0%0
_</code></pre>
<p>The <code>not</code> operator returns <code>0b</code> for all infinities and nulls since they all fail the test of equality with 0.</p>
<pre class="highlight"><code class="language-q">q)not 0W
_
q)not -0w
_
q)not 0N
_</code></pre>
<p>The <code>neg</code> operator reverses the sign of infinities but does nothing to nulls since sign is meaningless for missing data.</p>
<pre class="highlight"><code class="language-q">q)neg 0W
-_
q)neg -0w
_
q)neg 0N
_</code></pre>
<p>We saw previously that for any numeric type</p>
<p>null &lt; negative infinity &lt; normal value &lt; positive infinity</p>
<p>Nulls of different type, while equal, are not otherwise comparable ‚Äì i.e., any relational comparison results in <code>0b</code>.</p>
<p>Infinities of different type are ordered by their width. For positive infinities</p>
<p>short &lt; int &lt; long &lt; real &lt; float</p>
<p>For negative infinities</p>
<p>-float &lt; -real &lt; -long &lt; -int &lt; -short</p>
<p>Some examples follow. Try to predict the result before pressing Return.</p>
<pre class="highlight"><code class="language-q">q)42&lt;0W
_
q)-0w&lt;42.0
_
q)-0w&lt;1901.01.01
_
q)-0w&lt;0w
_
q)0W&lt;0w
_
q)-0w&lt;0W
_
q)-10000000&lt;0N
_
q)0N&lt;42i
_
q)0n&lt;-0w
_</code></pre>
<p>The null symbol is less than any other symbol</p>
<pre class="highlight"><code class="language-q">q)`a&lt;`
_</code></pre>
<p>The behavior of <code>|</code> and <code>&amp;</code> with infinities and nulls follows from the rules for equality, comparison and type promotion mentioned already.</p>
<pre class="highlight"><code class="language-q">q)42|0W
_
q)-42&amp;0N
_
q)0w|0n
_
q)-0w&amp;0n
_
q)0n|0N
_
q)0Wi&amp;0W
_</code></pre>
<p>The last result obtains because int infinity is promoted to a long and its bit pattern corresponds to the maximal positive 32-bit integer.</p>
<h2 id="411-alias">4.11 Alias <code>::</code></h2>
<p>Because q is strict, expressions are normally evaluated as soon as encountered by the interpreter. In particular, assignment with an expression on the right requires the expression to be evaluated before the result is assigned.</p>
<p>An <em>alias</em> is a variable that <strong>is</strong> an expression ‚Äì i.e., it is <strong>not</strong> the result of expression evaluation but the expression itself. Otherwise put, an alias provides a way to defer evaluation of an expression.</p>
<p>Evaluation of an alias is <em>lazy</em>, meaning that it occurs only when necessary. More precisely, evaluation is <em>forced</em> when the variable is referenced, at which point a determination is made whether the expression needs to be (re)evaluated.</p>
<ul>
<li>If it is the first reference or if any variable in its associated expression has changed since the last evaluation, evaluation proceeds with the current values of all the variables in the expression. The result of the most recent evaluation is then stored internally and also returned. The stored result is said to be <em>memoized</em>.</li>
<li>If no variables in the expression have changed since the previous evaluation, the memoized value is returned.</li>
</ul>
<p>The alias variable is said to <em>depend</em> on any variables in its expression.</p>
<h3 id="4111-creating-an-alias-with-double-colon">4.11.1 Creating an Alias with Double Colon</h3>
<p>Double colon <code>::</code> used outside a function body defines the variable in the left operand as an alias of the expression in the right operand. When the alias is referenced, the underlying expression is (re)evaluated as described above. The following trivial example defines <code>b</code> as an alias for <code>a</code>, contrasted with <code>c</code> which is just assigned the value of <code>a</code>. Observe that the subsequently changed value of <code>a</code> is reflected in <code>b</code> but not in <code>c</code>.</p>
<pre class="highlight"><code class="language-q">q)a:42
q)b::a
q)c:a
q)a:43
q)b
43
q)c
42</code></pre>
<p>Here is a more interesting alias.</p>
<pre class="highlight"><code class="language-q">q)w::(x*x)+y*y
q)x:3
q)y:4
q)w
25
q)y:5
q)w
34</code></pre>
<p>The mysteriously named utility <code>0N!</code> is the identity function fortified with the side effect of displaying its input on the console.</p>
<p>It is a non-invasive way to inspect the inner workings of an in-flight evaluation.</p>
<pre class="highlight"><code class="language-q">q)w::(0N!x*x)+y*y
q)x:3
q)y:4
q)w
9
25
q)w
25
q)y:6
q)w
9
45</code></pre>
<p>Observe that the first time <code>w</code> is referenced, the expression <strong>is</strong> evaluated, as indicated by the display of the value of <code>x*x</code>. On the next reference, the expression is <strong>not</strong> re-evaluated since none of the variables it depends on have changed. After changing <code>y</code>, the last reference causes re-evaluation.</p>
<h3 id="4112-alias-vs-function">4.11.2 Alias vs. Function</h3>
<p>A function also represents deferred evaluation. In the previous example, we could define,</p>
<pre class="highlight"><code class="language-q">q)fu:{(x*x)+y*y}
q)fu[3;4]
25</code></pre>
<p>There are two key differences between an alias and the analogous function.</p>
<ul>
<li>To evaluate an expression wrapped in a function you explicitly provide the arguments and apply the function all in one step. With an alias you set the variables at any point in the program and the expression is evaluated when, and only when, the alias variable is referenced.</li>
<li>The function does not memoize its result, so it recalculates on every application, even if the arguments do not change.</li>
</ul>
<h3 id="4113-dependencies">4.11.3 Dependencies</h3>
<p>An alias variable <em>depends</em> on the entities in its associated expression. In our previous example <code>w</code> depends on <code>x</code> and <code>y</code>. A list of all dependencies is maintained in the <a href="https://code.kx.com/q/ref/dotz/#zb-dependencies">system dictionary <code>.z.b</code></a>, which is also obtainable via the <a href="https://code.kx.com/q/basics/syscmds/#b-views">command <code>\b</code></a>.</p>
<pre class="highlight"><code class="language-q">q)w::(x*x)+y*y
q).z.b
x| w
y| w</code></pre>
<p>Each key in <code>.z.b</code> is associated to all the entities that depend on it.</p>
<p>It is permissible to create an alias with another alias in its expression. This results in a chain of dependencies. The entire chain is resolved lazily upon reference.</p>
<pre class="highlight"><code class="language-q">q)u::w*w
q).z.b
x| w
y| w
w| u
q)x:3
q)y:4
q)u
_</code></pre>
<p>Such a recursive definition leads to a hierarchy of dependencies, in which a variable depends not only on the variables in its own expression, but also any variables that its expression depends on, etc. You can easily build sophisticated dependency graphs this way.</p>
<div class="admonition warning">
<p class="admonition-title">You can easily build unmaintainable code this way.</p>
</div>
<p>A dependency chain that would create a loop is detected and results in an error. Continuing the example above,</p>
<pre class="highlight"><code class="language-q">q)x::u
q)x
'loop</code></pre>
<h3 id="4114-views">4.11.4 Views</h3>
<p>Aliasing is commonly used to provide a database view by specifying a query as the expression.</p>
<pre class="highlight"><code class="language-q">q)t:([]c1:`a`b`c`a;c2:20 15 10 20;c3:99.5 99.45 99.42 99.4)
q)v::select sym:c1,px:c3 from t where c1=`a
q)v
sym px
--------
a 99.5
a 99.4
q)update c3:42.0 from `t where c1=`a
_
q)v
_</code></pre>
<p>The table dependencies of a view are reflected in <code>.z.b</code>.</p>
<pre class="highlight"><code class="language-q">q).z.b
_</code></pre>
                


                
              
              
                


              
            </article>
            
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))for(var set of document.querySelectorAll("[data-tabs]")){var labels=set.querySelectorAll(":scope > label");e:for(var tab of tabs)for(var label of labels)if(label.innerText.trim()===tab){var input=label.previousElementSibling;input.checked=!0;break e}}</script>

          </div>
        </div>
        
          
        
      
                </div>
            </section>
        
            <section class="chapter" id="chapter-10">
                <div class="chapter-header">
                    <h1 class="chapter-title">5. Dictionaries¬∂</h1>
                    <div class="chapter-meta">
                        <span>üìñ Source: <a href="https://code.kx.com/q4m3/5_Dictionaries/">https://code.kx.com/q4m3/5_Dictionaries/</a></span>
                        <span>üìù 3237 words</span>
                        
                    </div>
                </div>
                <div class="chapter-content">
                    
        <div class="md-main__inner md-grid">
          
            
              
              
            
            
              
              
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                
                <h1 id="5-dictionaries">5. Dictionaries</h1>
<h2 id="50-overview">5.0 Overview</h2>
<p>A dictionary is a mapping defined by an explicit association between a key list and value list. The two lists must have the same count and the key list should be a unique collection. While general lists can be used to create a dictionary, many dictionaries involve simple lists of keys.</p>
<h2 id="51-dictionary-basics">5.1 Dictionary Basics</h2>
<p>A dictionary is an association between a list of keys and a list of values. Logically it can also be considered as key-value pairs but it is stored physically as a pair of lists.</p>
<h3 id="511-definition">5.1.1 Definition</h3>
<p>A <em>dictionary</em>, sometimes called an <em>association</em>, is a mapping defined by positional correspondence between a domain <strong>list</strong> of <em>keys</em> and a co-domain <strong>list</strong> of <em>values</em>. Dictionary creation uses the <a href="https://code.kx.com/q/ref/dict/"><code>!</code> operator</a> ‚Äì read "bang" ‚Äì in contrast with the syntactic form for lists.</p>
<p><em>keys</em>!<em>values</em></p>
<p>All dictionaries have type <code>99h</code>.</p>
<p>Observe that the q console displays a dictionary as an I/O table.</p>
<pre class="highlight"><code class="language-q">q)10 20 30!1.1 2.2 3.3
10| 1.1
20| 2.2
30| 3.3
q)`a`b`c!100 200 300
_</code></pre>
<p>Neither the keys nor values need be simple lists but the keys should conform else odd things will happen during operations.</p>
<pre class="highlight"><code class="language-q">q)(`Arthur`Dent; `Zaphod`Beeblebrox; `Ford`Prefect)! 100 42 150
Arthur Dent      | 100
Zaphod Beeblebrox| 42
Ford Prefect     | 150
q)1001 1002 1003!(`Arthur`Dent; `Zaphod`Beeblebrox; `Ford`Prefect)
_</code></pre>
<p>A dictionary can be decomposed into its key and value lists using the primitives <a href="https://code.kx.com/q/ref/key/"><code>key</code></a> and <a href="https://code.kx.com/q/ref/value/"><code>value</code></a>. The common number of keys or values is returned by <code>count</code>.</p>
<pre class="highlight"><code class="language-q">q)d:`a`b`c!100 200 300
q)key d
_
q)value d
_
q)count d
_</code></pre>
<p>Although q does not enforce uniqueness for keys (a historical accident) a dictionary does provide a unique output value for each input value. Indeed, only the first key occurrence is seen during lookup.</p>
<div class="admonition tip">
<p class="admonition-title">When you know that the keys are unique you can apply the <code>`u#</code> attribute to the keys.</p>
<p>This will effectively cause the dictionary to be a hash table with the attendant improvement in lookup speed over the default linear lookup.
</p><pre><code class="language-q">
q)(`u#`a`b`c)!10 20 30
_
</code></pre>
</div>
<p>The order of the items in the key and value lists is significant, just as positional order is significant for lists. Although the I/O assignments and the associated mappings are equivalent regardless of order, differently ordered dictionaries are <strong>not</strong> identical.</p>
<pre class="highlight"><code class="language-q">q)(`a`b`c!10 20 30)~`a`c`b!10 30 20
0b</code></pre>
<h3 id="512-empty-and-singleton-dictionaries">5.1.2 Empty and Singleton Dictionaries</h3>
<p>You can create a general empty dictionary using empty key and value lists.</p>
<pre class="highlight"><code class="language-q">q)()!()
_</code></pre>
<p>You can create a typed empty dictionary using typed empty key and value lists.</p>
<pre class="highlight"><code class="language-q">q)(`symbol$())!`float$()
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Because both the keys and values are required to be lists, you must enlist atoms for a singleton dictionary.</p>
<pre><code class="language-q">
q)(enlist `x)!enlist 42
x| 42
</code></pre>
</div>
<p>The following is <strong>not</strong> a singleton dictionary. This is a common mistake of qbies.</p>
<pre class="highlight"><code class="language-q">q)`x!42
`x!42i</code></pre>
<p>For those who care, it is actually an enumerated value for a link column.</p>
<h3 id="513-lookup">5.1.3 Lookup</h3>
<p>To find the output value corresponding to an input key, we <em>look up</em> the key. Lookup uses the same notation as indexing into a list: brackets or prefix syntax.</p>
<pre class="highlight"><code class="language-q">q)d:`a`b`c!10 20 30
q)d[`a]
10
q)d `b
_</code></pre>
<p>Similar to list indexing, lookup of a value not in the key list of a dictionary results in a null whose type is that of the initial item in the value list.</p>
<pre class="highlight"><code class="language-q">q)d[`x]
_</code></pre>
<p>As with lists, key lookup in a dictionary is extended item-wise to a simple list of keys.</p>
<pre class="highlight"><code class="language-q">q)d[`a`c]
_
q)ks:`a`c
q)d ks
_</code></pre>
<h3 id="514-reverse-lookup-with-find">5.1.4 Reverse Lookup with Find <code>?</code></h3>
<p>Recall that the <a href="https://code.kx.com/q/ref/find/">Find</a>  operator <code>?</code> on a list returns the index of the first occurrence of the right operand.</p>
<pre class="highlight"><code class="language-q">q)10 20 30 10 40?10
0</code></pre>
<p>Essentially it inverts the positional retrieval mapping. Extending this concept to dictionaries means reversing the key-to-value mapping of lookup. That is, <code>?</code> on a dictionary performs reverse lookup by mapping a value item to the first key associated to it.</p>
<pre class="highlight"><code class="language-q">q)d:`a`b`c`a!10 20 30 10
q)d?10
`a</code></pre>
<p>The result of Find on an argument not in the value list is a null whose type matches the initial item in the key list.</p>
<pre class="highlight"><code class="language-q">q)d:`a`b`c`a!10 20 30 10
q)d?40
`</code></pre>
<h3 id="515-dictionary-vs-list">5.1.5 Dictionary vs. List</h3>
<p>It is possible to create a dictionary that seemingly behaves very much like an equivalent list by making the positional retrieval explicit.</p>
<pre class="highlight"><code class="language-q">q)L:10 20 30
q)d:0 1 2!10 20 30
q)L 0
10
q)d 0
10
q)L 1 2
20 30
q)d 1 2
20 30
d~L
_</code></pre>
<p>The two are not the same. A major difference is that dictionaries can be extended via assignment and a list cannot.</p>
<details class="tip">
<summary>Sparse lists</summary>
<p>This dictionary version of lists provides a compact and efficient representation of sparse lists.
</p><pre><code class="language-q">
q)d1:0 100 500000!10 20 30
q)d2:0 99 1000000!100 200 300
q)d1+d2
0      | 110
100    | 20
500000 | 30
99     | 200
1000000| 300
</code></pre>
The implementation is left as an exercise for the reader.
</details>
<h3 id="516-non-unique-keys-and-values">5.1.6 Non-unique Keys and Values</h3>
<p>As mentioned previously, non-unique keys are tolerated but lookup only sees the first occurrence.</p>
<pre class="highlight"><code class="language-q">q)ddup:`a`b`a`c!10 20 30 20
q)ddup[`a]
10</code></pre>
<p>Reverse lookup works properly for non-unique keys but will only see the first non-unique value.</p>
<pre class="highlight"><code class="language-q">q)ddup?30
`a
q)ddup?20
`b</code></pre>
<p>You can find all keys mapping to a given value as follows.</p>
<pre class="highlight"><code class="language-q">q)where ddup=20
`b`c</code></pre>
<h3 id="517-non-simple-keys-and-values">5.1.7 Non-simple Keys and Values</h3>
<p>Neither the key nor value lists of a dictionary are required to be atoms or uniform. Either can be nested lists.</p>
<pre class="highlight"><code class="language-q">q)d:(`a`b; `c`d`e; enlist `f)!10 20 30
q)d `f
30
q)d?20
`c`d`e
q)d:`a`b`c!(10 20; 30 40 50; enlist 60)
q)d `b
30 40 50
q)d?30 40 50
`b
q)d?enlist 60
_</code></pre>
<p>Be forewarned that an irregular key or value list ‚Äì i.e., items do not conform ‚Äì will confound lookup or reverse lookup, respectively.</p>
<pre class="highlight"><code class="language-q">q)dwhackey:(1 2; 3 4 5; 6; 7 8)!10 20 30 40 / atom 6 is whack
q)dwhackey 1 2
10
q)dwhackey 6
0N
q)dwhackval:10 20 30 40!(1 2; 3 4 5; 6; 7 8) / atom 6 is whack
q)dwhackval?3 4 5
20
q)dwhackval?6
_</code></pre>
<p>The observed behavior is that lookup in either direction fails at the first item of different shape.</p>
<h2 id="52-operations-on-dictionaries">5.2 Operations on Dictionaries</h2>
<h3 id="521-amend-and-upsert">5.2.1 Amend and Upsert</h3>
<p>As with lists, the items of a dictionary can be modified via assignment to a key.</p>
<pre class="highlight"><code class="language-q">q)d:`a`b`c!10 20 30
q)d[`b]:42
q)d
_</code></pre>
<p>In contrast to lists, dictionaries <strong>can</strong> be extended via assignment.</p>
<pre class="highlight"><code class="language-q">q)d:`a`b`c!10 20 30
q)d[`x]:42
q)d
_</code></pre>
<p>Let‚Äôs examine more closely this capability to modify or extend a dictionary via key-value assignment. Given a dictionary <code>d</code>, a value <code>k</code> that matches the type of the keys of <code>d</code> and a value <code>v</code> that matches the type of the values of <code>d</code>, consider the assignment</p>
<pre class="highlight"><code class="language-q">d[k]:v</code></pre>
<p>It updates the existing key-value association when <code>k</code> is in key <code>d</code>, or inserts (appends) a new key-value association when <code>k</code> is not in key <code>d</code>.</p>
<pre class="highlight"><code class="language-q">q)d:`a`b`c!10 20 30
q)d[`b]:42 / update
q)d[`x]:100 / insert
q)d
_</code></pre>
<p>This update/insert behavior is called <em>upsert</em> semantics. Because tables and keyed tables are dictionaries, upsert semantics pervade kdb+.</p>
<h3 id="522-extracting-a-sub-dictionary">5.2.2 Extracting a Sub-Dictionary</h3>
<p>Dictionary lookup on a key or a list of keys returns the associated values. It is possible to extract both keys and values using an overload of the Take operator <code>#</code>. The left operand is a <strong>list</strong> of keys, the right operand is the <em>source</em> dictionary and the result is a sub-dictionary for the specified keys. Viewed as a mapping, the result is the original restricted to the specified keys.</p>
<pre class="highlight"><code class="language-q">q)d:`a`b`c!10 20 30
q)d `a`c
_
q)`a`c#d
a| 10
c| 30
q)(enlist `c)#d
_</code></pre>
<p>In the event of duplicate keys, only the first is extracted.</p>
<pre class="highlight"><code class="language-q">q)ddup:`a`b`a`c!10 20 30 20
q)`a`c#ddup
a| 10
c| 20</code></pre>
<p>This operation works with non-simple keys.</p>
<pre class="highlight"><code class="language-q">q)dns:(`arthur`dent; `ford`prefect; `zaphod`beebelbrox)!100 150 42
q)(`arthur`dent; `zaphod`beebelbrox)#dns
arthur dent      | 100
zaphod beebelbrox| 42</code></pre>
<h3 id="523-removing-entries">5.2.3 Removing Entries</h3>
<p>The adjoint operation to <code>#</code> is <a href="https://code.kx.com/q/ref/drop/" title="Drop"><code>_</code></a>, which removes key-value pairs. Its syntax is the same ‚Äì i.e., a list of keys as the left operand and a dictionary on the right ‚Äì and it returns the dictionary obtained by removing the key-value pairs for the specified keys.</p>
<div class="admonition tip">
<p class="admonition-title">Whitespace is required to the left of <code>_</code> if the left operand is a variable since <code>_</code> is a valid terminal name character.</p>
<pre><code class="language-q">
q)d:`a`b`c!10 20 30
q)`a`c _ d
b| 20
q)(enlist `b) _ d
_
</code></pre>
</div>
<p>Observe that all occurrences of a key are removed and that attempting to remove a key that does not exist has no effect.</p>
<pre class="highlight"><code class="language-q">q)d:`a`b`c`a!10 20 30 40
q
q)`a`c _ d
_
q)`x`a _ d
_</code></pre>
<p>Removing all the entries in a dictionary leaves a dictionary with empty key and value lists of the appropriate types. The console will not display the empty dictionary but you can force the display with <code>.Q.s1</code>. In this case we get typed empty lists.</p>
<pre class="highlight"><code class="language-q">q)d:`a`b`c!10 20 30
q)`a`b`c _ d
q).Q.s1 `a`b`c _ d
"(`symbol$())!`long$()"</code></pre>
<p>The binary keyword <a href="https://code.kx.com/q/ref/cut/"><code>cut</code></a> is the same as this overload of <code>_</code> on a dictionary.</p>
<pre class="highlight"><code class="language-q">q)`a`c cut d
_</code></pre>
<p>There is another overload of <code>_</code> with a dictionary on the left and a <strong>single</strong> key on the right that deletes just that key, which is seldom used.</p>
<pre class="highlight"><code class="language-q">q)d _ `b
a| 10
c| 30</code></pre>
<h3 id="524-basic-operations-on-dictionaries">5.2.4 Basic Operations on Dictionaries</h3>
<p>Because a dictionary is a map, it can be composed with another map to obtain a dictionary whose key-value association is the composite of the original and the new map. Another way to say this is that applying a function to a dictionary effectively applies it to the value list. Unary functions are straightforward.</p>
<p><code>d:`a`b`c!10 20 30</code> composed with <code>neg</code>:</p>
<pre class="highlight"><code class="language-txt">`a      |-&gt;  10    |-&gt;     -10
`b      |-&gt;  20    |-&gt;     -20
`c      |-&gt;  30    |-&gt;     -30</code></pre>
<pre class="highlight"><code class="language-q">q)d:`a`b`c!10 20 30
q)neg d
a| -10
b| -20
c| -30</code></pre>
<p>And similarly for other unary maps.</p>
<pre class="highlight"><code class="language-q">q)2*d
_
q)d=20
_
q)f:{x*x}
q)f d
_</code></pre>
<p>When the domains of two dictionary maps are identical, performing a binary operation is also straightforward: do it value-with-value along the keys. For example, to add two dictionaries with a common list of keys, add their corresponding values.</p>
<pre class="highlight"><code class="language-q">q)d1:`a`b`c!1 2 3
q)d2:`a`b`c!10 20 30
q)d1+d2
_</code></pre>
<p>What should happen when the domains lists are not identical? First, the domain of the resulting dictionary is the union of the domains ‚Äì i.e., the union of the key lists. For items in the common domain ‚Äì i.e., the intersection of the keys lists, we already know we should apply the operation value-with-value.</p>
<p>So the question becomes: what to do on non-common key items? The answer: Nothing! Since there really isn‚Äôt anything to do where there is no matching key on the other side, simply carry the value to the result. In essence, this implies using the identity element for the operation in place of the missing value.</p>
<pre class="highlight"><code class="language-q">q)d1:`a`b`c!1 2 3
q)d2:`b`c`d!20 30 40
q)d1+d2
a| 1
b| 22
c| 33
d| 40</code></pre>
<h3 id="525-join">5.2.5 Join <code>,</code></h3>
<p>The <a href="https://code.kx.com/q/ref/join/">Join</a> operator <code>,</code> merges two dictionaries. Clearly on disjoint keys the corresponding values should be carried over.</p>
<pre class="highlight"><code class="language-q">q)d1:`a`b`c!10 20 30
q)d2:`x`y!40 50
q)d1,d2
a| 10
b| 20
c| 30
x| 40
y| 50</code></pre>
<p>On common keys, since q is right-to-left, the value of the right operand prevails over that of the left.</p>
<pre class="highlight"><code class="language-q">q)d1:`a`b`c!10 20 30
q)d2:`a`b`c!100 200 300
q)d1,d2
a| 100
b| 200
c| 300</code></pre>
<p>Lo and behold, the entire right operand has been upserted into the left operand.</p>
<pre class="highlight"><code class="language-q">q)d1:`a`b`c!10 20 30
q)d2:`c`d!300 400
q)d1,d2
a| 10
b| 20
c| 300
d| 400</code></pre>
<p>This is equivalent to each key-value association being upserted into the left</p>
<pre class="highlight"><code class="language-q">q)d1:`a`b`c!10 20 30
q)d1[`c]:300
q)d1[`d]:400
q)d1
_</code></pre>
<p>Observe that Join is not commutative: order matters.</p>
<pre class="highlight"><code class="language-q">q)d1:`a`b`c!10 20 30
q)d2:`c`d!300 400
q)d1,d2
_
q)d2,d1
_</code></pre>
<h3 id="526-coalesce">5.2.6 Coalesce <code>^</code></h3>
<p>The <a href="https://code.kx.com/q/ref/coalesce/">Coalesce</a> operator is related to <code>,</code> in that it employs upsert semantics to merge two dictionaries. The difference is that right values prevail over left except for nulls in the right.</p>
<pre class="highlight"><code class="language-q">q)d1:`a`b`c!10 0N 30
q)d2:`b`c`d!200 0N 400
q)d1^d2
a| 10
b| 200
c| 30
d| 400</code></pre>
<h3 id="527-arithmetic-and-relational-operations">5.2.7 Arithmetic And Relational Operations</h3>
<p>Following the general pattern, when an arithmetic operation is performed on dictionaries, the operation is performed on the common domain elements and the identity element implied elsewhere. Of course the value lists must have proper types for the operation.</p>
<pre class="highlight"><code class="language-q">q)d1:`a`b`c!10 20 30
q)d2:`b`c`d!200 300 400
q)d1+d2
a| 10
b| 220
c| 330
d| 400</code></pre>
<p>For equality and comparison operations on dictionaries, the indicated operation is performed over the common keys. On disjoint keys, the appropriate null is effectively substituted for missing values. Due to all nulls being equal, a null value on a disjoint key will report <code>1b</code> under equality test.</p>
<pre class="highlight"><code class="language-q">q)(`a`b`c!10 20 30)=`b`c`d!20 300 400
a| 0
b| 1
c| 0
d| 0
q)(`a`b`c!0N 20 30)=`b`c`d!20 300 0N
a| 1
b| 1
c| 0
d| 1
q)(`a`b`c!10 20 30)&lt;`b`c`d!20 300 400
a| 0
b| 0
c| 1
d| 1</code></pre>
<h2 id="53-column-dictionaries">5.3 Column Dictionaries</h2>
<p>Column dictionaries are the foundation for tables.</p>
<h3 id="531-definition-and-terminology">5.3.1 Definition and Terminology</h3>
<p>A very useful type of dictionary maps a simple list of symbols to a rectangular list of lists.</p>
<pre class="highlight"><code class="language-q">q)`c1`c2!(`a`b`c; 10 20 30)
c1| a b c
c2| 10 20 30</code></pre>
<p>Interpreting each symbol as a name and the corresponding list as a vector of column values, we call such a list a <em>column dictionary</em>. A general column dictionary has the form,</p>
<p><em>c<sub>1</sub></em>...<em>c<sub>n</sub></em>!(<em>v<sub>1</sub></em>;...;<em>v<sub>n</sub></em>)</p>
<p>where each <em>c<sub>i</sub></em> is a symbol and the <em>v<sub>i</sub></em> are lists with common length (count). Such a dictionary associates the name <em>c<sub>i</sub></em> with the value list <em>v<sub>i</sub></em>.</p>
<p>The <em>type</em> of the column named by <em>c<sub>i</sub></em> is the type of its associated value list <em>v<sub>i</sub></em>. Often the <em>v<sub>i</sub></em> are all simple lists ‚Äì i.e., each column is a vector of atoms of uniform type.</p>
<h3 id="532-simple-example">5.3.2 Simple Example</h3>
<p>Let‚Äôs make a column dictionary that holds the names of famous galactic travelers and their IQ scores.</p>
<pre class="highlight"><code class="language-q">q)travelers:`name`iq!(`Dent`Beeblebrox`Prefect;42 98 126)
q)travelers
name| Dent Beeblebrox Prefect
iq  | 42   98         126</code></pre>
<p>In this dictionary, the values for the <em>name</em> column are,</p>
<pre class="highlight"><code class="language-q">q)travelers[`name]
`Dent`Beeblebrox`Prefect</code></pre>
<p>Since this column is a list, we can index into it.</p>
<pre class="highlight"><code class="language-q">q)travelers[`name][1]
`Beeblebrox
q)travelers[`iq][2]
126</code></pre>
<p>In general, whenever we encounter repeated indexing in q we can alternately write it as indexing at depth.</p>
<pre class="highlight"><code class="language-q">q)travelers[`name; 1]
`Beeblebrox
q)travelers[`iq; 2]
126</code></pre>
<p>Thus travelers can be considered a two-dimensional entity indexed by name in the first slot.</p>
<h3 id="533-general-case">5.3.3 General Case</h3>
<p>For a general column dictionary defined as,</p>
<p><em>dc:c<sub>1</sub>...c<sub>n</sub>!(v<sub>1</sub>;...;v<sub>n</sub>)</em></p>
<p>the <em>i<sup>th</sup></em> element of column <em>c<sub>j</sub></em> is retrieved by,</p>
<p><em>dc</em>[<em>c<sub>j</sub></em>][i]</p>
<p>Or equivalently,</p>
<p><em>dc</em>[<em>c<sub>j</sub></em>;i]</p>
<p>The indexing-at-depth notation suggests thinking of the column dictionary as a two-dimensional data structure, indexed by column name and column position. Alternatively, it is a positional map of two variables with symbolic name in the first parameter and column index in the second.</p>
<p>Specifying just an index in the second column is interesting. It essentially retrieves a 'slice' of the original dictionary across that index. This slice is itself a dictionary. In our simple example of the previous section,</p>
<pre class="highlight"><code class="language-q">q)travelers[; 2]
name| `Prefect
iq  | 126</code></pre>
<p>Let‚Äôs summarize.</p>
<ul>
<li>A column dictionary can be viewed as a two-dimensional entity with retrieval by name in the first dimension and by position within column in the second.</li>
<li>Specifying only a name retrieves the corresponding column, which can then be indexed by position.</li>
<li>Specifying only a column index retrieves a slice dictionary that maps the names to the associated values across that column index.</li>
</ul>
<p>This data structure has potential but there is a hitch: the indexing is backwards. That is, columns are retrieved in the first slot. Normally in two-dimensional data structures, columns are retrieved in the second slot. We shall see shortly how to fix this.</p>
<h3 id="534-column-dictionary-with-a-single-column">5.3.4 Column Dictionary with a Single Column</h3>
<p>Recall that every dictionary is constructed from a <strong>list</strong> of keys and a <strong>list</strong> of values. A column dictionary is further required to have a rectangular list of values ‚Äì i.e., a list of lists of the same length.</p>
<p>Thus in order to make a column dictionary with a single column, we need to enlist the single key and enlist the single column list.</p>
<pre class="highlight"><code class="language-q">q)dc1:(enlist `c)!enlist 10 20 30
q)dc1
c| 10 20 30</code></pre>
<div class="admonition warning">
<p class="admonition-title">As noted previously, the following isn‚Äôt even a valid dictionary, let alone a column dictionary.</p>
<pre><code class="language-q">
q)`c!1 2 3
_
</code></pre>
</div>
<h2 id="54-flipping-a-column-dictionary">5.4 Flipping a Column Dictionary</h2>
<p>No, this isn‚Äôt what you do to a dictionary that cuts you off in traffic. Recall that a rectangular nested list can be transposed with the <a href="https://code.kx.com/q/ref/flip/"><code>flip</code></a> operator.</p>
<pre class="highlight"><code class="language-q">q)L:(10 20 30; 100 200 300)
q)L
10 20 30
100 200 300
q)flip L
10 100
20 200
30 300</code></pre>
<p>A side effect of transposing the nested list data is that it reverses the slots for indexing at depth.</p>
<pre class="highlight"><code class="language-q">q)L:(10 20 30; 100 200 300)
q)M:flip L
q)L[0;0]
10
q)L[0;1]
20
q)L[0;2]
30
q)M[0;0]
10
q)M[1;0]
20
q)M[2;0]
30</code></pre>
<p>Recall that applying <code>flip</code> to a nested list creates a copy of the original list in which the data has been reorganized. When a column dictionary is considered as a two-dimensional entity it is rectangular, since its column lists all have the same count. The console display shows this.</p>
<pre class="highlight"><code class="language-q">q)`c1`c2!(`a`b`c; 10 20 30)
c1| a b c
c2| 10 20 30</code></pre>
<p>Thus it makes sense to transpose this rectangular data structure. Observe that the console display is exactly transposed.</p>
<pre class="highlight"><code class="language-q">q)dc:`c1`c2!(`a`b`c; 10 20 30)
q)dc
c1| a b c
c2| 10 20 30
q)t:flip dc
q)t
c1 c2
-----
a 10
b 20
c 30</code></pre>
<p>We expect the transposed entity to have the slots reversed for indexing at depth.</p>
<pre class="highlight"><code class="language-q">q)dc[`c1; 0]
`a
q)dc[`c1; 1]
`b
q)dc[`c1; 2]
`c
q)t[0; `c1]
`a
q)t[1; `c1]
`b
q)t[2; `c1]
`c</code></pre>
<p><em>Voil√†!</em> We have fixed the indexing issue with our column dictionaries. Columns are now indexed in the second parameter. Let‚Äôs translate the other aspects of the column dictionary retrieval into the transposed setting.</p>
<pre class="highlight"><code class="language-q">q)dc[`c1;]
`a`b`c
q)t[;`c1]
`a`b`c
q)dc[; 0]
c1| `a
c2| 10
q)t[0;]
c1| `a
c2| 10
q)dc[`c2; 1]
20
q)t[1; `c2]
20</code></pre>
<p>For the moment, forget the origin of <code>t</code> as a transposed column dictionary and examine it in isolation.</p>
<pre class="highlight"><code class="language-q">q)t[;`c1]
`a`b`c
q)t[0;]
c1| `a
c2| 10
q)t[1; `c2]
20</code></pre>
<p>Let‚Äôs look more closely at the section dictionaries that are now indexed in the first slot. Recall that we are permitted (although not encouraged) to omit trailing semi-colons for elided indices.</p>
<pre class="highlight"><code class="language-q">q)t[0]
c1| `a
c2| 10
q)t[1]
c1| `b
c2| 20
q)t[2]
c1| `c
c2| 30</code></pre>
<p>If you were to meet such a beast out of context, you would say that it is a list of these funky section dictionaries.</p>
<p>We summarize our findings about the transpose of a column dictionary,</p>
<ul>
<li>It is a two-dimensional data structure that uses an integer index in the first slot and a column name symbol in the second slot.</li>
<li>Specifying only an integer in the first slot retrieves a section dictionary across that index</li>
<li>Specifying only a column name in the second slot retrieves that column.</li>
<li>Specifying both an integer and a column name retrieves the "field" at that index in that column.</li>
<li>It can be viewed as a list of section dictionaries.</li>
</ul>
<p>We make two more observations about transposed column dictionaries. In general, if you transpose something twice, you get back the original.</p>
<pre class="highlight"><code class="language-q">q)dc~flip flip dc
1b
q)dc~flip t
1b</code></pre>
<p>We restate this as:</p>
<ul>
<li>The flip of a transposed column dictionary is a (the original!) column dictionary</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Unlike the case of transposing rectangular lists, transposing a column dictionary does not physically re-arrange data.</p>
</div>
<p>A transposed column dictionary is stored in column order.</p>
<p>Instead, the result is a logical adjustment ‚Äì meaning that the slots in indexing at depth are reversed.</p>
                


                
              
              
                


              
            </article>
            
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))for(var set of document.querySelectorAll("[data-tabs]")){var labels=set.querySelectorAll(":scope > label");e:for(var tab of tabs)for(var label of labels)if(label.innerText.trim()===tab){var input=label.previousElementSibling;input.checked=!0;break e}}</script>

          </div>
        </div>
        
          
        
      
                </div>
            </section>
        
            <section class="chapter" id="chapter-11">
                <div class="chapter-header">
                    <h1 class="chapter-title">6. Functions¬∂</h1>
                    <div class="chapter-meta">
                        <span>üìñ Source: <a href="https://code.kx.com/q4m3/6_Functions/">https://code.kx.com/q4m3/6_Functions/</a></span>
                        <span>üìù 10311 words</span>
                        
                    </div>
                </div>
                <div class="chapter-content">
                    
        <div class="md-main__inner md-grid">
          
            
              
              
            
            
              
              
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                
                <h1 id="6-functions">6. Functions</h1>
<h2 id="60-overview">6.0 Overview</h2>
<p>In this chapter, we cover functions in depth. Before diving in, you may wish to review the <a href="https://code.kx.com/q4m3/0_Overview/#02-mathematics-refresher">Mathematics Refresher</a> in Chapter 0 for the approach and terminology we adopt.</p>
<p>We describe various built-in functions along the way in this tutorial. Sometimes we shall use a built-in function with minimal explanation; simply look it up in <a href="https://code.kx.com/q4m3/A_Built-in_Functions/">Appendix A</a>, which contains specifics and examples of nearly all the q built-in functions.</p>
<h2 id="61-function-specification">6.1 Function Specification</h2>
<p>The notion of a function in q corresponds to a (mathematical) map that is specified by an algorithm. A <em>function</em> is a sequence of expressions to be evaluated, having optional input parameters and a return value. <em>Application</em> of a function is the process of evaluating the expressions in sequence, substituting actual arguments for any formal parameters. The result of the evaluation, should there be one, is the function's output value.</p>
<p>Because a q function can modify global variables, q is not a pure functional language. A mathematical function can never reach outside its own body and have side effects. You should minimize such behavior for code maintainability.</p>
<h3 id="611-function-definition">6.1.1 Function Definition</h3>
<p>The syntax of function definition is a matching pair of braces <code>{</code> and <code>}</code> enclosing (optional) parameters followed by a sequence of expressions. In contrast to statically typed languages, the input parameters and the return value are not explicitly typed; in fact, they don't even need to be declared. Even the function name is optional.</p>
<p>Following is a full specification of a function that squares its input. In this case, the function simply returns the value of the (last) expression evaluated. We add optional whitespace after the parameter declaration for readability.</p>
<pre class="highlight"><code class="language-q">q){[x] x*x}</code></pre>
<p>Apply this function by following it with an argument enclosed in square brackets. This causes the supplied argument to be substituted for all occurrences of the parameter <code>x</code>, the expression to be evaluated and the result returned as the output value.</p>
<pre class="highlight"><code class="language-q">q){[x] x*x}[3]
9</code></pre>
<p>A function is a first-class value ‚Äì i.e., it is data just like a long or float. In particular, a function can be assigned to a variable, whereupon it acquires a name. This variable can be used in place of the function.</p>
<pre class="highlight"><code class="language-q">q)f:{[x] x*x}
q)f[3]
_</code></pre>
<h3 id="612-function-notation-and-terminology">6.1.2 Function Notation and Terminology</h3>
<p>The formal notation for function definition is,</p>
<p>{[p<sub>1</sub>;...;p<sub>n</sub>] e<sub>1</sub>; ...; e<sub>m</sub>}</p>
<p>The optional p<sub>1</sub>, ... , p<sub>n</sub> are formal parameters. The expressions <em>e<sub>1</sub></em>, ... , <em>e<sub>m</sub></em> ‚Äì which presumably involve the parameters ‚Äì represent the steps of an algorithm that are evaluated in order. Note that while the expressions are sequenced left-to-right, an individual expression is always evaluated right-to-left.</p>
<p>For readability, in this text we shall normally insert optional whitespace after the square bracket that closes the parameter list, as well as after each semi-colon separator. Other styles may differ.</p>
<div class="admonition tip">
<p class="admonition-title">Semi-colons</p>
<p>The semi-colons in the body are separators, not terminators. Do not place a semi-colon after the last expression unless you deliberately want to suppress the return value.</p>
<p>In fact, <code>;</code> is an operator that evaluates its left operand and discards the result, then evaluates the right operand and returns that value. If you meditate on this, you will realize that this is precisely the behavior of the semi-colon separators in a function body.</p>
<pre><code class="language-q">
q)a:2*3;6*7
42
q)a
6
</code></pre>
</div>
<p>The number of formal input parameters (implicit or explicit) is the function <em>valence</em>. Most common are <em>unary</em> (valence 1) and <em>binary</em> (valence 2).</p>
<p>A <em>nullary</em> function in q is a function that has no meaningful input. This is similar to a function taking <code>void</code> in C. In functional programming this is represented as a function defined on a type called "unit" having a single value, often written <code>()</code>. In q it is written with an empty parameter declaration,</p>
<pre class="highlight"><code class="language-q">f:{[] ‚Ä¶ }</code></pre>
<p>and is applied with empty argument ‚Äì i.e., <code>f[]</code>. In this case, the function either returns a constant or has <em>side effects</em>, meaning that it accesses resources outside its body.</p>
<pre class="highlight"><code class="language-q">q){[] 42} / pure function returns constant 42
_
q){[] a*a} / impure function: references global a
_</code></pre>
<p>The maximum valence permitted as of this writing (Sep 2015) is 8; specifying more than eight parameters will cause an error. You can circumvent this restriction by encapsulating multiple parameters in a list or dictionary.</p>
<p>The output value of a function written in functional programming style is the value of the last expression in its body. This is the recommended style of writing q since it results in linear flow that is easy to follow and debug.</p>
<pre class="highlight"><code class="language-q">q){[x] x*x}
q){[x;y] a:x*x; b:y*y; r:a+b; r}</code></pre>
<p>This convention can be supplanted by using a unary overload of <code>:</code> that immediately terminates function evaluation and returns the value of the expression to its right. This style is discouraged.</p>
<pre class="highlight"><code class="language-q">q){[x] :x*x} / unnecessary use of :
q){[x] a:1; :x*x; b:3} / dead code</code></pre>
<div class="admonition tip">
<p class="admonition-title">Keep it short</p>
<p>Q functions should be compact and modular: each function should perform a well-defined unit of work. Due to the power of q operators and built-in functions, many functions are one line. </p>
<p>When a function exceeds 20 statements, you should look to refactor it.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Ambivalence</p>
<p>When Arthur Whitney, the creator of q, says that q is not ambivalent, he doesn‚Äôt mean that q is decisive. Rather, in contrast to k, q operators and built-in functions are <em>not</em> overloaded on valence, meaning that the same function does not have different behavior in a unary and binary form. That said, q operators and built-in functions <em>are</em> overloaded on just about anything else, including the type, sign or rank of arguments ‚Äì sometimes multiply so.</p>
</div>
<h3 id="613-function-application">6.1.3 Function Application</h3>
<p>The notation for function application parallels that of the formal parameters in its definition. The function is followed by square brackets enclosing arguments separated by semi-colons. Application causes the expressions in the function body to be evaluated in sequence, substituting the value of each argument for the corresponding formal parameter.</p>
<pre class="highlight"><code class="language-q">q){[x] x*x}[3]
9
q)f:{[x] x*x}
q)f[4]
_
q){[x;y] x+y}[3;4]
7
q)g:{[x;y] x+y}
q)g[3;4]
_</code></pre>
<p>Function application in q is <em>strict</em>, meaning that expressions in arguments are evaluated <strong>before</strong> substitution is performed.</p>
<pre class="highlight"><code class="language-q">q)f:{[x] x*x}
q)f[0N!3+1]
4
16</code></pre>
<p>The valence of a function is also called its <em>rank</em>. An application with too many arguments generates a <code>'rank</code> error. This doesn‚Äôt mean your code stinks, although it might.</p>
<pre class="highlight"><code class="language-q">q) {[x] x*x}[3;4]
'rank</code></pre>
<p>Apply a nullary function with no arguments or with an arbitrary argument, which is ignored.</p>
<pre class="highlight"><code class="language-q">q)const42:{[] 42}
q)const42[]
_
q)const42[98.6]
_</code></pre>
<h3 id="614-functions-with-no-return-value">6.1.4 Functions with No Return Value</h3>
<p>Every q function has a return value but sometimes the value carries no meaningful information ‚Äì i.e., it is used purely for side effects. For example, it may send off a message asynchronously without waiting for an acknowledgement of receipt or it may update a global table. To achieve the equivalent of a <code>void</code> return in C, make the expression after the last semi-colon in the function body empty.</p>
<pre class="highlight"><code class="language-q">q)fvoid:{[x] `a set x;}
q)fvoid 42
q)</code></pre>
<p>In fact, the actual return value is the nil item <code>::</code> that is a stand-in for <code>void</code> in this situation. Its display is suppressed in the q console but it can be revealed.</p>
<pre class="highlight"><code class="language-q">q).Q.s1 fvoid 42
"::"</code></pre>
<div class="admonition warning">
<p class="admonition-title">Semi-colon terminators</p>
<p>A common error made by qbies is to use semi-colons in a function body as expression terminators rather than as separators. This effectively makes the function return nil since the last expression is empty.</p>
</div>
<h3 id="615-we-dont-need-no-stinkin-brackets">6.1.5 We Don't Need No Stinkin‚Äô Brackets</h3>
<p>There is an alternative notation for application of unary functions (only) that dispenses with brackets. Simply separate the function from its argument with whitespace ‚Äì customarily a single blank.</p>
<pre class="highlight"><code class="language-q">q){[x] 2*x} 42
84
q)f:{[x] x*x}
q)f 5
_</code></pre>
<p>This convention for function application is called <em>prefix syntax</em> and is the norm in functional programming. While it may be jarring for newcomers, the decrease in superfluous punctuation ‚Äì i.e., program noise ‚Äì is worth the effort.</p>
<h3 id="616-application-of-a-name">6.1.6 Application of a Name</h3>
<p>When a function has been assigned to a global variable, it can be applied by name ‚Äì i.e., use the symbol name of the variable in place of the variable itself.</p>
<pre class="highlight"><code class="language-q">q)f:{x*x}
q)f[5]
_
q)`f[5]
25
q)`f 5
_
q).my.name.space.f:{2*x}
q)`.my.name.space.f[5]
_</code></pre>
<p>This works because a global variable is implemented as a symbolic-name/function pair in a dictionary. Referring to the variable is actually lookup-by-name. Consequently application by name does <strong>not</strong> work for local variables or q system variables.</p>
<div class="admonition warning">
<p class="admonition-title">Do not confuse application using the function name with call-by-name in which parameters are passed by name.</p>
</div>
<h3 id="617-implicit-parameters">6.1.7 Implicit Parameters</h3>
<p>If, like mathematicians, you are satisfied with generic parameters <em>x</em>, <em>y</em> and <em>z</em>, you can omit the formal parameters and their brackets. Three implicit positional parameters <code>x</code>, <code>y</code> and <code>z</code> are automatically defined and available in a function‚Äôs expressions when no parameters are explicitly declared. Thus, the following two specifications result in equivalent input-output relations.</p>
<pre class="highlight"><code class="language-q">{[x] x*x}
{x*x}</code></pre>
<p>As do,</p>
<pre class="highlight"><code class="language-q">{[x;y] x+y}
{x+y}</code></pre>
<div class="admonition note">
<p class="admonition-title">When using implicit parameters, <code>x</code> is always substituted by the first actual argument, <code>y</code> the second and <code>z</code> the third.</p>
</div>
<p>The following function <code>f</code> only evaluates partially unless it is called with three parameters.</p>
<pre class="highlight"><code class="language-q">q)g:{x+z}  / likely meant x+y; requires 3 args in call
q)g[1;2]   / still waiting for 3rd arg ‚Äì i.e., a projection
{x+z}[1;2]
q)g[1;2;3] / 2nd arg is required but ignored
4</code></pre>
<div class="admonition tip">
<p class="admonition-title">Only use the names <code>x</code>, <code>y</code> and <code>z</code> for the first three parameters of a function, either explicit or implicit.</p>
<p>Any other use leads down the path to perdition.</p>
<pre><code class="language-q">
q)evil:{[y;z;x] ...} / don't do this!
</code></pre>
</div>
<h3 id="618-anonymous-functions-and-lambda-expressions">6.1.8 Anonymous Functions and Lambda Expressions</h3>
<p>Many traditional programming languages include the function name as part of its definition. A function without a name is then called an <em>anonymous</em> function. In functional programming, functions are all anonymous and are called <em>lambda expressions</em> or <em>lambdas</em> for short. All q functions are anonymous until assigned to a variable. Incidentally, the term ‚Äúlambda‚Äù actually arose from a typesetting error in Church‚Äôs early work on what became known as the <em>lambda calculus</em>.</p>
<p>An anonymous function can be useful as an in-line macro where it would otherwise be awkward to substitute. For example,</p>
<pre class="highlight"><code class="language-q">f{[...] ...; {...}[...]; ...}</code></pre>
<p>It is arguably more readable to factor this out.</p>
<p>Another use for anonymous functions is a rudimentary form of dynamic dispatch, in which functions are placed in a collection (e.g., list, dictionary, table) and then selected dynamically (i.e., at runtime) rather than by an intrinsic name.</p>
<pre class="highlight"><code class="language-q">q)powers:({1}; {x}; {x*x}; {x*x*x})
‚Ä¶
q)selected:2
q)powers[selected]
{x*x}</code></pre>
<h3 id="619-the-identity-function">6.1.9 The Identity Function <code>::</code></h3>
<p>When <code>::</code> is used with function application syntax, it is the identity function ‚Äì i.e., it returns its input as output.</p>
<p>The naked identity function cannot be used with prefix syntax; it must be enclosed in parentheses.</p>
<pre class="highlight"><code class="language-q">q)::[42]
_
q)::[`a`b`c]
_
q):: 42 / error
'
q)(::) 42
_</code></pre>
<h3 id="6110-functions-are-data">6.1.10 Functions Are Data</h3>
<p>The q data entities we have met until now are atoms (of various types), lists and dictionaries. For those new to functional programming, it may come as a surprise that functions are also data. A function can be passed around just like a long or float ‚Äì e.g., as an item in a list.</p>
<pre class="highlight"><code class="language-q">q)(1; 98.6; {x*x})
_
q)f:{x*x}
q)(f; neg)
_
q)(f; neg)[0]
q)(f; neg)[1; 5]
_</code></pre>
<p>A function can also be used as the input or output value of another function. For example, here is a function that expects a function and a value and applies the function to the value.</p>
<pre class="highlight"><code class="language-q">q)apply:{x y}
q)sq:{x*x}
q)apply[sq; 5]
_</code></pre>
<p>A function that operates on other functions is called a <em>higher-order function</em>. Higher-order functions are a powerful concept from functional programming. The derivative and indefinite integral are higher-order functions in elementary calculus.</p>
<h2 id="62-call-by-name">6.2 Call-by-Name</h2>
<p>Ordinary function application in q uses call-by-value, meaning that arguments are reduced to values at the start of application. In the process, copies are made so that any original values are undisturbed. When the size of the input data is large, this copy may be prohibitive. In this case, there is an alternative method of application, <em>call-by-name</em>, in which names of (global) variables are passed instead of their values.</p>
<p>There is no special syntax for call-by-name in q. Instead, the function implementation simply expects a symbol containing the name of a variable and handles it appropriately. One example of a function that uses call-by-name is the built-in function <a href="https://code.kx.com/q/ref/get/"><code>get</code></a>, which returns the value of the global variable whose name is passed.</p>
<pre class="highlight"><code class="language-q">q)a:42
q)get `a
42</code></pre>
<p>Another example is binary <a href="https://code.kx.com/q/ref/get/#set"><code>set</code></a>, which does the actual work of global assignment. It expects the name of a global variable and the value to be assigned.</p>
<pre class="highlight"><code class="language-q">q)`a set 43
`a
q)a
43</code></pre>
<p>The result of any built-in call-by-name function application is the symbol that was passed as input. This enables call-by-name functions to be chained ‚Äì i.e., composed.</p>
<div class="admonition warning">
<p class="admonition-title">Do not confuse the return value of call-by-name with an error message. The former begins with a back-tick whereas the latter begins with tick.</p>
</div>
<h2 id="63-local-and-global-variables">6.3 Local and Global Variables</h2>
<h3 id="631-defining-local-and-global-variables">6.3.1 Defining Local and Global Variables</h3>
<p>A variable that is assigned with <code>:</code> within a function body is called a <em>local</em> variable. For example, a is a local variable in the following function.</p>
<pre class="highlight"><code class="language-q">q)f:{a:42; a+x}</code></pre>
<div class="admonition note">
<p class="admonition-title">As of this writing (Sep 2015), the maximum number of local variables permitted in a function is 24.</p>
</div>
<p>Some notes on local variables:</p>
<ul>
<li>A local variable exists only for the duration of an application. There is no notion of a static local variable that maintains its value across applications.</li>
<li>A local variable is not visible outside its immediate scope of definition.</li>
<li>A local variable cannot be used as an argument to a q function that uses call-by-name.</li>
<li>
<p>A local variable is not visible within the body of a local function defined in the same scope. Otherwise put,</p>
<p><strong>q does <em>not</em> have lexical scoping</strong>.</p>
</li>
</ul>
<p>Here is a simple example demonstrating the lack of lexical scoping and its consequence. The function <code>f</code> defines a local variable <code>a</code> and a local function <code>helper</code>. In functional programming languages, the variable <code>a</code> is accessible throughout its scope of definition, which is the body of <code>f</code>. In particular, the variable <code>a</code> would be accessible within the body of <code>helper</code>.</p>
<pre class="highlight"><code class="language-q">q)f:{[p1] a:42; helper:{[p2] a*p2}; helper p1}</code></pre>
<p>In q it is not. Nasty surprise!</p>
<pre class="highlight"><code class="language-q">q)f 5
{[p2] a*p2}
'a</code></pre>
<p>Instead, you must declare an additional parameter in the local functions and pass the local variable as an argument. Projection provides a relatively clean way to do this.</p>
<pre class="highlight"><code class="language-q">q)f:{[p1] a:42; helper:{[a; p2] a*p2}[a;]; helper p1}
q)f 5
210</code></pre>
<p>A variable assigned outside any function definition is called a <em>global</em> variable. Global variables are visible inside any function body.</p>
<pre class="highlight"><code class="language-q">q)b:7
q)f:{b*x}
q)f[6]
_</code></pre>
<div class="admonition note">
<p class="admonition-title">Maximum number of global variables</p>
<p>As of this writing (Sep 2015), the maximum number of global variables that can be referenced in a function is 32. </p>
<p>If this is a problem, redesign your code. For example collect values in a list or dictionary and pass that; the dictionary essentially provides pass-by-name.</p>
</div>
<h3 id="632-assigning-global-variables-within-a-function">6.3.2 Assigning Global Variables within a Function</h3>
<p>Although functional programming purists will cringe, you can assign a global within a function body. Some q programmers mistakenly use double colon <code>::</code>, which works provided there is no local variable with the same name.</p>
<pre class="highlight"><code class="language-q">q)b:6
q)f:{b::7; x*b}
q)f[6]
42
q)b
7</code></pre>
<p>This usage of <code>::</code> is analogous to other forms of <em>amend-in-place</em>, such as <code>+:</code> or <code>,:</code>, but using the assignment operator itself <code>:</code>. This accounts for its somewhat unintuitive properties ‚Äì it is not truly a global assignment operator.</p>
<p>If there is a local variable having the same name as the global you intend to assign, double-colon assigns the <strong>local</strong>, not the global.</p>
<pre class="highlight"><code class="language-q">q)b:6
q)f:{b:42; b::x; b}
q)f[98]
98
q)b
6</code></pre>
<div class="admonition tip">
<p class="admonition-title">Global assignment</p>
<p>We recommend against <code>::</code> for global assignment. Instead, use <code>set</code> which truly does global assignment and doesn‚Äôt get hung up on a local-global name collision.</p>
<p>As we saw earlier, <code>set</code> uses call-by-name.
</p><pre><code class="language-q">
q)a:42
q)f:{a:98.6; `a set x}
q)f 43
`a
q)a
43
</code></pre>
</div>
<h2 id="64-projection">6.4 Projection</h2>
<p>Projection means specifying only some of the parameters in function application, resulting in a function of the remaining parameters.</p>
<h3 id="641-function-projection">6.4.1 Function Projection</h3>
<p>In some circumstances, a portion of the arguments to a multivalent function may be fixed while the remaining arguments vary. A common example is where a date is the last parameter and you apply the function for many dates keeping all other inputs fixed. In this situation, you can specify the fixed arguments and leave the others for later. This is called <em>projecting</em> the function onto the remaining arguments. Notationally, projection is a partial application in which some arguments are supplied and the others are omitted ‚Äì i.e., nothing is in those slots.</p>
<p>For example, a homegrown binary function that adds its arguments can be projected onto the second parameter by providing just the first argument.</p>
<pre class="highlight"><code class="language-q">q)add:{x+y}
q)add[42;]
{x+y}[42;]</code></pre>
<p>You can see from the console that q views the projection as a partial application that awaits its remaining argument(s). The projected function is a legitimate unary function, which adds its input to the constant 42.</p>
<pre class="highlight"><code class="language-q">q)add[42;][3]
45</code></pre>
<p>Since functions are first class, we can assign a projection to a variable and then apply it, none the wiser of its origin.</p>
<pre class="highlight"><code class="language-q">q)g:add[42;]
q)g[3]
_</code></pre>
<p>Projection is related to <em>currying</em> in functional programming (named after Haskell Curry who did important early work on the theory of combinators). Both provide realizations of the mathematical observation that a function of two parameters is equivalent to a function of the first parameter that returns a function of the second parameter. This extends to multiple parameters as well. In q you simply project out successive parameters.</p>
<pre class="highlight"><code class="language-q">q)add3:{x+y+z}
q)add3[2][3][4]
9</code></pre>
<p>Here we can view the result of <code>add3</code> applied to 2 as a function that when applied to 3 returns a function that when applied to 4 yields <code>add[2;3;4]</code>.</p>
<div class="admonition tip">
<p class="admonition-title">Style recommendation</p>
<p>We recommend that you do <em>not</em> omit trailing semi-colons in projections, as this can obscure the intent of code. For example, if you came upon the following while reading q code, how would you know that <code>mystery</code> is actually a binary function unless you saw the comment line?</p>
<pre><code class="language-q">
q)mystery:f[2] / surprise! f is actually f:{x+y+z}
</code></pre>
</div>
<p>The brackets denoting a function projection are required, but the additional brackets in a unary projection‚Äôs application can be omitted using prefix syntax as with any function.</p>
<pre class="highlight"><code class="language-q">q){x+y}[42;][3]
_
q){x+y}[42;] 3
_</code></pre>
<p>Choice of notation is a matter of coding style. Some coders have good style; many do not.</p>
<div class="admonition warning">
<p class="admonition-title">The function body in a projection is captured at the time it is first encountered by the interpreter.</p>
<p>Thus if the underlying function is subsequently changed, the projection is not.</p>
<pre><code class="language-q">
q)f:{x-y}
q)g:f[42;]
q)g
{x-y}[42;]
q)g[6]
_
q)f:{x+y}
q)g
_
q)g[6]
_
</code></pre>
</div>
<h3 id="642-operator-projection">6.4.2 Operator Projection</h3>
<p>When used in infix form, a q operator can be projected by fixing its left operand (only). This requires parentheses. For example, the projection of <code>*</code> onto its right operand is,</p>
<pre class="highlight"><code class="language-q">q)(7*) 6
42</code></pre>
<p>Due to the overloading of parentheses in q, an operator cannot be projected by fixing its right argument, since this would lead to notational ambiguity. For example, <code>-42</code> can only be the atom -42 and not a projection.</p>
<p>Nonetheless, every operator is a function, so you can project it in prefix form.</p>
<pre class="highlight"><code class="language-q">q)-[;42] 98
_</code></pre>
<p>The whitespace is actually not necessary in prefix syntax here since the brackets make things unambiguous.</p>
<pre class="highlight"><code class="language-q">q)(7*)6
_
q)-[;42]98
_</code></pre>
<p>Such notation is an acquired taste not shared by the author.</p>
<h3 id="643-multiple-projections">6.4.3 Multiple Projections</h3>
<p>Functions having valence greater than two can be projected in multiple ways. For example, a function of valence three can be projected onto the second parameter by specifying the first and third. The result is a unary function of the second parameter only.</p>
<pre class="highlight"><code class="language-q">q){x+y+z}[1;;3]
{x+y+z}[1;;3]
q){x+y+z}[1;;3] 2
6</code></pre>
<p>We could arrive at the same result in two steps.</p>
<ul>
<li><em>Step 1</em>: Project onto the second and third parameters by specifying just the first argument. This yields a binary function.</li>
</ul>
<pre class="highlight"><code class="language-q">q){x+y+z}[1;;]
{x+y+z}[1;;]
q){x+y+z}[1;;][2;3]
_</code></pre>
<ul>
<li><em>Step two</em>: Project the resulting binary function onto its first parameter by providing only the second.</li>
</ul>
<pre class="highlight"><code class="language-q">q){x+y+z}[1;;][;3]
{x+y+z}[1;;][;3]
q){x+y+z}[1;;][;3] 2
_</code></pre>
<p>This is equivalent to projecting in the reverse order.</p>
<pre class="highlight"><code class="language-q">q){x+y+z}[;;3][1;]
{x+y+z}[;;3][1;]
q){x+y+z}[;;3][1;] 2
_</code></pre>
<h2 id="65-everything-is-a-map">6.5 Everything Is a Map</h2>
<p>Here we explore the deep relationship between q data structures and functions. While this section can be skipped on first reading, that would be like not eating your vegetables when you were a kid.</p>
<h3 id="651-similarity-of-notation">6.5.1 Similarity of Notation</h3>
<p>You have no doubt noticed that the notation for list indexing, dictionary lookup and unary function application are identical. Namely,</p>
<pre class="highlight"><code class="language-q">q)L:0 1 4 9 16 25 36
q)f:{x*x}
q)L[2]
_
q)L 2
_
q)f[2]
_
q)f 2
_</code></pre>
<p>This is no accident. In <a href="https://code.kx.com/q4m3/3_Lists/">Chapter 3</a> we saw that a list is a map defined by positional retrieval via item indexing. In <a href="https://code.kx.com/q4m3/5_Dictionaries/">Chapter 5</a> we saw that a dictionary is a map defined by key-value lookup. A function is a map defined by a sequence of expressions representing an algorithm for computing an output value from the input. The common notation is simply that of a map. It may take a little time to get accustomed to the Zen of q.</p>
<h3 id="652-list-of-indices-keys-and-arguments">6.5.2 List of Indices, Keys and Arguments</h3>
<p>Just as we can use a list of indices to retrieve items from a list, so can dictionary lookup retrieve a list of values corresponding to a list of keys. And a list of arguments to an atomic function yields a list of outputs. This justifies the common notation.</p>
<pre class="highlight"><code class="language-q">q)L:10 20 30 40 50
q)L[2 5]
_
q)I:2 5
q)L I
_
q)d:`a`b`c!10 20 30
q)ks:`a`c
q)d ks
_
q)f[2 5]
_
q)f I
_</code></pre>
<p>In fact, these are all examples of composition of maps.</p>
<pre class="highlight"><code class="language-txt">  I     L
--------------
0 |-&gt; 2 |-&gt; 30
1 |-&gt; 5 |-&gt; 0N

  ks     d
---------------
0 |-&gt; `a |-&gt; 10
1 |-&gt; `c |-&gt; 30

  I     f
--------------
0 |-&gt; 2 |-&gt; 4
1 |-&gt; 5 |-&gt; 25</code></pre>
<h3 id="653-indexing-at-depth">6.5.3 Indexing at Depth</h3>
<p>Next we examine the correspondence between indexing at depth and multivalent function evaluation. Notationally, a nested list is a list of lists, but it can also be viewed functionally as multivariate position retrieval. The display of a nested list tells us how: go down then over.</p>
<pre class="highlight"><code class="language-q">q)a:(1 2 3; 100 200)
q)a
1 2 3
100 200
q)a[1;0]
100</code></pre>
<p>The first index goes down and the second index goes over. A more deeply nested list is a positional map whose valence is one greater than the depth of nesting.</p>
<p>Similarly, a dictionary with complex values can also be viewed as a multivariate map.</p>
<pre class="highlight"><code class="language-q">q)d:`a`b!(1 2 3; 100 200)
q)d[`a;1]
2</code></pre>
<p>In this case, the first parameter locates a key and the second goes into the value list.</p>
<h3 id="654-projection-and-index-elision">6.5.4 Projection and Index Elision</h3>
<p>You have no doubt noticed that the notations for <a href="https://code.kx.com/q/basics/application/#projection">function projection</a> and elided indices in a list are identical. For example, an array is positional retrieval in which the first index is "down" and the second is "over." Thus eliding the first index indeed results in a list in which the remaining index is simply ordinary positional retrieval.</p>
<pre class="highlight"><code class="language-q">q)m:(10 20 30; 100 200 300)
q)m
10  20  30
100 200 300
q)m[1;2]
_
q)L:m[;2]
q)L
_
q)L[1]
_</code></pre>
<h3 id="655-out-of-bounds-index">6.5.5 Out of Bounds Index</h3>
<p>Viewing a list as a map on an integer domain also motivates the behavior of item indexing in the case of an out of bounds index. In traditional languages, this would either result in some sort of uncaught error ‚Äì the infamous indexing off the end of an array ‚Äì or an exception.</p>
<p>By viewing a list as a function defined on a sub-domain of integers, it is reasonable to extend the domain of the function to all integers by assigning a null output value outside the proper domain. Here null means "missing value." As we have seen previously,</p>
<pre class="highlight"><code class="language-q">q)10 20 30 40[100]
0N
q)`a`b`c[-1]
`
q)(1.1; 1; `1)[3]
0n</code></pre>
<p>The behavior for dictionaries is completely analogous.</p>
<pre class="highlight"><code class="language-q">q)d:`a`b`c!10 20 30
q)d[`x]
0N</code></pre>
<h2 id="66-atomic-functions">6.6 Atomic Functions</h2>
<p>The characterization of q as a vector language arises from the fact that most of the built-in operations are atomic. We examine the notion of <a href="https://code.kx.com/q/basics/atomic/">atomic functions</a> in more detail. The application of an atomic function is characterized by the fact that it recurses into an argument‚Äôs structure until it gets to atoms and then applies there. It does this without explicit loops or other control flow constructs.</p>
<h3 id="661-unary-atomic-functions-and-map">6.6.1 Unary Atomic Functions and "map"</h3>
<p>Atomic behavior is easiest to see with a unary function.</p>
<pre class="highlight"><code class="language-q">q)neg 10
-10
q)neg 10 20 30
-10 -20 -30
q)neg (10 20 30; 40 50)
-10 -20 -30
-40 -50
q)neg `a`b`c!10 20 30
a| -10
b| -20
c| -30
q)neg `a`b`c!(10 20; 30 40 50; 60)
a| -10 -20
b| -30 -40 -50
c| -60</code></pre>
<p>A consequence of this behavior is that the result of a unary atomic function always has the same shape as its argument ‚Äì i.e., the output conforms to the input.</p>
<p>A special case of this is that applying an atomic function to a list is the same as applying it to each item in the list, which is sometimes described as "atomic functions extend automatically to lists." Similar functionality is achieved with "foreach" in traditional languages and the higher-order function "map" in functional languages.</p>
<h3 id="662-binary-atomic-functions-and-zip">6.6.2 Binary Atomic Functions and zip</h3>
<p>Atomic behavior is more interesting for binary functions. A binary function can be atomic in either or both arguments. The first case can be thought of as a unary atomic function if you fix the non-atomic argument ‚Äì i.e. project the function. For example, <a href="https://code.kx.com/q/ref/find/">Find</a> (<code>?</code>) is atomic in only its second argument since it consumes the entire first argument in its search.</p>
<pre class="highlight"><code class="language-q">q)10 20 30?10
0
q)10 20 30?10 20 30 40 50
0 1 2 3 3
q)(enlist 10)?10
0
q)10 20?10
0
q)10 20 30 40 50?10
0</code></pre>
<p>The arithmetic, comparison and relation operators are all atomic in both operands. This leads to four cases for application:</p>
<ul>
<li>atom with atom</li>
<li>atom with list</li>
<li>list with atom</li>
<li>list with list</li>
</ul>
<p>In the last case, the two list operands must have the same length.</p>
<pre class="highlight"><code class="language-q">q)1+10
11
q)1+10 20 30
11 21 31
q)1 2 3+10
11 12 13
q)1 2 3+10 20 30
11 22 33</code></pre>
<p>Similar behavior is achieved with "zip" in traditional and functional programming.</p>
<h3 id="663-creating-atomic-functions">6.6.3 Creating Atomic Functions</h3>
<p>Brief meditation reveals that the composition of atomic functions is atomic. Hence, the guaranteed way to build your own atomic functions is to compose built-in atomic functions. First unary.</p>
<pre class="highlight"><code class="language-q">q)f:{(x*x)+(2*x)-1}
q)f 0
-1
q)f til 10
-1 2 7 14 23 34 47 62 79 98</code></pre>
<p>Now binary.</p>
<pre class="highlight"><code class="language-q">q)pyth:{sqrt (x*x)+y*y}
q)pyth[1; 1]
1.414214
q)pyth[1; 1 2 3]
1.414214 2.236068 3.162278
q)pyth[1 2 3; 1 2 3]
1.414214 2.828427 4.242641</code></pre>
<p>You might ask how to get this behavior with a function that is not atomic. Timely question.</p>
<h2 id="67-iterators">6.7 Iterators</h2>
<p><a href="https://code.kx.com/q/ref/iterators/">Iterators</a> (previously <em>adverbs</em>) are higher-order functions that modify the behavior of functions for application on lists. </p>
<!-- The terminology derives from thinking of q operators as verbs.  -->
<p>Proficiency in the use of iterators is one skill that separates q pretenders from q contenders.</p>
<p>Not every function is atomic, but we may still want to apply it to individual items of a data structure without loopy code. Iterators to the rescue.</p>
<h3 id="671-unary-each">6.7.1 Unary each</h3>
<p>We have seen that an atomic function automatically applies to the atoms in a nested list.</p>
<pre class="highlight"><code class="language-q">q)neg (1 2 3; 4 5)
-1 -2 -3
-4 -5</code></pre>
<p>Clearly a function that aggregates a list into an atom cannot be atomic since it collapses the list structure. In particular, aggregate functions operate only at the top level of a nested list.</p>
<pre class="highlight"><code class="language-q">q)count 10 20 30
_
q)count (10 20 30; 40 50)
_</code></pre>
<p>Suppose instead that we want to count each of the two items in our nested list. This is precisely what the <a href="https://code.kx.com/q/ref/each/"><code>each</code></a> iterator does. It modifies a unary function so that it applies to each item in a list rather than to the list as a whole. When used infix, <code>each</code> follows the function after (required) whitespace.</p>
<pre class="highlight"><code class="language-q">q)count each (10 20 30; 40 50)
3 2</code></pre>
<p>The nature of <code>each</code> as a higher-order function is more clearly revealed in its equivalent prefix form. This may look odd at first, but it shows that <code>each</code> takes a function and modifies its behavior by applying to each item in a list.</p>
<pre class="highlight"><code class="language-q">q)each[count] (10 20 30; 40 50)
3 2</code></pre>
<div class="admonition note">
<p class="admonition-title">Each</p>
<p>The higher-order function <code>each</code> is similar to "foreach" in imperative languages and is called "map" in functional programming languages. It is one half of the famous map-reduce paradigm.</p>
</div>
<p>We could say informally that <code>each</code> makes a non-atomic function act atomically‚Ä¶ at least at one level. For deeply nested lists, you need to iterate <code>each</code> to apply a function at deeper levels.</p>
<pre class="highlight"><code class="language-q">q)(count each) each ((1 2 3; 3 4); (100 200; 300 400 500))
3 2
2 3
q)each[each[count]] ((1 2 3; 3 4); (100 200; 300 400 500))
_</code></pre>
<p>The effect of iterated <code>each</code> is perhaps most clearly observed when applied to a matrix, where successive higher-order applications cause the original function to be applied on another axis.</p>
<pre class="highlight"><code class="language-q">q)count (1 2 3; 10 20 30)
_
q)count each (1 2 3; 10 20 30)
_
q)(count each) each (1 2 3; 10 20 30)</code></pre>
<p>You can use <code>each</code> with any unary function, although it is redundant on atomic functions.</p>
<pre class="highlight"><code class="language-q">q)reverse "live"
"evil"
q)reverse ("life"; "the"; "universe"; "and"; "everything")
_
q)reverse each ("life"; "the"; "universe"; "and"; "everything")
_
q)neg each (1 2 3; 4 5)
_</code></pre>
<p>It often arises that you want to convert a vector of length n to an n√ó1 matrix. You can do that with <code>enlist each</code> but <code>flip enlist</code> executes faster for large lists.</p>
<pre class="highlight"><code class="language-q">q)enlist each 1001 1002 1004 1003
1001
1002
1004
1003
q)flip enlist 1001 1002 1004 1003
_</code></pre>
<h3 id="672-each">6.7.2 Each <code>'</code></h3>
<p>An atomic operator automatically applies to corresponding pairs of items when applied to lists of the same length.</p>
<pre class="highlight"><code class="language-q">q)1 2 3+10 20 30
11 22 33</code></pre>
<p>The binary Join operator <code>,</code> is not atomic since it consumes (copies of) both of its operands in their entirety when it concatenates.</p>
<pre class="highlight"><code class="language-q">q)"abc","de"
"abcde"</code></pre>
<p>Suppose we want to join list items pair-wise. For example,</p>
<pre class="highlight"><code class="language-q">q)("abc"; "uv"),'("de"; "xyz")
"abcde"
"uvxyz"</code></pre>
<p>The iterator <a href="https://code.kx.com/q/ref/maps/#each">Each <code>'</code></a> modifies a binary function (operator, keyword) to apply pairwise to corresponding list items. Conventionally no whitespace should be between <code>'</code> and the function it modifies but this does not generate an error. In some programming languages, Each is called "zip".</p>
<pre class="highlight"><code class="language-q">q)("abc"; "uv"),'("de"; "xyz")
"abcde"
"uvxyz"</code></pre>
<p>There is no effect when the arguments are atoms.</p>
<pre class="highlight"><code class="language-q">q)3,'4
3 4</code></pre>
<p>A function modified by Each has the usual properties of atomic binary functions. For example, you get a length error if arguments don't line up.</p>
<pre class="highlight"><code class="language-q">q)("abc"; "uv"),'("de"; "xyz"; "uhoh")
'length</code></pre>
<p>The modified function also extends an atom to match a list. You will see this idiom often. For example,</p>
<pre class="highlight"><code class="language-q">q)1,'10 20 30
1 10
1 20
1 30
q)1 2 3,'10
_
q)2#'("abcde"; "fgh"; "ijklm")
"ab"
"fg"
"ij"</code></pre>
<p>If you are so inclined, you can apply a function modified by Each using brackets. This is not common but can simplify things in the functional form of queries (see <a href="https://code.kx.com/q4m3/9_Queries_q-sql/#912-functional-forms">¬ß9.12</a>).</p>
<pre class="highlight"><code class="language-q">q),'[("abc"; "uv"); ("de"; "xyz")]
_</code></pre>
<p>The idiom <code>,'</code> works fine for making a list of pairs from two simple lists but does not always work as expected with general lists. For example it loses the enlisting of the singleton in the following.</p>
<pre class="highlight"><code class="language-q">q)L1:(enlist `a; `b)
q)L2:1 2
q)L1,'L2
`a 1
`b 2</code></pre>
<p>A reliable way to make a list of pairs from a pair of lists is:</p>
<pre class="highlight"><code class="language-q">q)flip (L1; L2)
,`a 1
`b 2</code></pre>
<div class="admonition note">
<p class="admonition-title">Advanced</p>
<p>A nice example of <code>,'</code> arises when both operands are tables. Since a table is a list of records, it is possible to apply <code>,'</code> to tables with the same number of rows. The record dictionaries in each row are upserted, resulting in a sideways join of the tables, as in the following example.</p>
</div>
<pre class="highlight"><code class="language-q">q)t1:([] c1:1 2 3)
q)t2:([] c2:`a`b`c)
q)t1,'t2
c1 c2
-----
1  a
2  b
3  c</code></pre>
<h3 id="673-each-left">6.7.3 Each Left <code>\:</code></h3>
<p>An atomic operator extends an atom in the right operand to match a list on the left.</p>
<pre class="highlight"><code class="language-q">q)1 2 3+10
_</code></pre>
<p>The <a href="https://code.kx.com/q/ref/maps/#each-left-and-each-right">Each Left</a> iterator <code>\:</code> modifies a binary function so that it applies the second argument with each item of the first argument ‚Äì for example, to append a string to each string in a list. We insert unnecessary whitespace around the modified function in the following example to make it more readable.</p>
<pre class="highlight"><code class="language-q">q)("abc"; "de"; enlist "f") ,\: "&gt;"
"abc&gt;"
"de&gt;"
"f&gt;"</code></pre>
<p>Traditionally there is no space between the iterator and the function it modifies but this causes no error.</p>
<h3 id="674-each-right">6.7.4 Each Right <code>/:</code></h3>
<p>An atomic operator extends an atom in the left operand to match a list on the right.</p>
<pre class="highlight"><code class="language-q">q)10+1 2 3
_</code></pre>
<p>The <a href="https://code.kx.com/q/ref/maps/#each-left-and-each-right">Each Right</a> iterator <code>/:</code> modifies a binary function so that it applies the first argument to each item of the second argument. For example, to prepend a string to each string in a list. Again we surround the modified function with unnecessary whitespace for readability.</p>
<pre class="highlight"><code class="language-q">q)"&lt;/" ,/: ("abc"; "de"; enlist "f")
_</code></pre>
<p>Composing the last two examples makes data XML-ey (say it aloud) without loops.</p>
<pre class="highlight"><code class="language-q">q)"&lt;/",/:("abc"; "de"; enlist "f"),\:"&gt;"
_</code></pre>
<h3 id="675-cross-product">6.7.5 Cross Product</h3>
<p>A cross (Cartesian) product of two lists pairs each item on the left with each item on the right. If we compose Join with Each Right and Each Left, we are almost there, except that there is an extra level of nesting, which we eliminate with the built-in <a href="https://code.kx.com/q/ref/raze/"><code>raze</code></a>.</p>
<pre class="highlight"><code class="language-q">q)1 2 3,/:\:10 20
1 10 1 20
2 10 2 20
3 10 3 20
q)raze 1 2 3,/:\:10 20
1 10
1 20
2 10
2 20
3 10
3 20</code></pre>
<p>The built-in operator <a href="https://code.kx.com/q/ref/cross/"><code>cross</code></a> computes this cross product.</p>
<pre class="highlight"><code class="language-q">q)1 2 3 cross 10 20
_</code></pre>
<p>Observe that we could alternatively compose Each Left with Each Right and would arrive at the transpose of the previous result.</p>
<pre class="highlight"><code class="language-q">q)raze 1 2 3,\:/:10 20
1 10
2 10
3 10
1 20
2 20
3 20</code></pre>
<h3 id="676-over-for-accumulation">6.7.6 Over (<code>/</code>) for Accumulation</h3>
<p>The <a href="https://code.kx.com/q/ref/accumulators/">Over</a> iterator <code>/</code> is a higher-order function that provides the principal mechanism for recursion in q. In its simplest form it modifies a binary function to accumulate results over a list.</p>
<p>Suppose we want to add the first 10 natural numbers starting at 1. In imperative programming this requires control flow: initialize a result variable, establish a loop counter and then loop while adding into the result until the counter reaches the end of the list. In functional programming, simply declare that you want to accumulate starting with an initial value of the accumulator. No counters, no tests, no loop. You say "what" to do rather than "how" to do it.</p>
<p>Let‚Äôs see this in q. For readability, we have included optional whitespace.</p>
<pre class="highlight"><code class="language-q">q)0 +/ 1 2 3 4 5 6 7 8 9 10
55</code></pre>
<p>In this expression, we apply a compound operator formed from <code>+</code> modified by Over <code>/</code>.</p>
<div class="admonition warning">
<p class="admonition-title">There can be no whitespace between the function and <code>/</code>, due to <code>/</code> also being used to begin a comment.</p>
</div>
<p>The initial accumulator value is the left operand and the list to accumulate over is the right operand. Under the covers, each item of the list is progressively added into the accumulator, moving across the list until the end is reached. The final accumulated value is returned. In our example, 1 is added into the initial accumulator value of 0 to get 1; then 2 is added to this value to get 3; and so on until the end of the list. Just like old-fashioned imperative code, except you never see it. Here is an instrumented form of accumulating sum. It uses the <code>0N!</code> operator to display the accumulator <code>x</code> paired with the next input <code>y</code> before returning their sum.</p>
<pre class="highlight"><code class="language-q">q)addi:{0N!(x;y); x+y}
q)0 addi/ 1 2 3 4 5
0 1
1 2
3 3
6 4
10 5
15</code></pre>
<p>Observe that as a higher-order function <code>/</code> takes a binary function and returns a related binary function. The operands of the modified function are no longer symmetric ‚Äì i.e., the left operand is the initial accumulator value and the right operand is the list to be accumulated.</p>
<div class="admonition note">
<p class="admonition-title">In functional programming languages Over is called <em>fold</em> or <em>reduce</em>. Along with <code>each</code> this completes the famous map-reduce paradigm.</p>
</div>
<p>Often the generality of specifying the initial value of the accumulator is unnecessary. In our summation example, we could initialize the accumulator with the first list item and then accumulate the remaining items. The syntax for this form encloses the modified function in parentheses and omits the initial accumulator.</p>
<pre class="highlight"><code class="language-q">q)(+/) 1 2 3 4 5 6 7 8 9 10
55</code></pre>
<p>Another way to think of this is by representing the list in general form.</p>
<p>(1; 2; 3; 4; 5; 6; 7; 8; 9; 10)</p>
<p>Then <code>+/</code> effectively replaces the semi-colons with <code>+</code>, associated to the left.</p>
<p>A few notes about the alternate form of Over.</p>
<ul>
<li>The parentheses are mandatory</li>
<li>The modified function in this form is unary</li>
<li>This construct is actually k and not q. Don‚Äôt tell anyone you are writing k.</li>
</ul>
<p>Both the unary and binary forms can be written in prefix.</p>
<pre class="highlight"><code class="language-q">q)+/[0; 1 2 3 4 5 6 7 8 9 10]
_
q)+/[1 2 3 4 5 6 7 8 9 10]
_</code></pre>
<p>The basic Over pattern is powerful. Use various binary functions to obtain common aggregate operations.</p>
<pre class="highlight"><code class="language-q">q)(*/) 1 2 3 4 5 6 7 8 9 10 / product
3628800
q)(|/) 7 8 4 3 10 2 1 9 5 6 / maximum
10
q)(&amp;/) 7 8 4 3 10 2 1 9 5 6 / minimum
1</code></pre>
<p>Common aggregates are given their own names in q.</p>
<table>
<thead>
<tr>
<th>aggregate</th>
<th>name</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>+/</code></td>
<td><code>sum</code></td>
</tr>
<tr>
<td><code>*/</code></td>
<td><code>prd</code></td>
</tr>
<tr>
<td><code>|/</code></td>
<td><code>max</code></td>
</tr>
<tr>
<td><code>&amp;/</code></td>
<td><code>min</code></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Anyone with information about the location of the missing ‚Äòo‚Äô in <code>prd</code> please notify KX.</p>
</div>
<p>The edge cases when the above aggregates are applied to empty lists are completely determined by the appropriate invariants. For example, for <code>|/</code> the following must hold for the join of any numeric lists <code>L1</code> and <code>L2</code>.</p>
<pre class="highlight"><code class="language-q">max[L1,L2] = max[L1]|max[L2]</code></pre>
<p>After a moment of meditation we realize that choosing either <code>L1</code> or <code>L2</code> to be an empty list of numeric type forces,</p>
<pre class="highlight"><code class="language-q">q)(|/) `long$()
-0W
q)(|/) `float$()
-0w</code></pre>
<details class="note">
<summary>Advanced: morphism</summary>
<p>For those who know about such things, the above equation says that <code>|/</code> is a morphism from the free monoid of lists with concatenation <code>,</code> to the monoid of naturals with <code>|</code>. The edge case says the morphism preserves the identity. </p>
<p>Other edge cases are analogous.</p>
<pre><code class="language-q">
q)(&amp;/) `long<span class="arithmatex">\(()
0W
q)(+/) \`long\)</span>()
_
q)(*/) `long$()
_
q)(,/) ()
_
</code></pre>
</details>
<p>Applying <code>,/</code> across a list concatenates the items, effectively eliminating the top level of nesting. If there is only one level of nesting, this flattens a list of lists to a plain list. The function <code>,/</code> goes by the descriptive name <code>raze</code>.</p>
<pre class="highlight"><code class="language-q">q)(,/)((1 2 3; 4 5); (100 200; 300 400 500))
1 2 3
4 5
100 200
300 400 500
q)raze ((1 2 3; 4 5); (100 200; 300 400 500))
_</code></pre>
<div class="admonition note">
<p class="admonition-title">For those who know about monads, lists comprise a monad. In Haskell-speak, <code>each</code> serves as <code>fmap</code>, <code>enlist</code> as <code>return</code> and <code>,/</code> as <code>join</code>.</p>
</div>
<p>You can use your own function with either form of Over. The modified function can even be used infix, even though your original function cannot.</p>
<pre class="highlight"><code class="language-q">q)f:{2*x+y}
q)100 f/ 1 2 3 4 5 6 7 8 9 10
_
q)(f/) 1 2 3 4 5 6 7 8 9 10
_</code></pre>
<h3 id="677-more-over-iteration">6.7.7 More Over: Iteration</h3>
<p>The next pattern of recursion we investigate is another declarative equivalent of loopy code. In this version of <code>/</code>, the left operand is a natural number indicating how many times to perform the iteration and the right operand is the initial value.</p>
<p>Let‚Äôs compute the n<sup>th</sup> Fibonacci number ‚Äì see <a href="https://code.kx.com/q4m3/1_Q_Shock_and_Awe/#112-example-fibonacci-numbers">¬ß1.12</a> for a more detailed derivation of <code>fib</code>. Again the modified function can be used infix or prefix.</p>
<pre class="highlight"><code class="language-q">q)fib:{x,sum -2#x}
q)10 fib/ 1 1
1 1 2 3 5 8 13 21 34 55 89 144
q)fib/[10; 1 1]
_</code></pre>
<p>Yet another version of <code>/</code> runs the recursion until convergence, or until a loop is detected. Our example uses a simple form of Newton-Raphson ‚Äì see <a href="https://code.kx.com/q4m3/1_Q_Shock_and_Awe/#113-example-newtons-method-for-nth-roots">¬ß1.13</a> for a detailed exposition for n<sup>th</sup> roots. In this section we illustrate a variation of the square root in which we use a numerical approximation for the derivative. The approximation is the slope of the secant through points an epsilon to the left and right of <em>x</em>. This works provided we make epsilon sufficiently small because the derivative is defined as the slope of the tangent, which is the limit of the slope of the secant as epsilon approaches 0. Recall that in order to compute the square root of 2, we find the zero of <code>{-2+x*x}</code>.</p>
<pre class="highlight"><code class="language-q">q)f:{-2+x*x}
q)secant:{[f;x;e] (f[x+e]-f x-e)%2*e}
q){x-f[x]%secant[f; x; 1e-6]}/[1.5]
1.414214</code></pre>
<p>How does q determine convergence? At each step the result is compared to that of the previous step. If the two agree within equality tolerance (10<sup>-14</sup> at the time of this writing ‚Äì Sep 2015) the algorithm is considered to have converged and the recursion is complete; otherwise it continues.</p>
<p>Mathematically, it is possible to generate an infinite loop with Newton-Raphson. To wit, we select the function <em>x</em><sup>3</sup> ‚Äì 2<em>x</em> + 2 and choose the initial value 0, which causes the algorithm to go into a cycle.</p>
<pre class="highlight"><code class="language-q">q)newtcycle:{[xn] xn-((xn*xn*xn)+(-2*xn)+2)%-2+3*xn*xn}
q)newtcycle/[0.0]
1f</code></pre>
<p>How did q detect the cycle and stop the iteration? At each step it compares the result with the initial value. If they match, a cycle has occurred and the recursion is halted; otherwise it continues. Note that we mean "match" literally as in the <code>~</code> operator.</p>
<div class="admonition warning">
<p class="admonition-title">Open loops</p>
<p>If the values are equal but of different type, no cycle is detected and the loop will continue. In our example, providing a non-float initial value will cause an infinite loop. You will have to kill your console session if you enter the following.</p>
<pre><code class="language-q">
q)newtcycle/[0] / oops
</code></pre>
</div>
<p>The final overload of <code>/</code> is equivalent to a ‚Äúwhile‚Äù loop in imperative programming. It provides a declarative way to specify a test to end the iteration. Thinking functionally, we provide a predicate function that is applied to the result at each step. The iteration continues as long as the predicate result is <code>1b</code> and stops otherwise. For example, we stop the computation of the Fibonacci sequence once it exceeds 1000 as follows.</p>
<pre class="highlight"><code class="language-q">q)fib:{x,sum -2#x}
q)fib/[{1000&gt;last x}; 1 1]
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597</code></pre>
<h3 id="678-scan">6.7.8 Scan <code>\</code></h3>
<p>The Scan iterator <code>\</code> is a higher-order function that behaves just like <code>/</code> except that it returns all the intermediate accumulations instead of just the final one. Whereas Over produces an aggregate function that collapses a list, Scan produces a function whose output has the same number of items as its input ‚Äì i.e., a <em>uniform</em> function. Informally, Scan is a ‚Äúrunning‚Äù version of Over.</p>
<p>We omit optional whitespace in the following so that you can get accustomed to reading "real q."</p>
<pre class="highlight"><code class="language-q">q)0+\1 2 3 4 5 6 7 8 9 10
1 3 6 10 15 21 28 36 45 55
q)(*\)1 2 3 4 5 6 7 8 9 10
_
q)(|\)7 8 4 3 10 2 1 9 5 6
_
q)(&amp;\)7 8 4 3 10 2 1 9 5 6
_
q)100 f\1 2 3 4 5 6 7 8 9 10
_
q)(f\)1 2 3 4 5 6 7 8 9 10
_</code></pre>
<p>All the variations of Over are also available with Scan. Switching to Scan can be useful to see intermediate results of an accumulation. For example, we can see how fast Newton-Raphson converges to the square root by setting the float display to unlimited precision and running Scan.</p>
<pre class="highlight"><code class="language-q">q)newtsqrt[1.0]
q)\P 0
q)newtsqrt[1.0]
1 1.5 1.4166666666666667 1.4142156862745099 1.4142135623746899
1.4142135623730951</code></pre>
<h3 id="679-each-prior">6.7.9 Each Prior (<code>':</code>)</h3>
<p>The iterator <a href="https://code.kx.com/q/ref/maps/#each-prior">Each Prior</a> <code>':</code> provides a declarative way to perform a binary operation on each item of a list with its predecessor.</p>
<div class="admonition tip">
<p class="admonition-title">During traversal of the list, the current item is the left operand and the previous item is the right operand.</p>
</div>
<p>Since the initial item of the list does not have a predecessor, we must provide one in the left operand of the modified operator. One choice is the initial item of the source list. For example, to calculate the deltas of a list of prices.</p>
<pre class="highlight"><code class="language-q">q)100 -': 100 99 101 102 101
0 -1 2 1 -1</code></pre>
<p>As with the other iterators, there is a unary form of Each Prior (technically, it is k). It may come as a surprise that the unary form does <strong>not</strong> choose the initial item of the input list as the initial predecessor. Rather, it returns the initial item of the input on <code>-</code> and <code>%</code>.</p>
<pre class="highlight"><code class="language-q">q)(-':)100 99 101 102 101
100 -1 2 1 -1
q)deltas 100 99 101 102 101
100 -1 2 1 -1
q)(%':)100 99 101 102 101
100 0.98999999999999999 1.0202020202020201 1.0099009900990099 0.99019607843137258
q)ratios 100 99 101 102 101
_</code></pre>
<p>The motivation is that the initial predecessor is implicitly chosen as the identity for the binary function (assuming such exists). This has the advantage of preserving desirable invariants.</p>
<pre class="highlight"><code class="language-q">q)sums deltas 100 99 101 102 101
100 99 101 102 101
q)deltas sums 100 99 101 102 101
_</code></pre>
<p>On the other hand, if you are looking for anomalies in absolute differences ‚Äì e.g., price changes ‚Äì you will get a nasty surprise.</p>
<pre class="highlight"><code class="language-q">q)deltas 100 99 101 102 101
100 -1 2 1 -1</code></pre>
<p>It is easy enough to make our own version for this case.</p>
<pre class="highlight"><code class="language-q">q)deltas0:{first[x] -': x}
q)deltas0 100 99 101 102 101
0 -1 2 1 -1</code></pre>
<p>A powerful idiom with Each Prior uses Match <code>~</code> to test if successive items are identical. It is actually more useful to know where they do not match; the latter is built in as <a href="https://code.kx.com/q/ref/differ"><code>differ</code></a>.</p>
<pre class="highlight"><code class="language-q">q)(~':) 1 1 1 2 2 3 4 5 5 5 6 6
011010001101b
q)not (~':) 1 1 1 2 2 3 4 5 5 5 6 6
100101110010b
q)differ 1 1 1 2 2 3 4 5 5 5 6 6
_</code></pre>
<p>Observe that the <code>1b</code> values in the result of <code>differ</code> are the start points for runs of identical items, so <code>where</code> yields their indices. Then use <code>cut</code> to split them out.</p>
<pre class="highlight"><code class="language-q">q)L:1 1 1 2 2 3 4 5 5 5 6 6
q)where differ L
0 3 5 6 7 10
q)(where differ L) cut L
1 1 1
2 2
,3
,4
5 5 5
6 6</code></pre>
<p>Now let‚Äôs do some q.</p>
<pre class="highlight"><code class="language-q">q)runs:(where differ L) cut L / store runs
q)ct:count each runs / store count of each run
q)runs where ct=max ct / find the runs of maximum length
1 1 1
5 5 5</code></pre>
<p>While some q coders don‚Äôt like the style, we point out that the above can be written in a single line of q using intra-line assignments.</p>
<pre class="highlight"><code class="language-q">q)runs where ct=max ct:count each runs:(where differ L) cut L
_</code></pre>
<p>Using comparison and the correct initial value, we can also use the above technique to find runs of increasing or decreasing values.</p>
<pre class="highlight"><code class="language-q">q)L:9 8 7 11 10 12 13
q)(where -0W&gt;':L) cut L
9 8 7
11 10
,12
,13
q)(where 0W&lt;':L) cut L
,9
,8
7 11
10 12 13</code></pre>
<p>This is the <em>raison d‚Äô√™tre</em> for integer infinities.</p>
<h2 id="68-general-application">6.8 General Application</h2>
<p>We have seen that the syntactic forms of list indexing, key lookup and function application can use either square brackets or prefix syntax.</p>
<pre class="highlight"><code class="language-q">q)L:(1 2;3 4 5; enlist 6)
q)L[0]
_
q)L 1
_
q)L[0 2]
_
q)L[1][2]
_
q)L[1; 2]
_
q)d:`a`b`c!(1 2; 3 4 5; enlist 6)
q)d[`a]
1 2
q)d `a
_
q)d[`a`c]
_
q)d[`a][1]
_
q)d[`a; 1]
_
q)f:{x*x}
q)f[0]
_
q)f 1
_
q)f[0 2]
_
q)g:{x+y}
q)g[1][2]
_
q)g[1;2]
)</code></pre>
<p>It turns out that both forms are syntactic sugar for how q actually treats application. You won't be surprised that application is actually a higher-order function that takes a function and value(s) and evaluates the function at the value(s). Thorough understanding of the general application is another test that separates the q pretenders from the contenders. The simpler forms of general application are usually written infix and are traditionally considered to be operators.</p>
<h3 id="681-operator">6.8.1 Operator <code>@</code></h3>
<p><span class="twemoji"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M448 360V24c0-13.3-10.7-24-24-24H96C43 0 0 43 0 96v320c0 53 43 96 96 96h328c13.3 0 24-10.7 24-24v-16c0-7.5-3.5-14.3-8.9-18.7-4.2-15.4-4.2-59.3 0-74.7 5.4-4.3 8.9-11.1 8.9-18.6zM128 134c0-3.3 2.7-6 6-6h212c3.3 0 6 2.7 6 6v20c0 3.3-2.7 6-6 6H134c-3.3 0-6-2.7-6-6v-20zm0 64c0-3.3 2.7-6 6-6h212c3.3 0 6 2.7 6 6v20c0 3.3-2.7 6-6 6H134c-3.3 0-6-2.7-6-6v-20zm253.4 250H96c-17.7 0-32-14.3-32-32 0-17.6 14.4-32 32-32h285.4c-1.9 17.1-1.9 46.9 0 64z"></path></svg></span>
<a href="https://code.kx.com/q/ref/apply/#apply-at">Apply At</a></p>
<p>Basic application comprises retrieving a list item by index, looking up a dictionary value by key, or evaluating a unary function. These are all instances of application of a univalent mathematical mapping. These are to be distinguished from indexing at depth, which is discussed in the next section.</p>
<p>The higher-order function <code>@</code> is the true form of basic application in q. It applies a unary mapping to an argument. As with all built-in functions, it can be written infix or prefix.</p>
<pre class="highlight"><code class="language-q">q)10 20 30 40@1
20
q)L:10 20 30 40
q)L@1
_
q)@[L; 1]
_
q)count@L
_
q)@[count; L]
_
q){x*x}@L
_
q)d:`a`b`c!10 20 30
q)d@`a
_
q)@[d;`b]
_</code></pre>
<p>Applying a nullary function with <code>@</code> is best done using the nil argument <code>::</code> but any argument suffices since it is ignored.</p>
<pre class="highlight"><code class="language-q">q)f:{6*7}
q)f[]
_
q)@[f; ::]
_
q)f@(::)
_
q)f@43
42</code></pre>
<p>For contrast with vector application in the next section, we collect previously discussed facts about ordinary application with a non-atom argument.</p>
<ul>
<li>For lists, dictionaries and atomic functions, <code>@</code> application yields an output that conforms to the shape of the input.</li>
<li>An aggregate function collapses the top level of nesting from the input.</li>
<li>A uniform function has output the same length as an input list.</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Apply At and tables</p>
<p>The function <code>@</code> also applies to tables and keyed tables since they are lists and dictionaries, respectively. Since a table is a list of records, using <code>@</code> retrieves records; for dictionaries and keyed tables it looks up keys:</p>
<pre class="highlight"><code>q)t:([]c1:1 2 3; c2:`a`b`c)
q)t@1
c1| 2
c2| `b
q)d:`a`b`c!10 20 30
q)d@`b
_
q)kt:([k:`a`b`c] v:1.1 2.2 3.3)
q)kt@`c
v| 3.3
</code></pre>
</div>
<h3 id="682-operator-apply">6.8.2 Operator Apply <code>.</code></h3>
<p><span class="twemoji"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M448 360V24c0-13.3-10.7-24-24-24H96C43 0 0 43 0 96v320c0 53 43 96 96 96h328c13.3 0 24-10.7 24-24v-16c0-7.5-3.5-14.3-8.9-18.7-4.2-15.4-4.2-59.3 0-74.7 5.4-4.3 8.9-11.1 8.9-18.6zM128 134c0-3.3 2.7-6 6-6h212c3.3 0 6 2.7 6 6v20c0 3.3-2.7 6-6 6H134c-3.3 0-6-2.7-6-6v-20zm0 64c0-3.3 2.7-6 6-6h212c3.3 0 6 2.7 6 6v20c0 3.3-2.7 6-6 6H134c-3.3 0-6-2.7-6-6v-20zm253.4 250H96c-17.7 0-32-14.3-32-32 0-17.6 14.4-32 32-32h285.4c-1.9 17.1-1.9 46.9 0 64z"></path></svg></span>
<a href="https://code.kx.com/q/ref/apply/">Apply</a></p>
<p>Indexing a list at depth, retrieving a nested value from a dictionary and evaluating a function with multiple parameters are all instances of applying a multi-variate mapping. The higher-order function <code>.</code> is the true form of multi-variate application in q. It applies a multi-variate mapping to multiple arguments and can be written infix or prefix.</p>
<div class="admonition note">
<p class="admonition-title">The right argument of <code>.</code> must be a list.</p>
</div>
<div class="admonition tip">
<p class="admonition-title">Separate operator <code>.</code> from its operands by whitespace if they are names or literal constants, as proximity to dots used in name spacing and in decimal numbers can lead to confusion.</p>
</div>
<p>Here we show various forms of indexing at depth rewritten with <code>.</code>.</p>
<pre class="highlight"><code class="language-q">q)L:(10 20 30; 40 50)
q)L[1][0]
40
q)L[1; 0]
_
q)L . 1 0
_
q)d:`a`b`c!(10 20 30; 40 50; enlist 60)
q)d[`b][0]
40
q)d[`b; 0]
_
q)d . (`b; 0)
_
q)g:{x+y}
q)g[1; 2]
_
q)g . 1 2
_</code></pre>
<p>Observe that operator Apply effectively allows us to apply a multi-variate function to a list of arguments instead of multiple individual arguments. Mathematically, this means that we are thinking of the function as defined on a vector instead of its individual components.</p>
<p>Dot application provides function application syntax that is conveniently independent of the valence of the function. This is useful for situations in which a function and its arguments are generated dynamically ‚Äì e.g., dynamic dispatch ‚Äì and the valence cannot be known in advance.</p>
<pre class="highlight"><code class="language-q">q)g:{x+y}
q)f:g
q)f . 1 2
_
q)h:{x+y+z}
q)f:h
q)f . 1 2 3
_</code></pre>
<p>You can apply a unary function with <code>.</code>. The insight is that a function of a scalar is inter-convertible with a function of a singleton vector. This is realized in q if you enlist the argument and use <code>.</code> for application.</p>
<pre class="highlight"><code class="language-q">q)f:{x*x}
q)f@5
_
q)f . enlist 5
_
q)f . enlist 1 2 3
1 4 9</code></pre>
<div class="admonition tip">
<p class="admonition-title">We conclude that <code>.</code> can apply a function of any valence and that <code>@</code> is actually unnecessary. Most q programmers do use <code>@</code> where applicable (pun intended).</p>
</div>
<p>To denote an elided index with <code>.</code> application, use the nil item.</p>
<pre class="highlight"><code class="language-q">q)m:(1 2 3;4 5 6)
q)m[0;]
_
q)m . (0; ::)
_
q)m . (::; 1)
_</code></pre>
<p>Evaluating a nullary function with <code>.</code> should properly use the enlisted nil item, although any enlisted value will suffice since it is ignored.</p>
<pre class="highlight"><code class="language-q">q)f:{6*7}
q)f . enlist (::)
_
q)f . enlist 42
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Advanced</p>
<p>Let‚Äôs climb the philosophical mountain. All data structures in q are composed from lists and dictionaries. Because q views both lists and dictionaries as mathematical mappings, retrieval from each is function application. Retrieval from un-nested lists and dictionaries is unary application with <code>@</code>. Retrieval from nested entities is multivariate application with <code>.</code>. In light of the previous observation that a unary function can be viewed as a function on a singleton vector, the function <code>.</code> provides a mechanism for retrieval from an arbitrary data structure. Gazing out from the summit, we see that all application is actually <code>.</code>.</p>
</div>
<p>Following are some examples of complex data structures and indexing at depth. See if you can predict them before entering at the console. (They make good q test questions)</p>
<pre class="highlight"><code class="language-q">q)L:10 20 30
q)L . enlist 1
_
q)m:(10 20 30; 100 200 300)
q)m . 0 1
_
q)ds:(`a`b`c!10 20 30; `x`y!100 200)
q)ds . (0; `b)
_
q)mix:(10 20 30; `a`b`c!(1; 2; (300 400)))
q)mix . (1; `c; 1)
_
q)dc:`c1`c2!(1 2 3; `a`b`c)
q)dc . (`c2; 1)
_
q)t:([]c1:1 2 3;c2:`a`b`c)
q)t . (1; `c2)
_</code></pre>
<p>And for keyed tables (see <a href="https://code.kx.com/q4m3/8_Tables/#84-primary-keys-and-keyed-tables">¬ß8.4</a>).</p>
<pre class="highlight"><code class="language-q">q)kt:([k:`a`b`c] v:1.1 2.2 3.3)
q)kt . `b`v
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Indexing at depth</p>
<p>Note that indexing at depth fails for accessing items inside a nested column.</p>
<pre><code class="language-q">
q)t:([] c1:`a`b`c; c2:(1 2; 100 200 400; enlist 1000))
q)t . (1; `c2)
100 200 400
q)t . (1; `c2; 1)
'rank
</code></pre>
(Until V3.5, that is. <em>Ed.</em>)
<pre><code class="language-q">
q)t . (1; `c2; 1)
200
</code></pre>
</div>
<h3 id="683-general-form-of-function-application">6.8.3 General Form of Function Application</h3>
<p><span class="twemoji"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M448 360V24c0-13.3-10.7-24-24-24H96C43 0 0 43 0 96v320c0 53 43 96 96 96h328c13.3 0 24-10.7 24-24v-16c0-7.5-3.5-14.3-8.9-18.7-4.2-15.4-4.2-59.3 0-74.7 5.4-4.3 8.9-11.1 8.9-18.6zM128 134c0-3.3 2.7-6 6-6h212c3.3 0 6 2.7 6 6v20c0 3.3-2.7 6-6 6H134c-3.3 0-6-2.7-6-6v-20zm0 64c0-3.3 2.7-6 6-6h212c3.3 0 6 2.7 6 6v20c0 3.3-2.7 6-6 6H134c-3.3 0-6-2.7-6-6v-20zm253.4 250H96c-17.7 0-32-14.3-32-32 0-17.6 14.4-32 32-32h285.4c-1.9 17.1-1.9 46.9 0 64z"></path></svg></span>
<a href="https://code.kx.com/q/ref/amend/">Amend, Amend At</a></p>
<p>The uses of <code>@</code> and <code>.</code> seen heretofore are actually special cases of more general higher-order functions of greater valence. Since these must be written prefix, we begin by writing some simple examples of function application from the previous section into prefix form. We use lists for simplicity but other data structures are also applicable.</p>
<pre class="highlight"><code class="language-q">q)L:10 20 30 40 50
q)@[L; 1]
20
q)@[L; 0 2]
10 30
q)m:(10 20 30; 100 200 300)
q).[m; 0 2]
30</code></pre>
<p>Each application above can be viewed as <strong>retrieval</strong> from the data structure along a sub-domain of its definition. From this perspective, the general forms to come will apply an <strong>arbitrary operation</strong> along a sub-domain. Otherwise said, they modify a substructure <strong>within</strong> the original structure. This is a very powerful technique that is not present in traditional programming languages.</p>
<h3 id="684-general-apply-with-unary-functions">6.8.4 General Apply (<code>@</code>) with Unary Functions</h3>
<p>We restate the <code>@</code> retrieval examples from the previous section.</p>
<pre class="highlight"><code class="language-q">q)L:10 20 30 40 50
q)@[L; 1]
20
q)@[L; 0 2]
10 30</code></pre>
<p>Now instead of simply retrieving along the sub-domain, we supply a function to be <strong>applied</strong> along the sub-domain.</p>
<pre class="highlight"><code class="language-q">q)@[L; 1; neg]
10 -20 30 40 50
q)@[L; 0 2; neg]
-10 20 -30 40 50</code></pre>
<p>Effectively we reach inside (a copy of) the list, apply <code>neg</code> along the specified sub-domain, and return the modified list. Contrast this with normal application on the sub-domain, which returns only the modified items.</p>
<pre class="highlight"><code class="language-q">q)neg L@0 1
-10 -20</code></pre>
<p>The significance of enhanced application is that it returns the entire modified list, which allows the result to be chained (i.e., composed) into further operations. If you don't think this is a big deal, think again.</p>
<p>The syntax for general application of a unary atomic function on a list is,</p>
<pre class="highlight"><code class="language-q">@[L;I;f]</code></pre>
<p>where <code>L</code> is the list and <code>I</code> is a collection of indices into <code>L</code>. Viewing <code>L</code> as a mapping, <code>I</code> is a top-level sub-domain of <code>L</code>. In fact, this form generalizes to any data structure viewed as a mapping. For example, given a dictionary and a list of keys,</p>
<pre class="highlight"><code class="language-q">q)d:`a`b`c!10 20 30
q)ks:`a`c
q)@[d; ks; neg]
a| -10
b| 20
c| -30</code></pre>
<div class="admonition note">
<p class="admonition-title">Compound data structures</p>
<p>For compound data structures such as nested lists, tables and keyed tables, application of <code>@</code> occurs along a sub-domain at the top level. We‚Äôll see how to reach down into data structure in the next section.</p>
<pre><code class="language-q">
q)m:(10 20 30; 100 200 300; 1000 2000 3000)
q)@[m; 0 2; neg]
-10 -20 -30
100 200 300
-1000 -2000 -3000
</code></pre>
</div>
<p>All the examples we have shown thus far work against copies of the input data structure. It is also possible to modify the original data structure in place. Although q does not have references, general application provides pass-by-name with the name being a symbol. We demonstrate with a simple example. In the first application, the original <code>L</code> is unchanged; in the second it is modified.</p>
<pre class="highlight"><code class="language-q">q)L:10 20 30 40
q)@[L; 0; neg]
-10 20 30 40
q)L
10 20 30 40
q)@[`L; 0 ; neg]
`L
q)L
-10 20 30 40</code></pre>
<p>Observe that the result of an application of pass-by-name is the passed symbolic name. This allows chaining of function applications that modify in place.</p>
<h3 id="685-general-apply-with-binary-functions">6.8.5 General Apply (<code>@</code>) with Binary Functions</h3>
<p>In the previous section we saw how to apply a <strong>unary</strong> function within the top level of a data structure. In the same way, we can apply a binary atomic function using <code>@</code> by providing the function together with an operand to apply along the sub-domain. Clearly the shape of the supplied operand must conform to the specified sub-domain. The exception is applying with an atom, in which case the latter is automatically extended to match the sub-domain.</p>
<pre class="highlight"><code class="language-q">q)L:10 20 30 40
q)@[L; 0 1; +; 100 200]
110 220 30 40
q)@[L; 0 1; +; 100]
_
q)d:`a`b`c!10 20 30
q)@[d; `a`b; +; 100 200]
a| 110
b| 220
c| 30
q)@[d; `a`b; +; 100]
_</code></pre>
<p>The general form of functional <code>@</code> for a binary atomic function is,</p>
<pre class="highlight"><code class="language-q">@[L; I; g; v]</code></pre>
<p>The notation is suggestive of lists, but <code>L</code> can be any data structure, viewed as a mapping. Here <code>I</code> is a top-level sub-domain of <code>L</code>; <code>g</code> is a binary function; and <code>v</code> is an atom or list conforming to <code>I</code>.</p>
<p>We contrast application along a sub-domain with normal application on the extracted substructure.</p>
<pre class="highlight"><code class="language-q">q)L:10 20 30 40
q)@[L; 0 1; +; 100 200]
110 220 30 40
q)100 200+L@0 1
110 220</code></pre>
<p>As in the unary case, application of <code>@</code> along a sub-domain of compound data structures (e.g., nested lists, tables and keyed tables) occurs at the top Level.</p>
<pre class="highlight"><code class="language-q">q)m:(10 20 30; 100 200 300; 1000 2000 3000)
q)@[m; 0 2; +; 1 2]
11 21 31
100 200 300
1002 2002 3002</code></pre>
<div class="admonition tip">
<p class="admonition-title">A useful case of binary application uses the assignment operator <code>:</code> to modify values along the sub-domain.</p>
<pre><code class="language-q">
q)L:10 20 30 40
q)@[L; 0 2; :; 42 43]
42 20 43 40
</code></pre>
</div>
<p>As in the unary case, to apply to the original in place, instead of to a copy, use pass-by-name.</p>
<pre class="highlight"><code class="language-q">q)L:10 20 30 40
q)@[`L; 0 2; :; 42 43]
`L
q)L
42 20 43 40</code></pre>
<h3 id="686-general-apply-for-unary-functions">6.8.6 General Apply (<code>.</code>) for Unary Functions</h3>
<p>We have seen that general <code>@</code> applies a function on a vector along the top level of a data structure. Now consider indexing at depth.</p>
<div class="admonition tip">
<p class="admonition-title">Although the construct is valid at any depth, there is a case to be made for not going beyond depth two in q (i.e., data normalization with tables).</p>
</div>
<p>We begin by restating simple examples of indexing at depth in prefix notation, using moderately nested lists and dictionaries for simplicity.</p>
<pre class="highlight"><code class="language-q">q)m:(10 20 30; 100 200 300)
q).[m; 0 1]
20
q)d:`a`b`c!(10 20 30; 40 50; enlist 60)
q).[d; (`a; 1)]
20</code></pre>
<p>In contrast with <code>@</code>, the vector argument of <code>.</code> reaches down into the data structure and picks out a single point in the domain. Here we target that point with a unary function.</p>
<pre class="highlight"><code class="language-q">q).[m; 0 1; neg]
10 -20 30
100 200 300
q).[d; (`a; 1); neg]
a| 10 -20 30
b| 40 50
c| ,60</code></pre>
<p>As before, these applications work against a copy of the data. To modify the original in place, <code>.</code> supports pass-by-name.</p>
<pre class="highlight"><code class="language-q">q).[m; 0 1; neg]
q)m
_
q).[`m; 0 1; neg]
`m
q)m
_
q).[d; (`a; 1); neg]
_
q)d
_
q).[`d; (`a; 1); neg]
`d
q)d
_</code></pre>
<p>We previously saw that to elide an index in <code>.</code> retrieval, we place the nil item <code>::</code> in that slot. The same holds for general application, where it means apply the function along <strong>all</strong> indices at that level.</p>
<pre class="highlight"><code class="language-q">q).[m; (0; ::); neg]
-10 -20 -30
100 200 300
q)d:`a`b`c!(100 200 300; 400 500; enlist 600)
q).[d; (`a; ::); neg]
a| -100 -200 -300
b| 400 500
c| ,600
q).[d; (::; 0); neg]
a| -100 200 300
b| -400 500
c| ,-600</code></pre>
<p>The general form of <code>.</code> for unary functions is,</p>
<pre class="highlight"><code class="language-q">.[L; I; f]</code></pre>
<p>Here <code>L</code> is a data structure, <code>I</code> is an in-depth sub-domain of <code>L</code> and <code>f</code> is a unary atomic function.</p>
<h3 id="687-general-apply-for-binary-functions">6.8.7 General Apply (<code>.</code>) for Binary Functions</h3>
<p>By now you can predict how general application <code>.</code> with a binary function works. The form of functional <code>.</code> for a binary function is,</p>
<pre class="highlight"><code class="language-q">.[L; I; g; v]</code></pre>
<p>Here <code>L</code> is a data structure, <code>I</code> is an in-depth sub-domain of <code>L</code>, <code>g</code> is a binary function and <code>v</code> is an atom (for <code>g</code> atomic) or a vector that conforms to <code>I</code>. To apply in place use pass-by-name.</p>
<pre class="highlight"><code class="language-q">q)m:(10 20 30; 100 200 300)
q).[m; 0 1; +; 1]
10 21 30
100 200 300
q).[m; (::; 1); +; 1 2]
10 21 30
_
q)m
_
q).[`m; (::; 1); +; 1]
_
q)m
_
q).[`m; (::; 1); :; 42]
`m
q)m
_
q)d:`a`b`c!(100 200 300; 400 500; enlist 600)
q).[d; (`a; 1); +; 1]
_
q).[d; (`a; ::); +; 1]
_
q).[d; (::; 0); +; 1]
_
q)d
_
q).[`d; (::; 0); :; 42]
_
q)d
_</code></pre>
                


                
              
              
                


              
            </article>
            
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))for(var set of document.querySelectorAll("[data-tabs]")){var labels=set.querySelectorAll(":scope > label");e:for(var tab of tabs)for(var label of labels)if(label.innerText.trim()===tab){var input=label.previousElementSibling;input.checked=!0;break e}}</script>

          </div>
        </div>
        
          
        
      
                </div>
            </section>
        
            <section class="chapter" id="chapter-12">
                <div class="chapter-header">
                    <h1 class="chapter-title">7. Transforming Data¬∂</h1>
                    <div class="chapter-meta">
                        <span>üìñ Source: <a href="https://code.kx.com/q4m3/7_Transforming_Data/">https://code.kx.com/q4m3/7_Transforming_Data/</a></span>
                        <span>üìù 4006 words</span>
                        
                    </div>
                </div>
                <div class="chapter-content">
                    
        <div class="md-main__inner md-grid">
          
            
              
              
            
            
              
              
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                
                <h1 id="7-transforming-data">7. Transforming Data</h1>
<h2 id="71-types">7.1 Types</h2>
<p>Casting is a way to convert a value of one type to a compatible type. Sometimes the conversion is exact; other times information is lost. Enumeration and parsing in q also fit into the cast pattern.</p>
<h3 id="711-basic-datatypes">7.1.1 Basic DataTypes</h3>
<p>A type can be specified in three equivalent ways: a char, a short and a symbol. For convenience, we repeat the data types table from Chapter 1.</p>
<table>
<thead>
<tr>
<th>type</th>
<th>type symbol</th>
<th>type char</th>
<th>type num</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>`boolean</td>
<td>B</td>
<td>1h</td>
</tr>
<tr>
<td>guid</td>
<td>`guid</td>
<td>G</td>
<td>2h</td>
</tr>
<tr>
<td>byte</td>
<td>`byte</td>
<td>X</td>
<td>4h</td>
</tr>
<tr>
<td>short</td>
<td>`short</td>
<td>H</td>
<td>5h</td>
</tr>
<tr>
<td>int</td>
<td>`int</td>
<td>I</td>
<td>6h</td>
</tr>
<tr>
<td>long</td>
<td>`long</td>
<td>J</td>
<td>7h</td>
</tr>
<tr>
<td>real</td>
<td>`real</td>
<td>E</td>
<td>8h</td>
</tr>
<tr>
<td>float</td>
<td>`float</td>
<td>F</td>
<td>9h</td>
</tr>
<tr>
<td>char</td>
<td>`char</td>
<td>C</td>
<td>10h</td>
</tr>
<tr>
<td>symbol</td>
<td>`</td>
<td>S</td>
<td>11h</td>
</tr>
<tr>
<td>timestamp</td>
<td>`timestamp</td>
<td>P</td>
<td>12h</td>
</tr>
<tr>
<td>month</td>
<td>`month</td>
<td>M</td>
<td>13h</td>
</tr>
<tr>
<td>date</td>
<td>`date</td>
<td>D</td>
<td>14h</td>
</tr>
<tr>
<td>datetime</td>
<td>`datetime</td>
<td>Z</td>
<td>15h</td>
</tr>
<tr>
<td>timespan</td>
<td>`timespan</td>
<td>N</td>
<td>16h</td>
</tr>
<tr>
<td>minute</td>
<td>`minute</td>
<td>U</td>
<td>17h</td>
</tr>
<tr>
<td>second</td>
<td>`second</td>
<td>V</td>
<td>18h</td>
</tr>
<tr>
<td>time</td>
<td>`time</td>
<td>T</td>
<td>19h</td>
</tr>
</tbody>
</table>
<h3 id="712-the-type-operator">7.1.2 The <code>type</code> Operator</h3>
<p>The non-atomic unary function (<code>type</code>) can be applied to any entity in q to return its data type expressed as a short. It is a "feature" of q that the data type of an atom is negative whereas the type of a simple list is positive.</p>
<pre class="highlight"><code class="language-q">q)type 42
-7h
q)type 10 20 30
7h
q)type 98.6
-9h
q)type 1.1 2.2 3.3
_
q)type `a
-11h
q)type `a`b`c
_
q)type "z"
-10h
q)type "abc"
_</code></pre>
<p>Observe that infinities and nulls have their respective types.</p>
<pre class="highlight"><code class="language-q">q)type 0W
-7h
q)type 0N
_
q)type -0w
-9h
q)type 0n
_
q)type `
-11h</code></pre>
<p>The type of any general list is <code>0h</code>.</p>
<pre class="highlight"><code class="language-q">q)type (42h; 42i; 42j)
0h
q)type (1 2 3; 10 20 30)
_
q)type ()
_</code></pre>
<p>The type of any dictionary, including a keyed table, is <code>99h</code>.</p>
<pre class="highlight"><code class="language-q">q)type (`a`b`c!10 20 30)
99h
q)type ([k:`a`b`c] v:10 20 30)
_</code></pre>
<p>The type of any table is <code>98h</code>.</p>
<pre class="highlight"><code class="language-q">q)type ([] c1:`a`b`c; c2:10 20 30)
98h</code></pre>
<h3 id="713-type-of-a-variable">7.1.3 Type of a Variable</h3>
<p>Since q is a dynamically typed language, a variable has the type of the value currently assigned to it. Unlike statically typed languages, there is no predeclaration of type.</p>
<pre class="highlight"><code class="language-q">q)a:42
q)type a
-7h
q)a:"abc"
q)type a
10h</code></pre>
<p>In more detail, the variable <code>a</code> above is an association between the name <code>`a</code> and its assigned value. Since this is the first time that the variable is assigned, the q interpreter creates an entry for the key <code>`a</code> in its dictionary of global variables and associates it with the value <code>42</code>.</p>
<pre class="highlight"><code class="language-q">q)get `.
a| 42</code></pre>
<p>On the subsequent assignment, there is already an entry for the key <code>`a</code> in the dictionary, so the value <code>"abc"</code> is upserted.</p>
<pre class="highlight"><code class="language-q+">q)get `.
a| "abc"</code></pre>
<p>The type of a variable <strong>is</strong> the type of the value associated with the variable's name.</p>
<p>Global variables are stored in ordinary q dictionaries with special names. For example, the symbol <code>`.</code> is the name of the default global dictionary. Start a fresh q session and observe the life of this dictionary using <code>value</code>.</p>
<pre class="highlight"><code class="language-q">q)value `.
q)a:42
q)value `.
a| 42
q)f:{x*x}
q)value `.
a| 42
f| {x*x}
..</code></pre>
<div class="admonition note">
<p class="admonition-title">Since q internally uses the same dictionary structures available to us, it has been said (crassly) that q eats its own dog food.</p>
</div>
<h2 id="72-cast">7.2 Cast</h2>
<p>Casting renders an underlying value of one type into another compatible type. For example, a short integer has a natural interpretation as a long integer. In the <a href="https://code.kx.com/q4m3/0_Overview/#02-mathematics-refresher">Mathematics Refresher</a> we discussed the implicit identifications of naturals with their rational counterparts and rationals with their repeating decimal real counterparts. These identifications are actually examples of casting, since the numeric values representing the different types are the same in essence.</p>
<p>Since q is dynamically typed, casting occurs at run-time using the <a href="https://code.kx.com/q/ref/cast/" title="Cast">binary operator <code>$</code></a>, which is atomic in both operands. The right operand is the source value and the left operand specifies the target type. There are three ways to specify the target type, indicated by the first three columns of the type table at the beginning of this chapter.</p>
<ul>
<li>A (positive) numeric short type value</li>
<li>A char type value</li>
<li>A type name symbol</li>
</ul>
<h3 id="721-casts-that-widen">7.2.1 Casts that Widen</h3>
<p>In these examples, no information is lost in the cast, as the target type is wider than the source type. Here are examples using the short type specification in the target.</p>
<pre class="highlight"><code class="language-q">q)7h$42i / int to long
42
q)6h$42 / long to int
42i
q)9h$42 / long to float
42f</code></pre>
<p>It is arguably more readable to use the type char. Here are the same examples recast (ouch) to use the type char.</p>
<pre class="highlight"><code class="language-q">q)"j"$42i
42
q)"i"$42
42i
q)"f"$42
42f</code></pre>
<p>It is arguably most readable to use the symbolic type name.</p>
<pre class="highlight"><code class="language-q">q)`int$42
_
q)`long$42i
_
q)`float$42
_</code></pre>
<h3 id="722-casts-across-disparate-types">7.2.2 Casts across Disparate Types</h3>
<p>It may come as a surprise that q allows casting between superficially disparate types. When the underlying values are the same, the types are essentially just different representation formats, so why not allow a cast? We use the symbolic names in the following examples; the other formats work equally well.</p>
<p>The underlying value of a char is its position in the ASCII collation sequence, so we can cast char to and from integers, provided the integer is less than 256.</p>
<pre class="highlight"><code class="language-q">q)`char$42
"*"
q)`long$"\n"
_</code></pre>
<p>The underlying value of a date is its count of days from the millennium, so we can cast to and from an<code>int</code>.</p>
<pre class="highlight"><code class="language-q">q)`date$0
2000.01.01
q)`int$2001.01.01 / millennium occurred on leap year
_</code></pre>
<p>The underlying value of a timespan is its count of nanoseconds from midnight, so we can cast it to and from long.</p>
<pre class="highlight"><code class="language-q">q)`long$12:00:00.0000000000
43200000000000
q)`timespan$0
_</code></pre>
<h3 id="723-casts-that-narrow">7.2.3 Casts that Narrow</h3>
<p>Some casts lose information. This includes the usual suspects of float to integer and wider integers to narrower ones.</p>
<pre class="highlight"><code class="language-q">q)`long$12.345
12
q)`short$123456789
32767h</code></pre>
<p>Cast any numeric to a boolean using the C philosophy that zero is <code>0b</code> and anything else is <code>1b</code>.</p>
<pre class="highlight"><code class="language-q">q)`boolean$0
0b
q)`boolean$0.0
0b
q)`boolean$123
1b
q)`boolean$-12.345
1b</code></pre>
<p>We can also extract constituents from complex types.</p>
<pre class="highlight"><code class="language-q">q)`date$2015.01.02D10:20:30.123456789
2015.01.02
q)`year$2015.01.02
2015i
q)`month$2015.01.02
2015.01m
q)`mm$2015.01.02
1i
q)`dd$2015.01.02
2i
q)`hh$10:20:30.123456789
10i
q)`minute$10:20:30.123456789
10:20
q)`uu$10:20:30.123456789
20i
q)`second$10:20:30.123456789
10:20:30
q)`ss$10:20:30.123456789
30i</code></pre>
<div class="admonition tip">
<p class="admonition-title">This is to be preferred over dot notation since the latter does not work inside functions.</p>
</div>
<h3 id="724-casting-integral-infinities">7.2.4 Casting Integral Infinities</h3>
<p>When integral infinities are cast to integers of wider type, they <strong>are</strong> their underlying bit patterns, reinterpreted. Since these bit patterns are legitimate values for the wider type, the cast results in a finite value.</p>
<pre class="highlight"><code class="language-q">q)`int$0Wh
32767i
q)`int$-0Wh
-32767i
q)`long$0Wi
2147483647
q)`long$-0Wi
-2147483647</code></pre>
<h3 id="725-coercing-types">7.2.5 Coercing Types</h3>
<p>Casting can be used to coerce type-safe assignment. Recall that assignment into a simple list must strictly match the type.</p>
<pre class="highlight"><code class="language-q">q)L:10 20 30 40
q)L[1]:42h
'type
q)L,:43h
'type</code></pre>
<p>This situation can arise when the list and the assignment value are created dynamically. Coerce the type by casting it to that of the target, provided of course that the cast is legitimate.</p>
<pre class="highlight"><code class="language-q">q)L[1]:(type L)$42h
q)L,:(type L)$43h
q)L
_</code></pre>
<div class="admonition note">
<p class="admonition-title">The type of a simple list is positive to make this construct work.</p>
</div>
<h3 id="726-cast-is-atomic">7.2.6 Cast is Atomic</h3>
<p>Cast is atomic in the right operand.</p>
<pre class="highlight"><code class="language-q">q)"i"$10 20 30
10 20 30i
q)`float$(42j; 42i; 42j)
42 42 42f</code></pre>
<p>Cast is atomic in the left operand.</p>
<pre class="highlight"><code class="language-q">q)`short`int`long$42
42h
42i
42
q)"ijf"$98.6
99i
99
98.6</code></pre>
<p>Cast is atomic in both operands simultaneously.</p>
<pre class="highlight"><code class="language-q">q)"ijf"$10 20 30
10i
20
30f</code></pre>
<h2 id="73-data-to-and-from-text">7.3 Data to and from Text</h2>
<p>Recall that a q string is a simple list of char. All grown-up programming languages have a mechanism for translating literal text into values and vice versa. It isn‚Äôt strictly correct to say that converting a value to a string and parsing a string are casts since the value is only implicit in the text, but the operations are closely related and use the same operator in q.</p>
<h3 id="731-data-to-strings">7.3.1 Data to Strings</h3>
<p>The function <a href="https://code.kx.com/q/ref/string/"><code>string</code></a> can be applied to any q entity to produce a text representation suitable for console display or storage in a file. Here are the key features of <code>string</code>.</p>
<ul>
<li>The result is always a list of char, never a single char. Thus you will see singleton char lists from single digits.</li>
<li>The result contains no q type indicators or other decorations. In general, the result is the most compact representation of the input, which may not actually be convertible (i.e., parsed) back to the original value.</li>
<li>Applying <code>string</code> to an actual string (i.e., list of char) probably will not give you what you want.</li>
</ul>
<p>Following are some examples.
</p><pre class="highlight"><code class="language-q">q)string 42
"42"
q)string 4
,"4"
q)string 42i
"42"
q)a:2.0
q)string a
,"2"
q)f:{x*x}
q)string f
"{x*x}"</code></pre>
<p>The <code>string</code> function is clearly not atomic ‚Äì for example, it takes the atom <code>42</code> to the list <code>"42"</code>. However, it is pseudo-atomic, in that it recurses into its argument and applies to the individual atoms. As such, the result conforms to the input, which explains its behavior on strings.</p>
<pre class="highlight"><code class="language-q">q)string 1 2 3
,"1"
,"2"
,"3"
q)string "string"
,"s"
,"t"
,"r"
,"i"
,"n"
,"g"
q)string (1 2 3; 10 20 30)
,"1" ,"2" ,"3"
"10" "20" "30"</code></pre>
<div class="admonition tip">
<p class="admonition-title">Use <code>string</code> to convert a list (or column) of symbols to strings.</p>
<pre><code class="language-q">
q)string `Life`the`Universe`and`Everything
_
</code></pre>
</div>
<h3 id="732-creating-symbols-from-strings">7.3.2 Creating Symbols from Strings</h3>
<p>Casting from a string (i.e., a list of char) to a symbol is a foolproof way to create symbols. It is the <strong>only</strong> way to create symbols with embedded blanks or other special characters that cannot be entered into a literal symbol. To cast a char or a string to a symbol, use <code>`$</code>.</p>
<pre class="highlight"><code class="language-q">q)`$"abc"
`abc
q
q)`$"Hello World"
`_</code></pre>
<div class="admonition warning">
<p class="admonition-title">Do not use <code>`symbol$</code> for this as it generates an error. This is a common qbie mistake.</p>
</div>
<p>You can include any characters in a symbol this way but you may need to escape them into the string.</p>
<pre class="highlight"><code class="language-q">q)`$"Zaphod \"Z\""
`Zaphod "Z"
q)`$"Zaphod \n"
`Zaphod</code></pre>
<div class="admonition note">
<p class="admonition-title">The source string is left- and right-trimmed during the cast</p>
<p>The author knows no workaround to force leading or trailing blanks into a symbol. Why would you want them there, anyway?
</p><pre><code class="language-q">
q)string `$" abc "
"abc"
</code></pre>
</div>
<p>The unary <code>`$</code> is atomic and will thus convert an entire list (or column) of strings to symbols.</p>
<pre class="highlight"><code class="language-q">q)`$("Life";"the";"Universe";"and";"Everything")
`Life`the`Universe`and`Everything</code></pre>
<h3 id="733-parsing-data-from-strings">7.3.3 Parsing Data from Strings</h3>
<p>The <code>$</code> operator is <a href="https://code.kx.com/q/ref/tok/" title="Tok">overloaded</a> to parse strings into data of any type exactly as the q interpreter does. This overload is invoked by using an <strong>uppercase</strong> type char as the target left operand and a string in the right operand. If the specified parse cannot be performed, a null of the target type is returned ‚Äì i.e., missing or bad data ‚Äì instead of an exception.</p>
<pre class="highlight"><code class="language-q">q)"J"$"42"
42
q)"F"$"42"
42f
q)"F"$"42.0"
42f
q)"I"$"42.0"
0Ni
q)"I"$" "
0Ni</code></pre>
<p>Date parsing is flexible with respect to the format of the date..</p>
<pre class="highlight"><code class="language-q">q)"D"$"12.31.2014"
2014.12.31
q)"D"$"12-31-2014"
_
q)"D"$"12/31/2014"
_
q)"D"$"12/1/2014"
_
q)"D"$"2014/12/31"
_</code></pre>
<p>To create a function from a string, use the built-in <code>value</code>, which <strong>is</strong> the q interpreter or <code>parse</code>, which is the parse step of the interpreter.</p>
<pre class="highlight"><code class="language-q">q)value "{x*x}"
{x*x}
q)parse "{x*x}"
_</code></pre>
<h2 id="74-creating-typed-empty-lists">7.4 Creating Typed Empty Lists</h2>
<p>The general empty list has type 0 since it has no items and therefore affords no canonical way to determine a type.</p>
<pre class="highlight"><code class="language-q">q)type ()
0h</code></pre>
<p>An issue arises when appending an item in place to a general empty list, Namely, if that item is an atom, the resulting singleton list is now a simple list of the type of the atom.</p>
<pre class="highlight"><code class="language-q">q)L:()
q)type L
0h
q)L,:42
q)type L
7h</code></pre>
<p>Should this list be a column in a table, this can be problematic. For example, suppose you intend the column to be a list of floats but the first row appended to the table happens to have a long in the field for this column. Then the errant field is accepted, the type of the column is set to long, and all subsequent appends of float raise a <code>'type</code> error.</p>
<pre class="highlight"><code class="language-q">q)c1:()
q)c1,:42
q)c1,:98.6
'type</code></pre>
<p>To avoid this, cast the empty list using the name of the desired type, which makes it an empty simple list of that type. Now only atoms of the specified type can be appended in place.</p>
<pre class="highlight"><code class="language-q">q)c1:`float$()
q)c1,:42
'type
q)c1:98.6
q)c1
_</code></pre>
<p>Notice that an operation that yields a simple list retains the type on an empty result.</p>
<pre class="highlight"><code class="language-q">q)0#10 20 30
_</code></pre>
<p>This yields a succinct idiom to create typed empty lists.</p>
<pre class="highlight"><code class="language-q">q)0#0
`long$()
q)0#0.0
_
q)0#`
_</code></pre>
<div class="admonition note">
<p class="admonition-title">There is no way in q to type nested empty lists</p>
</div>
<h2 id="75-enumerations">7.5 Enumerations</h2>
<p>We have seen that the binary <a href="https://code.kx.com/q/ref/cast/">Cast</a> operator <code>$</code> transforms its right operand into a conforming entity of the type specified by the left operand. In the basic Cast form, the left operand can be a char type abbreviation, a type short, or a symbol type name. In this section, casting is extended to user-defined target domains, providing a functional version of enumerated types.</p>
<h3 id="751-traditional-enumerations">7.5.1 Traditional Enumerations</h3>
<p>To begin, recall that in traditional languages, an enumerated type is a way of associating a series of names with a corresponding set of integral values. Often the sequence of numbers is consecutive and begins with 0. The association is usually given a name and represents a new type.</p>
<p>A traditional enumerated type serves multiple purposes.</p>
<ul>
<li>It allows a descriptive name to be used instead of an arbitrary number ‚Äì e.g., 'red', 'green', 'blue' instead of 0, 1 and 2.</li>
<li>It enables type checking to ensure that only permissible values are supplied ‚Äì e.g., choosing a color name from a list instead of remembering its number is less prone to error.</li>
<li>It provides namespacing, meaning the same name can be reused in different domains without fear of confusion ‚Äì e.g., color.blue and note.blue (the flatted fifth).</li>
</ul>
<p>There is also a subtler, more powerful use of enumerations: normalizing data.</p>
<h3 id="752-data-normalization">7.5.2 Data Normalization</h3>
<p>Broadly speaking, data normalization seeks to eliminate duplication, retaining only the minimum required data. In the archetypal example, suppose you know that you will have a list of text entries taken from a fixed and reasonably short set of values ‚Äì e.g., stock exchange ticker symbols. Storing a long list of such strings verbatim presents two problems.</p>
<ul>
<li>Values of variable length complicate storage management and make retrieval inefficient.</li>
<li>There is potentially much duplication of data arising from repeated values. This is hard to keep in sync when values change.</li>
</ul>
<p>Let‚Äôs see how an enumeration solves both problems. The key ingredients are a (presumably repetitive) list <code>v</code> of symbols drawn from a unique list of symbols <code>u</code>. As in the case of ticker symbols, it may be that we know the list <code>u</code> in advance.</p>
<pre class="highlight"><code class="language-q">q)u:`g`aapl`msft`ibm
q)v:1000000?u
q)v
`g`g`msft`aapl`msft`aapl`msft`ibm`msft`aapl`g`ibm`aapl`msft`msft`aapl`g..</code></pre>
<p>Or it may be that we are given <code>v</code> and need to determine <code>u</code>.</p>
<pre class="highlight"><code class="language-q">q)v
`jha`jha`fna`fed`fna`fna`jha`jha`jgc`pkh`pkh`pkh`fna`fed`jha`cpi`pkh`pkh`igb`
q)u:distinct v
q)u
`jha`fna`fed`jgc`pkh`cpi`igb`hln`mjh`ooj</code></pre>
<p>In any case, we have a list of symbols <code>v</code> drawn from a unique list <code>u</code>.</p>
<p>Consider a new list <code>k</code> that represents the position in <code>u</code> of each item of <code>v</code>. This can be generated by our old friend the <a href="https://code.kx.com/q/ref/find/">Find</a> operator <code>?</code>.</p>
<pre class="highlight"><code class="language-q">q)u:`g`aapl`msft`ibm
q)v:1000000?u
q)k:u?v
q)k
2 1 1 3 3 1 0 0 0 3 0 2 2 1 2 3 1 0 1 1 2 1 2 0 2 1 1 0 1 1 3 0..</code></pre>
<p>The key observation is that <code>u</code> and <code>k</code> together carry precisely the same information as <code>v</code>; indeed, they can be used to reconstitute it.</p>
<pre class="highlight"><code class="language-q">q)u[k]
`msft`aapl`aapl`ibm`ibm`aapl`g`g`g`ibm`g`msft`msft`aapl`msft`ibm`aapl..
q)v~u[k]
1b</code></pre>
<p>After a bit of Zen, you will recognize that <code>u</code> and <code>k</code> exactly constitute a traditional enumeration discussed above. Indeed, <code>u</code> is the list of names, while the associated values are (implicitly) the indices of the items in <code>u</code>. Every symbol in <code>v</code> can be replaced by the corresponding index in <code>k</code> ‚Äì exactly what a traditional compiler does for an enumeration.</p>
<p>Why would we want to do this trade? Easy-peasy-lemon-squeezy: speed and compactness. First, <code>v</code> is a list of variable length text, which is time-consuming to search, whereas <code>k</code> is a uniform list of integers, which is very fast to traverse. Moreover, <code>u</code> and <code>k</code> normalize the data of <code>v</code>. In general, <code>v</code> will have many repetitions of each symbol, but <code>u</code> stores each symbol once. Reading and writing the index list <code>k</code> from/to disk is a block operation that will be very fast.</p>
<div class="admonition advanced">
<p class="admonition-title">Advanced</p>
<p>Extra credit for recognizing that in terms of maps, <code>v</code> is the composite map <code>u¬∑k</code>. For all you category theorists, we have factored the map of the non-unique list <code>v</code> through the unique list <code>u</code> via the index map <code>k</code>. Mathematically,
 <code>v = u¬∑k</code></p>
</div>
<p>Let‚Äôs examine the storage requirements for a list of symbols in more detail. Say that the count of <code>u</code> is <em>a</em> and the maximum width of the text inside the symbols in <code>u</code> is <em>b</em>. For a list <code>v</code> of variable count <em>x</em>, the amount of storage required is potentially</p>
<p><em>b</em>*<em>x</em></p>
<p>For the indexed form, the storage is known to be,</p>
<p><em>a</em>*<em>b</em>+4*<em>x</em></p>
<p>which represents the fixed amount of storage for <code>u</code> plus the variable amount of storage for the simple integer list <code>k</code>. If <em>a</em> is small and <em>b</em> is even moderately large, the factorization is significantly smaller.</p>
<p>This can be seen by comparing the sizes of <code>v</code>, <code>u</code> and <code>k</code> in a slightly modified version of our example.</p>
<pre class="highlight"><code class="language-q">v:`ccccccc`bbbbbbb`aaaaaaa`ccccccc`ccccccc`bbbbbbb
u:distinct v
u
`ccccccc`bbbbbbb`aaaaaaa
k:u?v
k
0 1 2 0 0 1</code></pre>
<p>Now imagine <code>v</code> and <code>k</code> to be much longer.</p>
<h3 id="753-enumerating-symbols">7.5.3 Enumerating Symbols</h3>
<p>The process of converting a list of symbols to the equivalent list of indices described in the previous section is called <em>enumeration</em> in q. It uses (yet another <a href="https://code.kx.com/q/ref/enumerate/" title="Enumerate">overload</a> of) <code>$</code> with the name of the variable holding the unique symbols as the left operand and a list of symbols drawn from that domain on the right.</p>
<p>Under the covers, <code>$</code> does the indexing operation in the previous section and then replaces each symbol with its index. Fortunately, you don‚Äôt have to see how the sausage is made ‚Äì i.e., q hides all this from you and displays the enumerated symbols in their reconstituted form with the name of the unique domain as an annotation. Continuing the example of the previous section:</p>
<pre class="highlight"><code class="language-q">q)`u$v
`u$`msft`aapl`aapl`ibm`ibm`aapl`g`g`g`ibm`g`msft`msft`aapl`msft..</code></pre>
<p>You can recover the underlying integer values (i.e., <code>k</code> above) by casting to an integer.</p>
<pre class="highlight"><code class="language-q">q)ev:`u$v
q)`int$ev
2 1 1 3 3 1 0 0 0 3 0 2 2 1 2 3 1 0 1 1 2 1 2 0 2 1 1 0 1 1 3 ..</code></pre>
<p>Let‚Äôs summarize. The basic form of an enumerated symbol is,</p>
<pre class="highlight"><code class="language-q">`u$v</code></pre>
<p>where <code>u</code> is a simple list of unique symbols and <code>v</code> is either an atom appearing in <code>u</code> or a (possibly nested) list of such. We call <code>u</code> the <em>domain</em> of the enumeration and the projection <code>`u$</code> is <em>enumeration over <code>u</code></em>. Under the covers, applying the enumeration <code>`u$</code> to a vector <code>v</code> produces the index list <code>k</code> as above.</p>
<details class="warning">
<summary>For this style of enumeration, all potential values must be in the list <code>u</code>; otherwise you will get a <code>'cast</code> error when trying to enumerate.</summary>
<pre><code class="language-q">
q)u:`a`b`c
q)`u$`d
'cast
</code></pre>
</details>
<p>We shall see in <a href="#757-dynamically-appending-to-an-enumeration-domain">¬ß7.5.7</a> an alternate approach when the full extent of <code>u</code> is not known in advance.</p>
<p>When working with tables in kdb+, by convention all symbol columns in all tables are enumerated over a common domain <em>sym</em>. You will hear this referred to as the <em>sym list</em> or the <em>sym file</em>, depending on where it resides.</p>
<div class="admonition note">
<p class="admonition-title">Although integers are 64-bit in q3+, for reasons known to the q gods, enumerations are 32-bit.</p>
</div>
<h3 id="754-using-enumerated-symbols">7.5.4 Using Enumerated Symbols</h3>
<p>We continue with the example of the previous section, renamed to use the standard sym domain.</p>
<pre class="highlight"><code class="language-q">q)sym:`g`aapl`msft`ibm
q)v:1000000?sym
q)ev:`sym$v</code></pre>
<p>The enumerated <code>ev</code> can be substituted for the original <code>v</code> in nearly all situations.</p>
<pre class="highlight"><code class="language-q">q)v[3]
`aapl
q)ev[3]
`u$`aapl
q)v[3]:`ibm
q)ev[3]:`ibm
q)v=`ibm
000100010010011101000010010100000000100100000001000000001100001001011..
q)ev=`ibm
q)where v=`aapl
4 5 19 20 21 31 33 34 41 42 43 49 58 59 61 74 81 83 90 94 95 98 114..
q)where ev=`aapl
4 5 19 20 21 31 33 34 41 42 43 49 58 59 61 74 81 83 90 94 95 98 114..
000100010010011101000010010100000000100100000001000000001100001001011..
q)v?`aapl
4
q)ev?`aapl
4
q)v in `ibm`aapl
000111010010011101011110010100010110100101110001010000001111011001011..
q)ev in `ibm`aapl
000111010010011101011110010100010110100101110001010000001111011001011..</code></pre>
<p>While the enumerated version is item-wise equal to the original, the entities are not identical.</p>
<pre class="highlight"><code class="language-q">q)all v=ev
1b
q)v~ev
0b</code></pre>
<p>This is because the types matter with <code>~</code>.</p>
<h3 id="755-type-of-enumerations">7.5.5 Type of Enumerations</h3>
<p>Each enumeration is assigned a new numeric data type, beginning with <code>20h</code>. Starting with q version 3.2, the type <code>20h</code> is reserved for the conventional enumeration domain sym, whether you use it or not (you should). The types of other enumerations you create will begin with <code>21h</code> and proceed sequentially. The convention of negative type for atoms and positive type for simple lists still holds. In a fresh q session we see the following.</p>
<pre class="highlight"><code class="language-q">q)sym1:`g`aapl`msft`ibm
q)type `sym1$1000000?sym1
21h
q)sym2:`a`b`c
q)type `sym2$`c
-22h</code></pre>
<div class="admonition warning">
<p class="admonition-title">The above was true in kdb+ V3.2. In later versions the type remains <code>20h</code>.</p>
</div>
<p>In contrast, the sym domain has type <code>20h</code> even if created after another enumeration. Continuing in the previous session,</p>
<pre class="highlight"><code class="language-q">q)sym:`b`c`a
q)type `sym$100?sym
20h</code></pre>
<p>Enumerations with different domains are distinct, even when all the constituents are the same.</p>
<pre class="highlight"><code class="language-q">q)sym1:`c`b`a
q)sym2:`c`b`a
q)ev1:`sym1$`a`b`a`c`a
q)ev2:`sym2$`a`b`a`c`a
q)ev1=ev2
11111b
q)ev1~ev2
0b</code></pre>
<h3 id="756-updating-an-enumerated-list">7.5.6 Updating an Enumerated List</h3>
<p>The normalization provided by an enumeration reduces updating all occurrences of a given value to a single operation. This can have significant performance implications for large lists with many repetitions. Continuing with our example above, suppose the list <code>u</code> contains the items in a stock index and we wish to change one of the constituents. A single update to <code>u</code> suffices.</p>
<pre class="highlight"><code class="language-q">q)sym:`g`aapl`msft`ibm
q)ev:`sym$`g`g`msft`ibm`aapl`aapl`msft`ibm`msft`g`ibm`g..
q)sym[0]:`twit
q)sym
`twit`aapl`msft`ibm
q)ev
`sym$`twit`twit`msft`ibm`aapl`aapl`msft`ibm`msft`twit`ibm`twit..</code></pre>
<p>In contrast, to make the equivalent update to <code>v</code> requires changing <strong>every</strong> occurrence.</p>
<pre class="highlight"><code class="language-q">q)v
`g`g`msft`ibm`aapl`aapl`msft`ibm`msft`g`ibm`g‚Ä¶
q)@[v; where v=`g; :; `twit]
_</code></pre>
<details class="warning">
<summary>Be extremely cautious about modifying the sym list manually. (Better not to do it at all.)</summary>
<p>Should you corrupt the sym list, your entire database will be scrambled! Make a persistent copy/backup before modifying the list, else update your CV after.</p>
</details>
<h3 id="757-dynamically-appending-to-an-enumeration-domain">7.5.7 Dynamically Appending to an Enumeration Domain</h3>
<p>One situation in which an enumeration is more complicated than working with the denormalized data is when you want to add a new value. Continuing with the example above, appending a new item to an ordinary list of symbols is a single operation. We saw in <a href="#754-using-enumerated-symbols">¬ß7.5.4</a> this is not the case when the new value is not in the enumeration domain.</p>
<pre class="highlight"><code class="language-q">q)sym:`g`aapl`msft`ibm
q)v:1000000?sym
q)ev:`sym$v
q)v,:`twtr
q)ev,:`twtr
'cast</code></pre>
<p>The new value <strong>must</strong> first be added to the unique list.</p>
<pre class="highlight"><code class="language-q">q)sym,:`twtr
q)ev,:`twtr</code></pre>
<p>In practice, to use <code>$</code> with dynamically generated values, you must test to see if the value you intend to append is already in the enumeration domain and, if not, append it there first. Fortunately, q has anticipated this situation.</p>
<p>If you cannot know the full extent of the enumeration domain in advance, you can use (yet another <a href="https://code.kx.com/q/ref/enum-extend" title="Enum Extend">overload</a> of) <code>?</code> to create the domain on the fly. The syntax of <code>?</code> is the same as the enumeration overload of <code>$</code> ‚Äì i.e., the <strong>name</strong> of a (unique) list of symbols as left operand and a source symbol or list of symbols as right operand.</p>
<p>This application of <code>?</code> has the side effect of first checking to see if the source symbols are in the domain named by the left operand, and appends any that aren't. In any case, it returns the enumerated version of the source just like <code>$</code>.</p>
<p>You can build the enumeration domain from scratch.</p>
<pre class="highlight"><code class="language-q">q)sym:()
q)`sym$`g
'cast
q)`sym?`g
`sym$`g
q)sym
,`g
q)`sym?`ibm`aapl
`sym$`ibm`aapl
q)sym
`g`ibm`aapl
q)`sym?`g`msft
`sym$`g`msft
q)sym
`g`ibm`aapl`msft</code></pre>
<p>Our previous example now works, with <code>?</code> in place of <code>$</code>.</p>
<pre class="highlight"><code class="language-q">q)ev,:`sym?`twtr</code></pre>
<h3 id="758-resolving-an-enumeration">7.5.8 Resolving an Enumeration</h3>
<p>An enumerated symbol can be substituted for its equivalent symbol value in most expressions. However, there are some situations in which you need non-enumerated values. One case is converting from one enumeration domain to another, which happens when copying from one kdb+ database to another or in merging two databases.</p>
<p>Given an enumerated symbol, or a list of such, you can recover the un-enumerated value(s) by applying the built-in <a href="https://code.kx.com/q/ref/value/"><code>value</code></a>. In our on-going example,</p>
<pre class="highlight"><code class="language-q">q)sym:`g`aapl`msft`ibm
q)v:1000000?sym
q)ev:`sym$v
q)value ev
`aapl`g`msft`msft`ibm`msft`msft`msft`msft`msft`g`ibm`ibm`ibm..
q)v~value ev
1b</code></pre>
<p>This is another overload of <code>value</code>, the function that is essentially the q interpreter.</p>
                


                
              
              
                


              
            </article>
            
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))for(var set of document.querySelectorAll("[data-tabs]")){var labels=set.querySelectorAll(":scope > label");e:for(var tab of tabs)for(var label of labels)if(label.innerText.trim()===tab){var input=label.previousElementSibling;input.checked=!0;break e}}</script>

          </div>
        </div>
        
          
        
      
                </div>
            </section>
        
            <section class="chapter" id="chapter-13">
                <div class="chapter-header">
                    <h1 class="chapter-title">8. Tables¬∂</h1>
                    <div class="chapter-meta">
                        <span>üìñ Source: <a href="https://code.kx.com/q4m3/8_Tables/">https://code.kx.com/q4m3/8_Tables/</a></span>
                        <span>üìù 8187 words</span>
                        
                    </div>
                </div>
                <div class="chapter-content">
                    
        <div class="md-main__inner md-grid">
          
            
              
              
            
            
              
              
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                
                <h1 id="8-tables">8. Tables</h1>
<h2 id="80-overview">8.0 Overview</h2>
<p>Tables are first-class entities in q, meaning they are data structures that live in memory just like lists or dictionaries. A q table is essentially a collection of named columns implemented as a dictionary. Consequently, q tables are column-oriented, in contrast to the row-oriented tables in relational databases. Moreover, since lists are ordered, so are columns, in contrast to SQL where the order of rows is undefined. The fact that q tables comprise ordered column lists makes kdb+ very efficient at storing, retrieving and manipulating sequential data. One important example is time-series data.</p>
<p>Kdb+ handles relational and time series data in the unified environment of q tables. There is no separate data-definition language, no separate stored-procedure language and no need to map internal representations to a separate form for persistence. Just q tables, expressions and functions.</p>
<p>Tables are built from dictionaries, so it behooves the cursory reader to review <a href="https://code.kx.com/q4m3/5_Dictionaries/">Chapter 5</a> before proceeding.</p>
<h2 id="81-table-definition">8.1 Table Definition</h2>
<h3 id="811-review-of-table-as-column-dictionary">8.1.1 Review of Table as Column Dictionary</h3>
<p>We summarize our findings on column dictionaries from <a href="https://code.kx.com/q4m3/5_Dictionaries/#54-flipping-a-column-dictionary">¬ß5.4</a>. We began with a rectangular collection of named column lists.</p>
<pre class="highlight"><code class="language-q">q)dc:`name`iq!(`Dent`Beeblebrox`Prefect;98 42 126)
q)dc[`iq;]
98 42 126
q)dc[;2]
name| `Prefect
iq  | 126
q)dc[`iq; 2]
126</code></pre>
<p>Transpose it with <a href="https://code.kx.com/q/ref/flip/"><code>flip</code></a> to get a table.</p>
<pre class="highlight"><code class="language-q">q)t:flip `name`iq!(`Dent`Beeblebrox`Prefect;98 42 126)
q)t[;`iq]
98 42 126
q)t[2;]
name| `Prefect
iq  | 126
q)t[2;`iq]
126</code></pre>
<p>We repeat our findings about a table defined this way.</p>
<ul>
<li>It is a two-dimensional data structure that uses an integer index in the first slot and a symbol column name in the second slot.</li>
<li>Specifying only an integer in the first slot retrieves a section dictionary across that index ‚Äì i.e., a record.</li>
<li>Specifying only a column name in the second slot retrieves that column.</li>
<li>Specifying both an integer and a column name retrieves the "field" at that row in that column.</li>
<li>A table is logically a list of section dictionaries.</li>
<li>The <strong>only</strong> effect of flipping the column dictionary is to reverse the order of its indices; no data is rearranged under the covers.</li>
</ul>
<p>All tables have type <code>98h</code>.</p>
<pre class="highlight"><code class="language-q">q)type t
98h</code></pre>
<p>The proper way to extract a table column is by eliding the row index. For table columns (only), you can omit the leading semi-colon in the syntax.</p>
<pre class="highlight"><code class="language-q">q)t[;`iq]
_
q)t[`iq]
_
q)t[`name`iq]
Dent Beeblebrox Prefect
98   42         126</code></pre>
<p>Since it is possible to retrieve values from a dictionary using dot notation, this is also true for tables.</p>
<pre class="highlight"><code class="language-q">q)t.name
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Unfortunately dot notation doesn‚Äôt work inside functions so we recommend not using it at all.</p>
</div>
<h3 id="812-table-display">8.1.2 Table Display</h3>
<p>Observe that the row and column display of a table is indeed the transpose of the dictionary display. This reflects the transposed indices, even though the internal data layout is the same.</p>
<pre class="highlight"><code class="language-q">q)dc
name| Dent Beeblebrox Prefect
iq  | 98   42         126
q)t
name       iq 
--------------
Dent       98 
Beeblebrox 42 
Prefect    126</code></pre>
<h3 id="813-table-definition-syntax">8.1.3 Table-Definition Syntax</h3>
<p>Constructing a table by flipping a column dictionary is useful when you need to build the table on the fly. There is an alternate syntax to define tables that makes things a bit more readable.</p>
<pre>([] *c<sub>1</sub>*:*L<sub>1</sub>*; ...; *c<sub>n</sub>*:*L<sub>n</sub>*)
</pre>
<p>Here <em>c<sub>i</sub></em> is a symbol representing a column name and <em>L<sub>i</sub></em> is the corresponding list of column values. The <em>L<sub>i</sub></em> are lists of equal count, but can be atoms as long as at least one is a list. The brackets will contain key columns for keyed tables ‚Äì explained in <a href="#833-selecting-columns">¬ß8.3.3</a> ‚Äì but are empty for tables. For readability, in this tutorial we shall often include optional whitespace after the closing square bracket and to the right of semicolon separators.</p>
<p>The colons in table-definition syntax are <strong>not</strong> assignment. They are part of the syntactic sugar and serve as markers separating column names from column values.</p>
<div class="admonition warning">
<p class="admonition-title">Do not omit the square brackets in table-definition syntax</p>
<p>The interpreter will not complain and you will end up with a list, rather than a table, and the colons will be assignment.</p>
</div>
<p>Here is how to define our favorite table using table-definition syntax, which is arguably simpler.</p>
<pre class="highlight"><code class="language-q">q)t:([] name:`Dent`Beeblebrox`Prefect; iq:98 42 126)
q)t~flip `name`iq!(`Dent`Beeblebrox`Prefect;98 42 126)
1b</code></pre>
<p>The value lists in table-definition syntax can originate from variables, which is useful for programmatic table definition. In this case the column names are the variable names.</p>
<pre class="highlight"><code class="language-q">q)c1:`Dent`Beeblebrox`Prefect
q)c2:98 42 126
q)([] c1; c2)
_</code></pre>
<p>This example shows that if you don't explicitly specify column names, q will create them on a best-effort basis. In this example, it used the variable names. It will also try to make duplicate column names unique by appending a numeric suffix.</p>
<p>Any valid q expression can appear to the right of the semi-colon in table-definition syntax; it is evaluated as part of the table construction. You must ensure that the resulting column lists all have the same length.</p>
<pre class="highlight"><code class="language-q">q)([] c1:1+til 5; c2:5#42)
_</code></pre>
<p>Provided you specify at least one column as a list, atoms will be extended to match.</p>
<pre class="highlight"><code class="language-q">q)([] c1:`a`b`c; c2:42; c3:98.6)
c1 c2 c3  
----------
a  42 98.6
b  42 98.6
c  42 98.6</code></pre>
<p>Using an atom in this way might appear to assign a default value. It does not.</p>
<div class="admonition tip">
<p class="admonition-title">You cannot define a single-row table using all atoms. You must enlist at least one of the atoms.</p>
<pre><code class="language-q">
q)([] c1:`a; c2:100)
'rank
q)([] enlist `a; c2:100)
_
</code></pre>
</div>
<p>If you create a table as the flip of a column dictionary, item-wise extension is performed when the column dictionary is flipped into a table.</p>
<pre class="highlight"><code class="language-q">q)`c1`c2`c3!(`a`b`c;42;1.1)
c1| `a`b`c
c2| 42
c3| 1.1
q)flip `c1`c2`c3!(`a`b`c;42;1.1)
c1 c2 c3 
---------
a  42 1.1
b  42 1.1
c  42 1.1</code></pre>
<h3 id="814-table-metadata">8.1.4 Table Metadata</h3>
<p>The column names of a table can be retrieved as a list of symbols with <a href="https://code.kx.com/q/ref/cols"><code>cols</code></a>.</p>
<pre class="highlight"><code class="language-q">q)cols t
_</code></pre>
<p>The function <a href="https://code.kx.com/q/ref/meta/"><code>meta</code></a> applied to a table retrieves its metadata. The result is a keyed table (see <a href="#841-keyed-table">¬ß8.4.1</a>) with one record for each column in the original table.</p>
<ul>
<li>The key column <code>c</code> of the result contains the column names.</li>
<li>The column <code>t</code> contains a symbol denoting the type char of the column.</li>
<li>The column <code>f</code> contains the domains of any foreign key or link columns.</li>
<li>The column <code>a</code> contains any attributes associated with the column.</li>
</ul>
<pre class="highlight"><code class="language-q">q)meta t
c   | t f a
----| -----
name| s    
iq  | j</code></pre>
<p>When <code>meta</code> displays an <strong>upper</strong>-case type char for a column, this indicates that column is a <em>compound</em> list in which all fields are simple lists of the indicated type. Such tables arise, for example, when you group without aggregating in a query. Here is one created manually. Observe the upper case J in the <code>t</code> column for column <code>c2</code>.</p>
<pre class="highlight"><code class="language-q">q)meta ([] c1:1 2 3; c2:(1 2; enlist 3; 4 5 6))
c | t f a
--| -----
c1| j    
c2| J   </code></pre>
<details class="warning">
<summary>When <code>meta</code> is applied to a partitioned table that has been mapped into memory, it examines only the most recent partition.</summary>
<p>Thus it makes the implicit assumption that the partition slice schemas are consistent across the partitions. In the event that the partition slices are not consistent, <code>meta</code> blithely reports the schema found in the most recent partition. </p>
<p>In order to determine the offending partition, you will have to run <code>meta</code> on each of the partition slices and determine the outliers. This is relevant because the <code>.Q</code> utilities will <strong>not</strong> prevent you from writing an inconsistent partition slice and you may discover the error later.</p>
</details>
<p>The function <a href="https://code.kx.com/q/ref/tables/"><code>tables</code></a> takes a symbolic namespace (see <a href="https://code.kx.com/q4m3/12_Workspace_Organization/#121-namespaces">¬ß12.1</a>) and returns a sorted symbol list of the names of tables in that context. For example, we list all tables in the root context for a fresh q session.</p>
<pre class="highlight"><code class="language-q">q)t2:([] c1:1 2 3; c2:(1 2; enlist 3; 4 5 6))
q)t:([] name:`Dent`Beeblebrox`Prefect; iq:98 42 126)
q)tables `.
`t`t2</code></pre>
<p>Alternatively, the command <a href="https://code.kx.com/q/basics/syscmds/#a-tables"><code>\a</code></a> provides the same result. If no argument is provided, it returns the result for the current context.</p>
<h3 id="815-records">8.1.5 Records</h3>
<p>Since a table is logically a list of dictionary records, <a href="https://code.kx.com/q/ref/count/"><code>count</code></a> returns the number of records. In our example,</p>
<pre class="highlight"><code class="language-q">q)count t
_</code></pre>
<p>Now let's inspect the sequence of records.</p>
<pre class="highlight"><code class="language-q">q)t
name       iq 
--------------
Dent       98 
Beeblebrox 42 
Prefect    126
q)t[0]
name| `Dent
iq  | 98
q)t[1]
name| `Beeblebrox
iq  | 42</code></pre>
<p>Since a record dictionary slices across the table display horizontally, this motivates calling the value portion of the record dictionary a table <em>row</em>. The record associates column names with the values in a physical row. To retrieve the naked values of a row ‚Äì i.e., without the column names ‚Äì simply apply <code>value</code> to the record dictionary.</p>
<pre class="highlight"><code class="language-q">q)value t[1]
`Beeblebrox
42</code></pre>
<h3 id="816-flipped-column-dictionary-vs-list-of-records">8.1.6 Flipped Column Dictionary vs. List of Records</h3>
<p>Is a table a flipped column dictionary or a list of records? Logically it is both, but physically it is stored as a column dictionary. In fact, q dynamically recognizes a conforming list of dictionaries that could be formed into a table and reorganizes the data into columnar form automatically. It doesn‚Äôt ask for permission or seek forgiveness.</p>
<p>To verify this, we first create a list of non-conforming dictionaries that differ in <!-- the *italicized* --> key names. As expected it has type 0.</p>
<pre class="highlight"><code class="language-q">q)type (`name`iq!(`Dent;98); `nome`iq!(`Beeblebrox;42))
0h</code></pre>
<p>Once we make the names agree so that the records conform, <code>type</code> tells us that q has indeed converted the list to a table.</p>
<pre class="highlight"><code class="language-q">q)type (`name`iq!(`Dent;98); `name`iq!(`Beeblebrox;42))
98h</code></pre>
<p>This is no mere illusion. The data have been reorganized into columns.</p>
<div class="admonition tip">
<p class="admonition-title">A useful special case of this phenomenon</p>
<p>Start with a simple dictionary and enlist it to create a singleton. What is this?
</p><pre><code class="language-q">
q)enlist `a`b!10 20
_
</code></pre>
It is a table because it is a singleton list of records that conform.
</div>
<p>You might think that you don‚Äôt want q to do this automatic reorganization, but you would be wrong. In general, column retrieval and manipulation will be significantly faster than operations on a list of dictionaries, especially if the columns are simple ‚Äì i.e., the column values are stored contiguously.</p>
<p>A downside of tables being stored as columns is that row deletion is an expensive operation because all the column lists must be compressed to close the resulting gap. The best way to deal with this in large tables is not to do it. Instead of deleting a row, use a separate column that holds a flag indicating whether the row has been deleted and then exclude the "deleted" rows. Then compress this column to save space since it will be sparse.</p>
<h2 id="82-empty-tables-and-schema">8.2 Empty Tables and Schema</h2>
<p>We saw in the previous section that a table can be defined and populated in one step using table syntax.</p>
<pre class="highlight"><code class="language-q">q)t:([] name:`Dent`Beeblebrox`Prefect; iq:98 42 126)</code></pre>
<p>Fully listing columns with literals is usually done only with smaller tables ‚Äì e.g., lookup tables. Large tables are usually created programmatically from computed data or data read from files or received over the wire.</p>
<p>In these circumstances, it is useful to create an empty table initially and then populate it later by appending in place. You could do this with general empty lists.</p>
<pre class="highlight"><code class="language-q">q)([] name:(); iq:())</code></pre>
<p>All columns here are lists of general type, so data of any type can be appended in the first record. Should the first item being appended to an empty column be an atom (a common case), the column becomes a singleton list with that atom ‚Äì i.e., a simple list of that type. As with all simple lists, type checking will thereafter be enforced for all inserts and updates to that column. Consequently all subsequent appends must match the initial one.</p>
<p>This situation is fine provided you are guaranteed that all data will match the initial record. Unfortunately, real world data can be highly unpredictable. Should the first record be bad, type checking will reject all subsequent good data.</p>
<div class="admonition tip">
<p class="admonition-title">It is good practice to specify the types of all columns in an empty table.</p>
<p>In the table definition, cast an empty list to the appropriate type.</p>
<pre><code class="language-q">
q)([] name:`symbol$(); iq:`int$())
_
</code></pre>
</div>
<p>A shorter, and arguably less obvious technique is the following.</p>
<pre class="highlight"><code class="language-q">q)([] name:0#`; iq:0#0)
_
q)([] name:0#`; iq:0#0) ~ ([] name:`symbol$(); iq:`long$())
1b</code></pre>
<p>Whichever form you use, it ensures that only data of the appropriate type can be appended.</p>
<h2 id="83-basic-select-and-update">8.3 Basic select and update</h2>
<p>We shall cover q-sql in depth in <a href="https://code.kx.com/q4m3/9_Queries_q-sql/">Chapter 9</a>, but we provide an introduction here in order to extract and display data in our examples. We use the following sample table in this section.</p>
<pre class="highlight"><code class="language-q">q)t:([] name:`Dent`Beeblebrox`Prefect; iq:98 42 126)</code></pre>
<h3 id="831-syntax-of-select">8.3.1 Syntax of <code>select</code></h3>
<p>The basic select is a template that takes the form,</p>
<pre class="highlight"><code class="language-q">select cols from table</code></pre>
<p>where <em>table</em> is either a table or a keyed table and <em>cols</em> is a comma-separated list of columns. This expression results in a list of <strong>all</strong> records for the specified columns. This corresponds to the SQL statement,</p>
<pre class="highlight"><code class="language-sql">SELECT * FROM table</code></pre>
<p>In q you do not write the wildcards when you want all columns in the table; simply omit the columns and you get them all.</p>
<p>This basic select syntax may seem comfortably familiar from SQL, but it should seem odd to the qbie who is just getting accustomed to parsing expressions right-to-left. Neither <code>select</code> nor <code>from</code> represent functions that can stand alone. There are many options for the basic select template whose elements appear between the <code>select</code> and <code>from</code> or after the <em>table</em> element.</p>
<h3 id="832-displaying-the-result">8.3.2 Displaying the Result</h3>
<p>The result of <code>select</code> is always a table. You may think of it as a list of (conforming) records but it is actually constructed as a column dictionary.</p>
<pre class="highlight"><code class="language-q">q)select from t
name       iq 
--------------
Dent       98 
Beeblebrox 42 
Prefect    126</code></pre>
<h3 id="833-selecting-columns">8.3.3 Selecting Columns</h3>
<p>To select specific columns, list them comma-separated in left-to-right order between <code>select</code> and <code>from</code>. You can optionally provide column names using the same colon format as table-definition syntax.</p>
<pre class="highlight"><code class="language-q">q)select name from t
name
----------
Dent
Beeblebrox
Prefect
q)select c1:name, c2:iq from t
_</code></pre>
<h3 id="834-basic-update">8.3.4 Basic update</h3>
<p>The syntax of <code>update</code> is the same as <code>select</code>, but named columns represent replacement by the values to the right of the colon. In our example,</p>
<pre class="highlight"><code class="language-q">q)update iq:iq%100 from t
_</code></pre>
<h2 id="84-primary-keys-and-keyed-tables">8.4 Primary Keys and Keyed Tables</h2>
<p>In SQL, one can declare one or more column(s) of a table as a primary key. This means that the values in the column(s) are unique over the domain of the rows, making it possible to identify and retrieve a row via its key value. These two features motivate how q implements a keyed table.</p>
<h3 id="841-keyed-table">8.4.1 Keyed Table</h3>
<p>We begin with a simple key ‚Äì i.e., the key is a single column of simple type. The approach is to place the key column in a separate table parallel to a table containing the remaining columns to obtain a table of keys and a table of values. Since a table is logically a list of records, this is the same as a list of key records and list of value records. We establish a positional correspondence between these lists via a dictionary mapping.</p>
<p>A <em>keyed table</em> is a dictionary mapping a table of key records to a table of value records. This represents a mapping from each row in a table of (presumably unique) keys to a corresponding row in a table of values ‚Äì i.e., a positional correspondence of key rows to value rows. Using dictionary lookup on a key (record) retrieves the corresponding value record in the remaining columns. This is just what a primary key should do. Note that the key mapping assumes that the key records and value records are in corresponding order.</p>
<div class="admonition note">
<p class="admonition-title">A keyed table is <strong>not</strong> a table ‚Äì it is a dictionary and so has type <code>99h</code>.</p>
</div>
<p>Keys should be unique but (sadly) this is not enforced. As we have already noted, dictionary creation does not enforce key uniqueness. A value row associated with a duplicate key is not accessible via key lookup, but it can be retrieved via a <code>select</code> on the key column.</p>
<h3 id="842-simple-example">8.4.2 Simple Example</h3>
<p>Let‚Äôs see how this works for our previous example. We begin with a flipped column dictionary to make things explicit.</p>
<pre class="highlight"><code class="language-q">q)v:flip `name`iq!(`Dent`Beeblebrox`Prefect;98 42 126)</code></pre>
<p>Now say we want to add a key column <code>eid</code> containing employee identifiers. We begin by placing the identifiers in a separate table. Recall from <a href="https://code.kx.com/q4m3/5_Dictionaries/#534-column-dictionary-with-a-single-column">¬ß5.3.4</a> that we must enlist both the column name and the value list for single column table.</p>
<pre class="highlight"><code class="language-q">q)k:flip (enlist `eid)!enlist 1001 1002 1003</code></pre>
<p>Now establish the association between the two tables.</p>
<pre class="highlight"><code class="language-q">q)kt:k!v</code></pre>
<p><em>Voil√†!</em> The console display of a keyed table is the combination of dictionary display and table display. It lists the key column(s) on the left, separated by a vertical bar from the value columns on the right.</p>
<pre class="highlight"><code class="language-q">q)kt
eid | name       iq 
----| --------------
1001| Dent       98 
1002| Beeblebrox 42 
1003| Prefect    126</code></pre>
<h3 id="843-keyed-table-definition-syntax">8.4.3 Keyed-Table Definition Syntax</h3>
<p>Fundamentalists insist on constructing a keyed table as a dictionary of flipped dictionaries, but most folks prefer to use table-definition syntax.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Due to space limitations on the printed page we cannot fit our keyed table examples on a single line, so we wrap the lines, with column alignment for readability. You cannot enter such a multiline statement into the q console, but you can place it in a script. If you are following this tutorial line by line, you can copy/paste the individual lines onto a single line in the q console.</p>
</div>
<p>Here is the fundamental form of our keyed table.</p>
<pre class="highlight"><code class="language-q">q)kt:(flip (enlist `eid)!enlist 1001 1002 1003)!
    flip `name`iq!(`Dent`Beeblebrox`Prefect;98 42 126)</code></pre>
<p>It is arguably simpler to use table-definition syntax. This is a generalization of (plain) table definition in which key column(s) are placed between the square brackets and the value columns are after the square brackets.</p>
<pre class="highlight"><code class="language-q">q)kt:([eid:1001 1002 1003]
      name:`Dent`Beeblebrox`Prefect; iq:98 42 126)</code></pre>
<div class="admonition note">
<p class="admonition-title">Placing key column(s) inside the square brackets is consistent with the notation for a (regular) table since a regular table has no keys.</p>
</div>
<p>To define an empty keyed table, use empty key and value columns.</p>
<pre class="highlight"><code class="language-q">q)ktempty:([eid:()] name:(); iq:())</code></pre>
<p>As with regular tables, empty columns should be typed with either of the following constructs to ensure data integrity.</p>
<pre class="highlight"><code class="language-q">q)ktempty:([eid:`int$()] `symbol$name:(); iq:`int$())
q)ktempty:([eid:0#0] name:0#`; iq:0#0)</code></pre>
<h3 id="844-accessing-records-of-a-keyed-table">8.4.4 Accessing Records of a Keyed Table</h3>
<p>Since a keyed table is a dictionary mapping, it provides access to records in the value table via key lookup. Remember that the records in the key table and value table are section dictionaries.</p>
<pre class="highlight"><code class="language-q">q)kt[(enlist `eid)!enlist 1002]
name| `Beeblebrox
iq  | 42</code></pre>
<p>Yikes! This is a cumbersome way to retrieve by key.</p>
<p>Fortunately, you can abbreviate the full dictionary specification of a key record to its key value. Our example reduces to,</p>
<pre class="highlight"><code class="language-q">q)kt[1002]
name| `Beeblebrox
iq  | 42</code></pre>
<p>Now we can look up the value for an individual column.</p>
<pre class="highlight"><code class="language-q">q)kt[1002][`iq]
42</code></pre>
<p>Or we can use the equivalent index at depth notation.</p>
<pre class="highlight"><code class="language-q">q)kt[1002;`iq]
42</code></pre>
<p>After the customary moment of q Zen, we realize that the net effect of "placing a key on a table" is to convert indexing of the rows from row number to key value.</p>
<h3 id="845-retrieving-multiple-records">8.4.5 Retrieving Multiple Records</h3>
<p>We have seen how to look up a single record in a keyed table by key value.</p>
<pre class="highlight"><code class="language-q">q)kt[1001]
name| `Dent
iq  | 98
q)kt 1001
_</code></pre>
<p>You might think it is possible to retrieve multiple records from a keyed table via a simple list of keys. You would be wrong.</p>
<pre class="highlight"><code class="language-q">q)kt[1001 1002]
'length</code></pre>
<div class="admonition tip">
<p class="admonition-title">This works for a compound key ‚Äì i.e., a multi-column key ‚Äì just not for a single column key.</p>
</div>
<p>To look up multiple key values in a keyed table, we could use one of the following constructs to generate a list of enlisted keys.</p>
<pre class="highlight"><code class="language-q">q)kt[(enlist 1001;enlist 1002)]
name       iq
-------------
Dent       98
Beeblebrox 42
q)kt[flip enlist 1001 1002]
_</code></pre>
<p>This is still pretty cumbersome, so back to the drawing board. Since we are supposed to provide a list of key records for lookup, we can simply create an anonymous table whose records are precisely the form we need.</p>
<pre class="highlight"><code class="language-q">q)kt ([] eid:1001 1002)
_</code></pre>
<p>Now that‚Äôs slick!</p>
<p>With such a nifty way to create a list of key records in hand, we recall from <a href="https://code.kx.com/q4m3/5_Dictionaries/#522-extracting-a-sub-dictionary">¬ß5.2.2</a> that a sub-dictionary can be extracted using a list of keys as the left operand of <code>#</code>. Applying this to our keyed table,</p>
<pre class="highlight"><code class="language-q">q)([] eid:1001 1002)#kt
eid | name       iq
----| -------------
1001| Dent       98
1002| Beeblebrox 42</code></pre>
<p>The Zen of keyed tables‚Ä¶ no select statement required.</p>
<h3 id="846-reverse-lookup">8.4.6 Reverse Lookup</h3>
<p>Because a keyed table is a dictionary, it is possible to perform reverse lookup from value records to key records. Let‚Äôs show an example having a single value column.</p>
<pre class="highlight"><code class="language-q">q)kts:([eid:1001 1002 1003] name:`Dent`Beeblebrox`Prefect)
q)kts
_</code></pre>
<p>As in the case of key lookup, we can use an anonymous table with a list of value records.</p>
<pre class="highlight"><code class="language-q">q)kts?([] name:`Prefect`Dent)
_</code></pre>
<h3 id="847-components-of-a-keyed-table">8.4.7 Components of a Keyed Table</h3>
<p>Since a keyed table is a dictionary mapping the table of keys to the table of values, the functions <a href="https://code.kx.com/q/ref/key/"><code>key</code></a> and <a href="https://code.kx.com/q/ref/value/"><code>value</code></a> extract the constituents.</p>
<pre class="highlight"><code class="language-q">q)key kt
_
q)value kt
_</code></pre>
<p>The function <code>keys</code> returns a list of symbolic key column name(s).</p>
<pre class="highlight"><code class="language-q">q)keys kt
_</code></pre>
<p>Observe that <a href="https://code.kx.com/q/ref/cols/"><code>cols</code></a> retrieves all column names of the keyed table ‚Äì i.e., from both the key and value tables.</p>
<pre class="highlight"><code class="language-q">q)cols kt
_</code></pre>
<h3 id="848-tables-vs-keyed-tables">8.4.8 Tables vs. Keyed Tables</h3>
<p>It is possible to convert dynamically between a regular table having a column of potential key values and the corresponding keyed table using binary primitive <a href="https://code.kx.com/q/ref/xkey/"><code>xkey</code></a>. The right operand is the source table/keyed table and the left operand is a symbol (or list of symbols) with the column name(s) to be used as the key.</p>
<pre class="highlight"><code class="language-q">q)t:([] eid:1001 1002 1003; name:`Dent`Beeblebrox`Prefect; iq:98 42 126)
q)`eid xkey t
eid | name       iq 
----| --------------
1001| Dent       98 
1002| Beeblebrox 42 
1003| Prefect    126</code></pre>
<p>Conversely, to convert a keyed table to a regular table, use <code>xkey</code> with an empty general list as the left operand.</p>
<pre class="highlight"><code class="language-q">q)kt:([eid:1001 1002 1003] name:`Dent`Beeblebrox`Prefect; iq:98 42 126)
q)kt
_
q)() xkey kt
eid  name       iq 
-------------------
1001 Dent       98 
1002 Beeblebrox 42 
1003 Prefect    126</code></pre>
<p>You can also use an overload of <code>!</code> to <a href="https://code.kx.com/q/ref/enkey/">key/unkey</a> tables. The left operand is a non-negative integer that specifies the number of left-most columns to include in the key, where 0 indicates none ‚Äì i.e., no keys. With t and kt as above,</p>
<pre class="highlight"><code class="language-q">q)1!t
_
q)0!kt
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">While these forms are terse, the first makes your code less obvious since the new key column(s) are only implicit.</p>
</div>
<p>The table/keyed table conversions above (in both forms) work on copies and do not affect the original table. Use call-by-name to modify the original.</p>
<pre class="highlight"><code class="language-q">q)`eid xkey `t
`t
q)t
_
q)() xkey `kt
`kt
q)kt
_</code></pre>
<p>If <code>xkey</code> is applied with a column that does not contain unique values, the result is not a error but rather a keyed table that does not have a true primary key.</p>
<pre class="highlight"><code class="language-q">q)t:([] eid:1001 1002 1003 1001; name:`Dent`Beeblebrox`Prefect`Dup)
q)ktdup:`eid xkey t
q)ktdup
eid | name
----| ----------
1001| Dent
1002| Beeblebrox
1003| Prefect
1001| Dup</code></pre>
<p>Duplicate key values are not accessible via key lookup.</p>
<pre class="highlight"><code class="language-q">q)ktdup 1001
name| Dent</code></pre>
<p>They are accessible via select.</p>
<pre class="highlight"><code class="language-q">q)select from ktdup where eid=1001
eid | name
----| ----
1001| Dent
1001| Dup</code></pre>
<h3 id="849-compound-primary-key">8.4.9 Compound Primary Key</h3>
<p>The q implementation of a keyed table as a dictionary mapping between a pair of tables carries over unchanged to compound keys. Recall that a compound key in SQL is a collection of multiple columns that together provide a unique value for each row. A compound key in q is simply a table association <code>k!v</code> in which <code>k</code> has multiple columns. Presumably each record in the key table has a unique combination of field values, but this is <strong>not</strong> checked.</p>
<p>Here is our galactic travelers table redone to replace the employee ID with a compound key comprising last and first names.</p>
<pre class="highlight"><code class="language-q">q)ktc:([lname:`Dent`Beeblebrox`Prefect; fname:`Arthur`Zaphod`Ford]; iq:98 42 126)</code></pre>
<p>Observe that the console displays a compound keyed table with the key columns on the left of the vertical bar and the value columns to the right.</p>
<pre class="highlight"><code class="language-q">q)ktc
lname      fname | iq 
-----------------| ---
Dent       Arthur| 98 
Beeblebrox Zaphod| 42 
Prefect    Ford  | 126</code></pre>
<p>Here is lookup by a compound key record,</p>
<pre class="highlight"><code class="language-q">q)ktc[`lname`fname!`Beeblebrox`Zaphod]
_</code></pre>
<p>As with a simple key, we can abbreviate a full key record to the key value for key lookup.</p>
<pre class="highlight"><code class="language-q">q)ktc[`Dent`Arthur]
_</code></pre>
<p>The empty keyed table can be typed using table-definition syntax with either of the following,</p>
<pre class="highlight"><code class="language-q">q)ktc:([lname:`symbol$();fname:`symbol$()] iq:`int$())
q)ktc:([lname:0#`;fname:0#`] iq:0#0)</code></pre>
<p>For the fundamentalists, here is the same compound keyed table built from its constituent column dictionaries.</p>
<pre class="highlight"><code class="language-q">q)ktc:(flip `lname`fname!(`Dent`Beeblebrox`Prefect;`Arthur`Zaphod`Ford))!
    flip (enlist `iq)!enlist 98 42 126</code></pre>
<p>Most will agree that the table-definition syntax is simpler.</p>
<h3 id="8410-retrieving-records-with-a-compound-primary-key">8.4.10 Retrieving Records with a Compound Primary Key</h3>
<p>Unlike a simple key, we can lookup multiple value records with a list of compound keys.</p>
<pre class="highlight"><code class="language-q">q)ktc (`Dent`Arthur;`Prefect`Ford)
_</code></pre>
<p>Of course the nifty construct with an anonymous table works with compound keys too.</p>
<pre class="highlight"><code class="language-q">q)ktc ([] lname:`Dent`Prefect; fname:`Arthur`Ford)
_</code></pre>
<p>As does the use of <a href="https://code.kx.com/q/ref/take/" title="Take"><code>#</code></a> to retrieve a sub keyed table from a list of keys.</p>
<pre class="highlight"><code class="language-q">q)K:([] lname:`Dent`Prefect; fname:`Arthur`Ford)
q)K#ktc
lname   fname | iq 
--------------| ---
Dent    Arthur| 98 
Prefect Ford  | 126</code></pre>
<h3 id="8411-extracting-column-data">8.4.11 Extracting Column Data</h3>
<p>In this section we use the following example tables. The first has a simple key of long and the second a compound key of symbols.</p>
<pre class="highlight"><code class="language-q">q)kts:([k:101 102 103] v1:`a`b`c; v2:1.1 2.2 3.3)
q)kts
_
q)ktc:([k1:`a`b`c;k2:`x`y`z] v1:`a`b`c; v2:1.1 2.2 3.3)
q)ktc
_</code></pre>
<p>In the previous section we saw how to retrieve <strong>all</strong> the value columns using an anonymous table of keys.</p>
<pre class="highlight"><code class="language-q">q)kts[([] k:101 103)]
_
q)ktc[([] k1:`a`c;k2:`x`z)]
_</code></pre>
<p>Often we need to extract the naked column data from some value columns. No problem for the fundamentalist. Since the result of the lookup is a sub-table of the value table, we can index into it to get the column list(s).</p>
<pre class="highlight"><code class="language-q">q)kts[([] k:101 103)][`v1]
`a`c
q)ktc[([] k1:`a`c;k2:`x`z)][`v1`v2]
_</code></pre>
<p>And we can simplify using indexing at depth.</p>
<pre class="highlight"><code class="language-q">q)kts[([] k:101 103); `v1]
_
q)ktc[([] k1:`a`c;k2:`x`z); `v1`v2]
_</code></pre>
<h2 id="85-foreign-keys-and-virtual-columns">8.5 Foreign Keys and Virtual Columns</h2>
<p>A foreign key in SQL is a column in one table whose values are members of a primary key column in another table. Foreign keys are the mechanism for establishing relations between tables.</p>
<p>An important feature of a foreign key is that the RDBMS enforces referential integrity, meaning that values in the foreign key column are <strong>required</strong> to be in the related primary key column. Before you can insert a row having a foreign key field value that is not there, you must first ensure there is a row with that primary key in the related table.</p>
<h3 id="851-definition-of-foreign-key">8.5.1 Definition of Foreign Key</h3>
<p>A foreign key in q should provide a relation with referential integrity (in one direction, at least). Can we implement this with a construct we already know in q? The setting is a collection of record items in a column list that are drawn from the (supposedly) unique record items in another column list. Sound familiar? It is precisely the situation of an enumeration!</p>
<p>A <em>foreign key</em> is one or more table columns whose values are defined as an enumeration over the key column(s) of a keyed table. As in the case of symbol enumeration <code>`sym$</code>, the enumeration restricts foreign key values to be in the list of primary key values.</p>
<h3 id="852-example-of-simple-foreign-key">8.5.2 Example of Simple Foreign Key</h3>
<p>We return to the galactic travelers keyed table.</p>
<pre class="highlight"><code class="language-q">q)kt:([eid:1001 1002 1003] name:`Dent`Beeblebrox`Prefect; iq:98 42 126)</code></pre>
<p>Suppose we have a table with the detail records of the results of repeated IQ tests of the travelers.</p>
<pre class="highlight"><code class="language-q">([] eid:1003 1001 1002 1001 1002 1001; sc:126 36 92 39 98 42)</code></pre>
<p>This table has no restriction on <code>eid</code> other than it be a long. To ensure that only <code>eid</code> values for actual travelers can be entered, we make the <code>eid</code> column in this table a foreign key related to the <code>eid</code> column in <code>kt</code>. This is done by enumerating over the name of the keyed table ‚Äì i.e., <code>`kt$</code>.</p>
<div class="admonition tip">
<p class="admonition-title">When q sees the name of a keyed table in an enumeration domain it knows to use the list of key records.</p>
</div>
<p>Here is the enumeration of the column in isolation.</p>
<pre class="highlight"><code class="language-q">q)`kt$1002 1001 1001 1003 1002 1003</code></pre>
<p>As in the case of symbol enumeration, q looks up the index of each foreign key value in the list of key records and, under the covers, replaces the field value with that index. Also as with symbols, the enumeration is displayed in reconstituted form instead of as the underlying indices. To see the underlying indices, cast to an integer.</p>
<pre class="highlight"><code class="language-q">q)`long$`kt$1002 1001 1001 1003 1002 1003
1 0 0 2 1 2</code></pre>
<p>As always, the enumeration can be substituted for the original in normal operations.</p>
<pre class="highlight"><code class="language-q">q)1003=`kt$1002 1001 1003 1002 1003
000101b</code></pre>
<p>And now, the moment of truth. Does the enumeration provide referential integrity?</p>
<pre class="highlight"><code class="language-q">q)`kt$1004
'cast</code></pre>
<p>It does. Attempting to enumerate a value that is not in the primary key column causes an error.</p>
<p>We put this together with table-definition syntax to define a details table with a foreign key over <code>kt</code>.</p>
<pre class="highlight"><code class="language-q">q)tdetails:([] eid:`kt$1003 1001 1002 1001 1002 1001; sc:126 36 92 39 98 42)</code></pre>
<p>Observe that a foreign key is denoted by the name of the target keyed table in the <code>f</code> column in the output of <code>meta</code>.</p>
<pre class="highlight"><code class="language-q">q)meta tdetails
c  | t f  a
---| ------
eid| j kt  
sc | j    </code></pre>
<p>The built-in function <a href="https://code.kx.com/q/ref/fkeys/"><code>fkeys</code></a> applied to a table (or keyed table) returns a dictionary in which each foreign key column name is mapped to its primary key table name.</p>
<pre class="highlight"><code class="language-q">q)fkeys tdetails
eid| kt</code></pre>
<h3 id="853-resolving-a-foreign-key">8.5.3 Resolving a Foreign Key</h3>
<p>When you wish to resolve a foreign key ‚Äì i.e., get the actual values instead of enumerated values ‚Äì apply <code>value</code> to the enumerated column.</p>
<pre class="highlight"><code class="language-q">q)meta update value eid from tdetails
c  | t f a
---| -----
eid| j    
sc | j    </code></pre>
<p>Observe that there is no longer an entry in the <code>f</code> column.</p>
<h3 id="854-foreign-keys-and-relations">8.5.4 Foreign Keys and Relations</h3>
<p>In SQL, a join is used to splice back together data that has been normalized via relations. The splice is done along a foreign key that establishes a relation to the primary key. In the result, columns from both tables are available using dot notation.</p>
<p>The same effect is achieved in q using foreign keys but you don't need to perform the join explicitly. The notation is similar, but the operation is different enough to warrant close attention.</p>
<p>Let <code>tf</code> be a table having a foreign key column <code>f</code> enumerated over a keyed table <code>kt</code>. All columns in <code>kt</code> are available via dot notation in a <code>select</code> expression whose <em>from</em> domain is <code>tf</code>. To access a column <code>c</code> in <code>kt</code>, use the notation <code>f.c</code> in the <code>select</code> expression. This column takes the name <code>c</code> by default in the result.</p>
<p>In our galactic travelers example, we can access columns in <code>kt</code> via a <code>select</code> on <code>tdetails</code>. Here is a query that retrieves a "foreign" column in addition to one from <code>tdetails</code>.</p>
<pre class="highlight"><code class="language-q">q)select eid.name, sc from tdetails
name       sc 
--------------
Prefect    126
Dent       36 
Beeblebrox 92 
Dent       39 
Beeblebrox 98 
Dent       42 </code></pre>
<p>There is an implicit left join between <code>tdetails</code> and <code>kt</code> here.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The implicit join with dot notation is powerful and convenient when your tables are in normal form and there are multiple foreign key relations. For example, a query could retrieve
</p><pre><code class="language-q">
select name.street.city.zip.country from residents where ‚Ä¶
</code></pre>
in a single select with no explicit joins.
</div>
<h2 id="86-working-with-tables-and-keyed-tables">8.6 Working with Tables and Keyed Tables</h2>
<p>In this section, we use the galactic travelers tables.</p>
<pre class="highlight"><code class="language-q">q)t:([] name:`Dent`Beeblebrox`Prefect; iq:98 42 126)
q)kt:([eid:1001 1002 1003] name:`Dent`Beeblebrox`Prefect; iq:98 42 126)</code></pre>
<h3 id="861-appending-records">8.6.1 Appending Records</h3>
<p>The fundamental way to append a record to a table is to view the table as a list of records and join with <code>,:</code>. Note that the fields in the record do not need to be in column order.</p>
<pre class="highlight"><code class="language-q">q)t,:`name`iq!(`W; 26)
q)t,:`iq`name!(200; `Albert)
q)t
_</code></pre>
<p>You can also append naked row values with <code>,:</code> but the fields <strong>must</strong> be in column order.</p>
<pre class="highlight"><code class="language-q">q)t,:(`H; 142)
_
q)t,:(97;`J)
'type
q)t
_</code></pre>
<h3 id="862-first-and-last-records">8.6.2 First and Last Records</h3>
<p>Because a table is logically a list of records, the functions <a href="https://code.kx.com/q/ref/first/"><code>first</code></a> and <a href="https://code.kx.com/q/ref/last/#last"><code>last</code></a> retrieve the initial and final records, respectively.</p>
<pre class="highlight"><code class="language-q">q)first t
name| `Dent
iq  | 98
q)last t
_</code></pre>
<p>A keyed table is a dictionary so functions apply to the value table.</p>
<pre class="highlight"><code class="language-q">q)first kt
name| `Dent
iq  | 98
q)last kt
_</code></pre>
<p>Because tables and keyed tables are ordered, these functions can be used for aggregation in queries without any need of the SQL clause <code>ORDER BY</code> ‚Äì provided your table was created in order.</p>
<p>You can retrieve the first or last <em>n</em> records of a table or keyed table using the Take operator <code>#</code>. Why does this work? Tables are lists and keyed tables are dictionaries and <code>#</code> works on both. Since <code>#</code> always returns a list and the extracted records conform, q recognizes the result of <code>#</code> as a table or keyed table with the same schema as the input.</p>
<pre class="highlight"><code class="language-q">q)2#t
_
q)-3#kt
_</code></pre>
<p>Also see <a href="https://code.kx.com/q4m3/9_Queries_q-sql/#9324-select">¬ß9.3.2.4</a> for another way to achieve this result using <code>select[n]</code>.</p>
<h3 id="863-find">8.6.3 Find</h3>
<p>The <a href="https://code.kx.com/q/ref/find/">Find</a> operator <code>?</code> used with a table returns the index of a record ‚Äì i.e., its row number.</p>
<pre class="highlight"><code class="language-q">q)t?`name`iq!(`Dent;98)
0</code></pre>
<p>As usual, the record can be abbreviated to a row list provided the fields have the right type and order.</p>
<pre class="highlight"><code class="language-q">q)t?(`Dent;98)
_</code></pre>
<p>Since Find is atomic in the right operand, you can determine multiple row indices.</p>
<pre class="highlight"><code class="language-q">q)t?((`Dent;98);(`Prefect;126))
_</code></pre>
<p>Since a keyed table is a dictionary, Find <code>?</code> performs a reverse lookup of a value record/row and returns the first associated key record.</p>
<pre class="highlight"><code class="language-q">q)kt?`name`iq!(`Dent;98)
eid| 1001
q)kt?(`Dent;98)
_</code></pre>
<p>As with key lookup, a single column must have enlisted values, or you can use the anonymous table construct.</p>
<pre class="highlight"><code class="language-q">q)t1:([] eid:1001 1002 1003)
q)t1?enlist each 1001 1002
0 1
q)t1?([] eid:1001 1002)
_</code></pre>
<h3 id="864-union-with">8.6.4 Union with <code>,</code></h3>
<p>The <a href="https://code.kx.com/q/ref/join/">Join</a> operator <code>,</code> is defined for tables and keyed tables since they both comprise lists of records. It is essentially the same as <code>UNION</code> in SQL.</p>
<p>You can use <code>,</code> to append a record to (a copy of) a table, but no type checking will be performed.</p>
<pre class="highlight"><code class="language-q">q)t,`name`iq!(`Slaartibartfast; `123)
name            iq  
--------------------
Dent            98  
Beeblebrox      42  
Prefect         126 
Slaartibartfast `123</code></pre>
<div class="admonition warning">
<p class="admonition-title">Using a row with <code>,</code> will not yield a table. Instead you get a general list.</p>
<pre><code class="language-q">
q)t,(`Slaartibartfast; 110)
`name`iq!(`Dent;98)
`name`iq!(`Beeblebrox;42)
`name`iq!(`Prefect;126)
`Slaartibartfast
110
</code></pre>
</div>
<p>Tables having <strong>exactly</strong> the same <a href="https://code.kx.com/q/ref/meta/"><code>meta</code></a> result can be joined to form a table. Since a table is a list of records, the result is obtained by appending the records of the right operand to those of the left.</p>
<pre class="highlight"><code class="language-q">q)t,([] name:1#`W; iq:1#26)
_
q)t,t
_</code></pre>
<p>Two tables with the same columns in different order can not be joined because the order of columns is significant in q.</p>
<pre class="highlight"><code class="language-q">q)t,([] iq:1#42; name:`W)
'mismatch</code></pre>
<div class="admonition note">
<p class="admonition-title">Later versions of kdb+ do not signal a mismatch. <em>[Ed.]</em></p>
</div>
<p>Two keyed tables with the same <code>meta</code> result can be joined with <code>,</code>. Because a keyed table is a dictionary whose keys and values are record lists, the operation has upsert semantics. Keys in the right operand that are not in the left operand are treated as append (i.e., insert), whereas the right operand acts as an update on common key values. In other words, the right operand is upserted into the left.</p>
<pre class="highlight"><code class="language-q">q)kt,([eid:1003 1004] name:`Prefect`W; iq:150 26)
eid | name       iq 
----| --------------
1001| Dent       98 
1002| Beeblebrox 42 
1003| Prefect    150
1004| W          26 </code></pre>
<h3 id="865-coalesce">8.6.5 Coalesce <code>^</code></h3>
<p><a href="https://code.kx.com/q/ref/coalesce/">Coalesce</a> <code>^</code> can be used to merge two keyed tables having the same columns. Its behavior derives from its behavior on dictionaries. For a common key value and a common column, the value of the column in the right keyed table prevails over that of column in the left keyed table, except where the right column is null, in which case the left column value survives. On non-common keys the individual values carry thru.</p>
<p>The behavior of <code>^</code> is the same as <code>,</code> when there are no nulls in a column in the right table.</p>
<pre class="highlight"><code class="language-q">q)([k:`a`b`c] v:10 0N 30)^([k:`a`b`c] v:100 200 0N)
k| v
-| ---
a| 100
b| 200
c| 30
q)([k:`a`b`c`x] v:10 0N 30 40)^([k:`a`b`c`y]; v:100 200 0N 0N)
_</code></pre>
<p>The performance of <code>^</code> is slower than that of <code>,</code> since fields of the right operand must be checked for null.</p>
<h3 id="866-column-join">8.6.6 Column Join</h3>
<p>Two tables with the same number of records can be joined sideways with Join Each (<code>,'</code>) to create a <em>column join</em> in which the columns are aligned in parallel</p>
<pre class="highlight"><code class="language-q">q)([] c1:`a`b`c),'([] c2:100 200 300)
c1 c2 
------
a  100
b  200
c  300</code></pre>
<p>When the column lists of the tables are not disjoint, the operation on the common columns has upsert semantics because each record is a dictionary.</p>
<pre class="highlight"><code class="language-q">q)([] c1:`a`b`c; c2:1 2 3),'([] c2:100 200 300)
c1 c2 
------
a  100
b  200
c  300</code></pre>
<p>A sideways join on keyed tables requires that the key records conform, meaning that the key columns must have identical meta. The columns from the right operand are aligned along common keys and appended elsewhere.</p>
<pre class="highlight"><code class="language-q">q)([k:1 2 3] v1:10 20 30),'([k:3 4 5] v2:1000 2000 3000)
k| v1 v2  
-| -------
1| 10     
2| 20     
3| 30 1000
4|    2000
5|    3000</code></pre>
<h2 id="87-complex-column-data">8.7 Complex Column Data</h2>
<h3 id="871-simple-example">8.7.1 Simple Example</h3>
<p>There is no restriction on the column lists of a table other than they are rectangular. In practice, simple lists are preferable because they are faster, more storage-efficient and are easier to process. There are situations in which it may be convenient to use nested column lists, although far less often than most q programmers seem to think. In general, it is more efficient to flatten columns and then use joins or grouping to create structure on the way out. For those who simply must have nested column structure, we provide examples here.</p>
<p>Suppose we want to keep track of a pair of daily observations, say a low temperature and a high temperature in Hawaii. The normal form stores the low and high values in separate columns with flat lists for rows and columns.</p>
<pre class="highlight"><code class="language-q">q)tf:([] d:2015.01.01 2015.01.02; l:67.9 72.8; h:82.1 88.4)
q)tf 0
_
q)tf `l
_
q)tf `h
_</code></pre>
<p>Alternatively, we can store pairs in a single column, resulting in nested lists for records and columns.</p>
<pre class="highlight"><code class="language-q">q)tp:([] d:2015.01.01 2015.01.02; lh:(67.9 82.10; 72.8 88.4))
q)tp 0
d | 2015.01.01
lh| 67.9 82.1
q)tp `lh
67.9 82.1
72.8 88.4</code></pre>
<p>This example can easily be generalized to the situation of n-tuples. For example, we could store the daily values of a yield curve. Further, the fields can have different length or even different type, although the latter is strongly discouraged as it will not be possible to persist them in kdb+.</p>
<h3 id="872-operations-on-compound-column-data">8.7.2 Operations on Compound Column Data</h3>
<p>The case of a nested column in which all items are simple lists of the same type is handled specially in kdb+. We call this a <em>compound</em> column. There is no requirement that the simple lists all have the same length.</p>
<p>As an example, say we want to analyze the weekly gross revenues for movies and we don't care about the titles (we don't have room to display them here). Since there will be a different number of movies in release each week, the number of observations in each field will vary. An oversimplified time series that fits within the margins looks like the following in which the gross revenues are in millions.</p>
<pre class="highlight"><code class="language-q">q)tm:([] wk:2015.01.01 2015.01.08; rv:(38.92 67.34; 16.99 5.14 128.23 31.69))
q)tm
wk         rv                     
----------------------------------
2015.01.01 38.92 67.34            
2015.01.08 16.99 5.14 128.23 31.69</code></pre>
<p>Storing complex values in a single column in a table enables sophisticated operations to be performed in a single expression, provided you remember:</p>
<div class="admonition tip">
<p class="admonition-title">Nested columns mean iterators. Lots of iterators.</p>
</div>
<p>Using our movie data, we can produce the sorted, the average and high gross for each week in one expression.</p>
<pre class="highlight"><code class="language-q">q)select wk, srt:desc each rv, avgr:avg each rv, hi:max each rv from tm
wk         srt                     avgr    hi    
-------------------------------------------------
2015.01.01 67.34 38.92             53.13   67.34 
2015.01.08 128.23 31.69 16.99 5.14 45.5125 128.23</code></pre>
<p>While sorts and aggregates such as <code>MAX</code> and <code>AVG</code> are standard SQL, think of how you‚Äôd produce the sorted sub list and the aggregates together. In your favorite traditional programming environment, you'll soon discover that you need a sordid list of rows and a loop to unravel it.</p>
<p>Now let‚Äôs compute the drops between the ranked revenue numbers within each week. No loop required in q.</p>
<pre class="highlight"><code class="language-q">q)select wk, drp:neg 1_'deltas each desc each rv from tm
wk         drp             
---------------------------
2015.01.01 ,28.42          
2015.01.08 96.54 14.7 11.85</code></pre>
<h3 id="873-compound-foreign-key">8.7.3 Compound Foreign Key</h3>
<p>A nested column is how to make a foreign key on a compound primary key. We recast the galactic travelers to make a keyed table with common key of last and first name.</p>
<pre class="highlight"><code class="language-q">q)ktc:([lname: `Dent`Beeblebrox`Prefect; fname:`Arthur`Zaphod`Ford]; iq:98 42 126)</code></pre>
<p>We create a details table with a foreign key over <code>ktc</code> by placing the names in the foreign key column.</p>
<pre class="highlight"><code class="language-q">q)tdetails:([] name:`ktc$(`Beeblebrox`Zaphod;`Prefect`Ford;`Beeblebrox`Zaphod); 
    sc:36 126 42)</code></pre>
<p>The columns of <code>ktc</code> are available as virtual columns from <code>tdetails</code>.</p>
<pre class="highlight"><code class="language-q">q)select name.lname, name.iq, sc from tdetails
lname      iq  sc 
------------------
Beeblebrox 42  36 
Prefect    126 126
Beeblebrox 42  42 </code></pre>
<p>When defining the schema of a table with a compound key column, specify the foreign key as a cast of an empty list.</p>
<pre class="highlight"><code class="language-q">q)([] name:`ktc$();sc:`long$())
_</code></pre>
<p>When the foreign key comprises multiple types you also cast the general list with the foreign table in its schema.</p>
<pre class="highlight"><code class="language-q">q)ktc:([k1:1 2 3; k2:2001.01.01 2001.01.02 2001.01.03] v: 1. 2. 3.)
q)tfc:([] fk:`ktc$(); s:`symbol$())
q)tfc,:(`ktc$(1; 2001.01.01); `a)
q)tfc,:(`ktc$(1; 2015.01.01); `a)
'cast</code></pre>
<p>The failure of the cast in the second append is correct; it is enforced referential integrity.</p>
<h2 id="88-attributes">8.8 Attributes</h2>
<p>Attributes are metadata that you attach to lists of special forms. They are also used on a dictionary domain or a table column to speed retrieval for some operations. The q interpreter can make certain optimizations based on the structure of the list implied by the attribute.</p>
<p>Attributes (other than <code>`g#</code>)  are descriptive rather than prescriptive. By this we mean that by applying an attribute you are asserting that the list has a special form, which q will check. It does <strong>not</strong> instruct q to (re)make the list into the special form; that is your job. A list operation that respects the form specified by the attribute leaves the attribute intact (other than <code>`p#</code>), while an operation that breaks the form results in the attribute being removed in the result.</p>
<p>The syntax for applying an attribute is (yet) another <a href="https://code.kx.com/q/ref/set-attribute/" title="Set Attribute">overload of <code>#</code></a>, whose left operand is a symbol specifying the attribute and whose right operand is the target list. </p>
<div class="admonition note">
<p class="admonition-title">The attribute is applied to the target list in place, not on a copy.</p>
</div>
<p>KX says not to expect significant benefit from an attribute for fewer than a million items. This is why attributes are not automatically applied in mundane situations. You should test your use case to see whether applying an attribute provides performance benefit. Do not just apply attributes blindly, as they consume resources.</p>
<h3 id="881-sorted-s">8.8.1 Sorted <code>`s#</code></h3>
<p>Applying the sorted attribute <code>`s#</code> to a simple list indicates that the items of the list are sorted in ascending order; there is no way to indicate a descending sort. When a list has the sorted attribute, linear search is replaced with binary search, which makes certain operations faster ‚Äì for example, <a href="https://code.kx.com/q/ref/find/">Find</a> <code>?</code>, <a href="https://code.kx.com/q/ref/equal/">Equal</a> <code>=</code>, <a href="https://code.kx.com/q/ref/in/"><code>in</code></a> and <a href="https://code.kx.com/q/ref/within/"><code>within</code></a>.</p>
<p>When an attribute is successfully applied to a list, it becomes part of the list and is displayed on the q console. Observe that q checks to see that the list is actually sorted when the attribute is applied.</p>
<pre class="highlight"><code class="language-q">q)`s#1 2 4 8
`s#1 2 4 8
q)`s#2 1 3 4
's-fail</code></pre>
<p>The sort function <a href="https://code.kx.com/q/ref/asc/"><code>asc</code></a> automatically applies the sorted attribute to its result but <a href="https://code.kx.com/q/ref/til/"><code>til</code></a> does not.</p>
<pre class="highlight"><code class="language-q">q)asc 2 1 8 4
`s#1 2 4 8
q)til 5
0 1 2 3 4</code></pre>
<p>When a list with an attribute is amended with <code>,:</code> the result is checked to see that the attribute is preserved; if not, it is removed.</p>
<pre class="highlight"><code class="language-q">q)L:`s#1 2 3 4 5
q)L,:6
q)L
_
q)L,:0
q)L
_</code></pre>
<p>One place to apply the sorted attribute is on the date or time column of a simple time series.</p>
<pre class="highlight"><code class="language-q">q)t:([] ti:`s#00:00:00 00:00:01 00:00:03; v:98 98 100.)
q)meta t
c | t f a
--| -----
ti| v   s
v | f    </code></pre>
<p>Applying the sorted attribute to a table unintuitively applies the parted attribute (see next section) to the first column.</p>
<pre class="highlight"><code class="language-q">q)meta `s#([] ti:00:00:00 00:00:01 00:00:03; v:98 98 100.)
c | t f a
--| -----
ti| v   p
v | f    </code></pre>
<p>Applying the sorted attribute to a dictionary applies the attribute to the key list. Lookup is faster because binary search is used. A side effect of the way binary search is implemented is that the mapping given by the dictionary is now a step function, meaning that values between successive key values are "filled in."</p>
<pre class="highlight"><code class="language-q">q)d:`s#10 20 30 40 50!`a`b`c`d`e
q)key d
`s#10 20 30 40 50
q)d 10
`a
q)d 12
`a
q)d 15
_
q)d 20
`b</code></pre>
<p>Since a keyed table is a dictionary of tables, applying the sorted attribute to a keyed table applies to the table of keys that, in turn, applies to the initial key column.</p>
<pre class="highlight"><code class="language-q">q)meta `s#([k:1 2 3 4] v:`d`c`b`a)
c| t f a
-| -----
k| j   s
v| s    </code></pre>
<h3 id="882-unique-u">8.8.2 Unique <code>`u#</code></h3>
<p>Applying the unique attribute <code>`u#</code> to a list indicates that the items of the list are distinct. Knowing that the elements of a list are unique makes <a href="https://code.kx.com/q/ref/distinct/"><code>distinct</code></a> the identity function and shortens some operations ‚Äì i.e., if an operation has found one of what you‚Äôre looking for, it‚Äôs done. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Applying <code>`u#</code> essentially causes q to create a hash table, which uses storage and adds overhead. It is best to apply the attribute after the list has been created, if possible. If you have a column that will always have unique values and your large table does not change often, you can get a significant performance speedup with <code>`u#</code>.</p>
</div>
<p>Observe that uniqueness is checked. Don‚Äôt take the error message personally.</p>
<pre class="highlight"><code class="language-q">q)`u#2 1 4 8
`u#2 1 4 8
q)`u#2 1 4 8 2
'u-fail</code></pre>
<p>An amend that does not preserve uniqueness causes the attribute to be lost.</p>
<pre class="highlight"><code class="language-q">q)L:`u#2 1 4 8
q)L,:3
q)L
_
q)L,:2
q)L
2 1 4 8 3 2</code></pre>
<p>The unique attribute can be applied to the domain of a dictionary, a column of a table, or the key column of a keyed table. It cannot be applied to a dictionary, a table or a keyed table directly.</p>
<h3 id="883-parted-p">8.8.3 Parted <code>`p#</code></h3>
<p>The parted attribute <code>`p#</code> indicates that all common occurrences of any value in a list are adjacent. Viewing the list as a map, the parted attribute says that its graph is a step function with distinct steps. The parted attribute can be applied to a simple list of any type whose underlying value is integral ‚Äì e.g., the integer types, dates, times, timestamps, timespans. You can also apply parted on a list of enumerated symbols since the underlying index values are integral.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The parted attribute causes q to create an underlying structure that keeps track of the steps. Because the attribute is not preserved under most operations you should apply it only after the list is fully created. One exception is that when two lists have <code>`p#</code> and their values are disjoint, the attribute will be preserved when the lists are joined with <code>,</code>.</p>
</div>
<p>Here is a simple example of a parted list. Notice that the items are neither sorted nor unique.</p>
<pre class="highlight"><code class="language-q">q)`p#2 2 2 1 1 4 4 4 4 3 3
`p#2 2 2 1 1 4 4 4 4 3 3</code></pre>
<p>Notice that the rather nasty error does not say <code>'p-fail</code>; rather it contains a <code>'u-fail</code> error.</p>
<pre class="highlight"><code class="language-q">q)`p#2 2 2 1 1 4 4 4 4 3 3 2
k){$[3=x;(`#y;`u#y i;(i:&amp;~=':y),#y);(y;`u#!r;+\0,#:'x;,/x:. r:=y)]}
'u-fail
#
`u
2 1 4 3 2
q.o))</code></pre>
<p>With the exception in the note above, the parted attribute is <strong>not</strong> preserved under any operation on the list, even if the operation preserves the property.</p>
<pre class="highlight"><code class="language-q">q)L:`p#1 1 2 3 3
q)L
_
q)L,:3
q)L
1 1 2 3 3 3</code></pre>
<p>Historical time-series databases for ticker symbols are usually sorted by time within symbol with the parted attribute applied to the (enumerated) symbol column. This makes queries by ticker fast and guarantees that results for a given symbol are returned in time order.</p>
<h3 id="884-grouped-g">8.8.4 Grouped <code>`g#</code></h3>
<p>The grouped attribute <code>`g#</code> differs from other attributes in that it can be applied to any list. It causes q to create and maintain an index ‚Äì essentially a hash table. Grouped can be applied to a list when no other assumptions about its structure can be made.</p>
<p>For example,</p>
<pre class="highlight"><code class="language-q">q)`g#1 2 3 2 3 4 3 4 5 2 3 4 5 4 3 5 6
_
q)L:`g#100?100
q)L
_
q)L,:1 1 1 1
q)L
_</code></pre>
<p>The grouped attribute is maintained as operations are performed on the list, which can cause significant processing overhead in addition to the storage required. Best to apply it after the entire list has been created, if possible.</p>
<p>Applying the grouped attribute to a table column roughly corresponds to placing an index on a column in an RDBMS. As of this writing (Sep 2015), in q3.2 the maximum number of grouped attributes that can be placed on a single table is unlimited.</p>
<h3 id="885-remove-attribute">8.8.5 Remove Attribute <code>`#</code></h3>
<p>The operations <code>`#</code> removes any attribute that may currently be applied. For example,</p>
<pre class="highlight"><code class="language-q">q)L:`s#til 10
q)L
_
q)`#L
_</code></pre>
                


                
              
              
                


              
            </article>
            
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))for(var set of document.querySelectorAll("[data-tabs]")){var labels=set.querySelectorAll(":scope > label");e:for(var tab of tabs)for(var label of labels)if(label.innerText.trim()===tab){var input=label.previousElementSibling;input.checked=!0;break e}}</script>

          </div>
        </div>
        
          
        
      
                </div>
            </section>
        
            <section class="chapter" id="chapter-14">
                <div class="chapter-header">
                    <h1 class="chapter-title">9. Queries: q-sql¬∂</h1>
                    <div class="chapter-meta">
                        <span>üìñ Source: <a href="https://code.kx.com/q4m3/9_Queries_q-sql/">https://code.kx.com/q4m3/9_Queries_q-sql/</a></span>
                        <span>üìù 14490 words</span>
                        
                    </div>
                </div>
                <div class="chapter-content">
                    
        <div class="md-main__inner md-grid">
          
            
              
              
            
            
              
              
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                
                <h1 id="9-queries-q-sql">9. Queries: q-sql</h1>
<h2 id="90-overview">9.0 Overview</h2>
<p>We call the collection of functions for manipulating tables <em>q-sql</em>, since many of them resemble their SQL counterparts in form or function. The usual suspects such as <em>insert</em>, <em>select</em>, <em>update</em>, are present, as well as functionality that is not available in traditional SQL. But appearances can be deceiving: there are some significant differences in the syntax and behavior.</p>
<p>The first important difference is that a q table has ordered rows and columns. This is particularly useful when dealing with the situation where records arrive in time order. Appending them to a table ensures that they enter ‚Äì and stay ‚Äì in order. Subsequent select operations always retrieve the records in order without any need for sorting.</p>
<p>A second difference is that a q table is stored physically as a collection of column lists. This means that operations on column data are vector operations. Moreover, for simple column lists, atomic, aggregate and uniform functions applied to columns are especially simple and fast since they reduce to direct memory addressing.</p>
<p>A third difference is that q-sql provides upsert semantics. Recall that upsert semantics on a dictionary mean that when a key-value pair is applied with <a href="https://code.kx.com/q/ref/join/" title="Join"><code>,</code></a> and the key is present, the value is updated; otherwise the pair is inserted. In the context of tables and keyed tables, which are both dictionaries, this has far-reaching consequences for many common operations, including joins. Upsert semantics permeate q-sql.</p>
<p>In this chapter, we cover the important features of q-sql, beginning with simple examples for each. Eventually more complex examples are introduced.</p>
<p>Some examples are based on the <code>sp.q</code> script included in the q installation files. Tables in the script are,</p>
<pre class="highlight"><code class="language-q">q)meta s
c     | t f a
------| -----
s     | s
name  | s
status| j
city  | s
q)meta p
c     | t f a
------| -----
p     | s
name  | s
color | s
weight| j
city | s
q)meta sp
c  | t f a
---| -----
s  | s s
p  | s p
qty| j</code></pre>
<p>You should <a href="https://code.kx.com/q4m3/13_Commands_and_System_Variables/#13111-load-l">load</a> and display these tables in your console session now.</p>
<h2 id="91-inserting-records">9.1 Inserting Records</h2>
<p>There are multiple ways to insert ‚Äì i.e., append ‚Äì records in q.</p>
<div class="admonition tip">
<p class="admonition-title">The <code>upsert</code> function is superior to <code>insert</code> and is to be preferred. We include <code>insert</code> for nostalgia only.</p>
</div>
<h3 id="910-append-using-assign">9.1.0 Append Using Assign</h3>
<p>Since a table is (logically) a list of records, it is possible to append records in place using <code>,:</code>. Type checking on field values is performed.</p>
<pre class="highlight"><code class="language-q">q)t:([] name:`symbol$(); iq:`int$())
q)t,:`name`iq!(`Beeblebrox; 42)
q)t,:`name`iq!(`Dent; 98.0)
'type</code></pre>
<p><em>Assign</em> can also be used with a row of naked field values provided the fields align exactly with the target columns.</p>
<pre class="highlight"><code class="language-q">q)t,:(`Prefect; 126)</code></pre>
<p>Applying Assign to a table repeatedly with the same argument results in duplicate records.</p>
<pre class="highlight"><code class="language-q">q)t,:(`Prefect; 126)
q)t,:(`Prefect; 126)
q)t
_</code></pre>
<p>You can use Assign to append to a keyed table using the full record form, but you will quickly see why no one does this.</p>
<pre class="highlight"><code class="language-q">q)kt:([eid:`long$()] name:`symbol$(); iq:`long$())
q)kt,:(enlist (enlist `eid)!enlist 1001)!enlist `name`iq!(`Beeblebrox; 42)</code></pre>
<p>It is much easier to use naked field values, provided they align exactly with both the key and value columns.</p>
<pre class="highlight"><code class="language-q">q)kt,:(1002; `Dent; 98)
q)kt
_</code></pre>
<p>Assign has upsert semantics on keyed tables, so repeated operation on the same key will retain only the last values.</p>
<pre class="highlight"><code class="language-q">q)kt,:(1002; `Dent; 101)
q)kt
_</code></pre>
<h3 id="911-basic-insert">9.1.1 Basic insert</h3>
<p>Those who prefer the familiarity of SQL can append records to an existing global table using the binary function <a href="https://code.kx.com/q/ref/insert/"><code>insert</code></a> whose left operand is a symbol containing the name of a <strong>global</strong> table (<em>target</em>) and whose right argument is a record, or list of records, conforming to the target. The result is a list of integers representing the row number(s) of the appended record(s).</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Since <code>insert</code> essentially reduces to amend in place, fields are type checked.</p>
<ul>
<li>If the target column is simple, the type must match exactly.</li>
<li>If the target column is an untyped empty list, the result will take the type of the field in the initial <code>insert</code>.</li>
</ul>
</div>
<p>For a regular ‚Äì i.e., non-keyed ‚Äì table, the effect of <code>insert</code> is to append a new record with the specified field values. Let‚Äôs use our simple example.</p>
<pre class="highlight"><code class="language-q">q)t:([] name:`Dent`Beeblebrox`Prefect; iq:42 98 126)</code></pre>
<p>Here is how to insert a single record or the equivalent row list.</p>
<pre class="highlight"><code class="language-q">q)`t insert (`name`iq)!(`Slartibartfast; 134)
,3
q)`t insert (`Marvin; 150)
,4
q)t
_</code></pre>
<p>Repeatedly applying <code>insert</code> to a table with the same argument results in duplicate records.</p>
<pre class="highlight"><code class="language-q">q)`t insert (`Marvin; 150)
_
q)`t insert (`Marvin; 150)
_
q)
_</code></pre>
<p>Since a list of conforming records is a table, inserting a list of records is the same as inserting a table. Observe that use of <code>3#</code> to truncate the table.</p>
<pre class="highlight"><code class="language-q">q)t:3#t
q)`t insert (`name`iq!(`Slartibartfast; 134); (`name`iq!(`Marvin; 200)))
_
q)t
_
q)t:3#t
q)`t insert ([] name:`Slartibartfast`Marvin; iq:134 200)
_</code></pre>
<p>You can also use <code>insert</code> in prefix form, possibly with the table name projected. For example, the previous insert can be written as,</p>
<pre class="highlight"><code class="language-q">q)insert[`t; (`Slartibartfast; 134)]
_
q)insert[`t;] (`Slartibartfast; 134)
_</code></pre>
<h3 id="912-bulk-columnar-insert">9.1.2 Bulk Columnar Insert</h3>
<p>We have seen that it is possible to insert a naked list of row values instead of the full record dictionary. We have also seen that it is possible to bulk insert a list of conforming records, which is just a table with the same schema as the target.</p>
<p>It is also possible to bulk insert naked field values but there is a twist. To bulk insert naked field values, you provide a list of <strong>columns</strong> not a list of rows.</p>
<pre class="highlight"><code class="language-q">q)t:([] name:`Dent`Beeblebrox; iq:98 42)
q)`t insert ((`Prefect; 126); (`Marvin; 200))
'type
q)`t insert (`Prefect`Marvin; 126 200)
8 9</code></pre>
<p>After a brief q Zen meditation, you will realize that this is consistent with the previous bulk insert of a table, since a table is a collection of columns. From this perspective, we should view the insertion of a single naked row more correctly as a trivial list of column atoms.</p>
<h3 id="913-insert-into-empty-tables">9.1.3 Insert into Empty Tables</h3>
<p>Inserting into a table that has been initialized with empty lists of general type causes the result table to take the type of the first record inserted. In particular, an atomic field in the inserted record results in a simple column with its type.</p>
<pre class="highlight"><code class="language-q">q)t:([] name:(); iq:())
q)`t insert (`Dent;98)
,0
q)meta t
c   | t f a
----| -----
name| s
iq  | j</code></pre>
<p>This is fine as long as all the types in the initial record are correct. Should any field have an unintended type, subsequent records of the correct type will all be rejected.</p>
<pre class="highlight"><code class="language-q">q)t:([] name:(); iq:())
q)`t insert (`Dent;98.0)
,0
q)`t insert (`Beeblebrox; 42)
'type</code></pre>
<div class="admonition tip">
<p class="admonition-title">Recommendation</p>
<p>It is good practice to type all columns in an empty table. This will ensure that incorrect types are rejected and correct ones accepted.</p>
<pre><code class="language-q">
 q)t:([] name:`symbol$(); iq:`int$())
 q)`t insert (`Dent;98.0)
 'type
 q)`t insert (`Beeblebrox; 42)
 ,0
</code></pre>
</div>
<p>It is also possible to insert a <strong>list</strong> of conforming records (i.e., a table) into a table that does not exist. This is the same as assigning the table to a variable of the specified name.</p>
<pre class="highlight"><code class="language-q">q)tnew
'tnew
q)`tnew insert enlist `c1`c2!(`a; 10)
_
q)tnew
_</code></pre>
<h3 id="914-insert-and-foreign-keys">9.1.4 Insert and Foreign Keys</h3>
<p>When inserting data into a table that has foreign key(s), the values destined for the foreign key column(s) are checked to ensure that they appear in the primary key column(s) pointed to by the foreign key(s). This is referential integrity (well, half of it).</p>
<p>Returning to our previous foreign-key example.</p>
<pre class="highlight"><code class="language-q">q)kt:([eid:1001 1002 1003] name:`Dent`Beeblebrox`Prefect; iq:98 42 126)
q)tdetails:([] eid:`kt$1003 1002 1001 1002 1001; sc:126 36 92 39 98)</code></pre>
<p>The first insert in the following succeeds but the second fails when trying to enumerate the foreign-key value 1042 that does not appear in <code>kt</code>.</p>
<pre class="highlight"><code class="language-q">q)`tdetails insert (1002;42)
,5
q)`tdetails insert (1042;150)
'cast</code></pre>
<p>Recall that enumeration is a form of cast.</p>
<h3 id="915-insert-into-keyed-tables">9.1.5 Insert into Keyed Tables</h3>
<p>You can use <code>insert</code> to append data to a keyed table, but this probably does not have the desired semantics. Specifically, you can insert into a keyed table only if the key value is <strong>not</strong> already in the table. For this and other reasons, <code>upsert</code> should normally be preferred over <code>insert</code>.</p>
<p>Since a keyed table is a dictionary, to use <code>insert</code> we should properly provide a dictionary entry comprising a key record and a value record.</p>
<pre class="highlight"><code class="language-q">q)kt:([eid:1001 1002] name:`Dent`Beeblebrox; iq:98 42)
q)`kt insert (enlist ((enlist `eid)!enlist 1003))!enlist `name`iq!(`W; 21)
,2</code></pre>
<p>Yikes! Nobody does this. Instead, you provide a list of raw field values with the proviso that they align exactly across the key and value columns.</p>
<pre class="highlight"><code class="language-q">q)`kt insert (1005; `Marvin; 200)
,3
q)`kt insert (1004;`Slartibartfast;158)
,4</code></pre>
<p>Repeating the last insert now fails because the key value 1004 already exists.</p>
<pre class="highlight"><code class="language-q">q)`kt insert (1004; `Marvin; 200)
'insert</code></pre>
<div class="admonition tip">
<p class="admonition-title">The records in the keyed table are stored in insert order rather than key order.</p>
</div>
<pre class="highlight"><code class="language-q"> q)kt
 _</code></pre>
<h2 id="92-upsert">9.2 Upsert</h2>
<p>The <a href="https://code.kx.com/q/ref/upsert/"><code>upsert</code></a> template is like <code>insert</code>, only better. Except for the last sub-section on keyed tables, all the examples in the previous section all work the same for <code>upsert</code>.</p>
<h3 id="921-upsert-replacing-insert">9.2.1 Upsert Replacing Insert</h3>
<p>Here we repeat some examples from the previous section to demonstrate that <code>upsert</code> can (and should) be used in place of <code>insert</code> for appending rows to a table.</p>
<pre class="highlight"><code class="language-q">q)t:([] name:`Dent`Beeblebrox`Prefect; iq:42 98 126)
q)`t upsert (`name`iq)!(`Slartibartfast; 134)
`t
q)`t upsert (`Marvin; 150)
_
q)`t upsert ([] name:`Slartibartfast`Marvin; iq:134 200)
_
q)t:3#t
q)upsert[`t; (`Slartibartfast; 134)]
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>To bulk upsert naked field values, use rows instead of columns.
</p><pre><code class="language-q">
 q)t upsert ((`Prefect; 126); (`Marvin; 200))
 _
</code></pre>
</div>
<h3 id="922-upsert-by-name">9.2.2 Upsert by Name</h3>
<p>A limitation of <code>insert</code> is that it uses pass-by-name, so it can only operate against global tables. In contrast, <code>upsert</code> supports both pass-by-name and pass-by-value. Thus it can be used with anonymous or local tables.</p>
<pre class="highlight"><code class="language-q">q)([] c1:`a`b; c2:10 20) upsert (`c; 30)
c1 c2
-----
a  10
b  20
c  30
q)f:{t:([] c1:`a`b; c2:10 20); t upsert x}
q)f (`c; 30)
c1 c2
-----
a  10
b  20
c  30</code></pre>
<h3 id="923-upsert-on-keyed-tables">9.2.3 Upsert on Keyed Tables</h3>
<p>We have seen that <code>insert</code> has undesirable semantics on keyed tables ‚Äì i.e., it rejects ‚Äúduplicate‚Äù keys. What we really want is, well, upsert semantics.</p>
<pre class="highlight"><code class="language-q">q)`kt upsert (1001; `Beeblebrox; 42)
_
q)`kt upsert (1001; `Beeblebrox; 43)
_
q)kt
eid | name iq
----| -------------
1001| Beeblebrox 43</code></pre>
<p>This is the second reason to use <code>upsert</code> instead of <code>insert</code>.</p>
<h3 id="924-upsert-on-persisted-tables">9.2.4 Upsert on Persisted Tables</h3>
<p>You can use <code>upsert</code> to append records to serialized and <a href="https://code.kx.com/q/kb/splayed-tables/">splayed tables</a>. Simply pass the handle of the file or splayed directory as the name of the table. This is the final strike against <code>insert</code>, since it cannot do this.</p>
<p>We serialize a table and then append a row to it.</p>
<pre class="highlight"><code class="language-q">q)`:/q4m/tser set ([] c1:`a`b; c2:1.1 2.2)
q)`:/q4m/tser upsert (`c; 3.3)
`:/q4m/tser
q)get `:/q4m/tser
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Upserting to a serialized table reads the entire table into memory, updates it and writes out the result.</p>
</div>
<p>Next we splay a table and then append a row to it. Observe that we ensure that all symbols are enumerated, as required for splayed tables.</p>
<pre class="highlight"><code class="language-q">q)`:/q4m/tsplay/ set ([] c1:`sym?`a`b; c2:1.1 2.2)
`:/q4m/tsplay/
q)`:/q4m/tsplay upsert (`sym?`c; 3.3)
`:/q4m/tsplay
q)select from `:/q4m/tsplay
_</code></pre>
<p>Upserting to a splayed table does <strong>not</strong> read the persisted image into memory; rather, it appends to the ends of the column files. This allows incremental creation of large splayed (or partitioned) tables by upserting chunks that comfortably fit into memory. See <a href="https://code.kx.com/q4m3/11_IO/#113-splayed-tables">¬ß11.3</a> for more details on splayed tables.</p>
<div class="admonition tip">
<p class="admonition-title">Upserting to a table in either form will destroy any attributes on table columns. You will have to reapply them.</p>
</div>
<h2 id="93-the-select-template">9.3 The <code>select</code> Template</h2>
<p>In this section we investigate the general form of <a href="https://code.kx.com/q/ref/select/"><code>select</code></a>, which like all q-sql templates, has required and optional elements. The template elements contain phrases that are expressions (presumably) involving column values of a specified table. The template is converted by the interpreter into a functional form and is applied against the table to produce a result table. While the syntax and behavior of <code>select</code> resemble the analogous SQL statement, the underlying mechanics are quite different.</p>
<div class="admonition important">
<p class="admonition-title">The result of <code>select</code> is always a table.</p>
</div>
<p>We examine each of the constituents of <code>select</code> in detail. We introduce the concepts with illustrative examples using trivial tables so that the basic mechanics are not obscured by large or complex data.</p>
<h3 id="931-syntax">9.3.1 Syntax</h3>
<p>The <code>select</code> template has the following form, where elements enclosed in matching angle brackets <code>&lt;...&gt;</code> are optional.</p>
<p><code>select</code> &lt;<em>p<sub>s</sub></em>&gt; &lt;<code>by</code> <em>p<sub>b</sub></em>&gt; <code>from</code> <em>t<sub>exp</sub></em> &lt;<code>where</code> <em>p<sub>w</sub></em>&gt;</p>
<p>The <code>select</code> and <code>from</code> keywords are required; omission or mistyping either results in an error. The table expression <em>t<sub>exp</sub></em>, which is any q expression whose value is a table or keyed table, is also required. The remaining elements <em>p<sub>s</sub></em>, <em>p<sub>b</sub></em> and <em>p<sub>w</sub></em> are optional. They are called the Select, the By and the Where phrases, respectively.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>If <code>where</code> is present and t<sub>exp</sub> is itself a select expression, the inner expression should be enclosed in parentheses to avoid confusion in the binding of the Where phrase.</p>
</div>
<p>Each phrase in the select template is a comma-separated list of subphrases. A <em>subphrase</em> is an arbitrary q expression (presumably) involving columns of <em>t<sub>exp</sub></em> or columns of another table accessed via foreign key. The evaluation of subphrases within a phrase is sequenced left-to-right by the commas, but each subphrase expression is evaluated right-to-left, like any q expression.</p>
<div class="admonition warning">
<p class="admonition-title">Commas</p>
<p>The commas separating the subphrases are separators, so it is not necessary to enclose a subphrase in parentheses unless the expression contains the Join operator <code>,</code>. Any expression containing the operator <code>,</code> within any template phrase must be enclosed in parentheses or it will be interpreted as the separator. Forgetting this is both easy and painful.</p>
</div>
<p>The order of evaluation of the <code>select</code> template is:</p>
<ol>
<li>
<p>From expression <em>t<sub>exp</sub></em></p>
</li>
<li>
<p>Where phrase <em>p<sub>w</sub></em></p>
</li>
<li>
<p>By phrase <em>p<sub>b</sub></em></p>
</li>
<li>
<p>Select phrase <em>p<sub>s</sub></em></p>
</li>
</ol>
<h3 id="932-the-select-phrase">9.3.2 The Select Phrase</h3>
<p>We begin our examples with the Select phrase because it is the easiest. We shall use the following table for our examples.</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:`a`b`c; c2:10 20 30; c3:1.1 2.2 3.3)</code></pre>
<p>The Select phrase specifies the columns in the result table, one per subphrase. If the Select phrase <em>p<sub>s</sub></em> is absent, all columns are returned. There is no need for the <code>*</code> wildcard of SQL.</p>
<pre class="highlight"><code class="language-q">q)select from t
_
q)t~select from t
1b</code></pre>
<p>To specify result columns, list them separated by commas. Whitespace after commas is optional but some think it improves readability, especially for complicated queries.</p>
<pre class="highlight"><code class="language-q">q)select c1, c3 from t
_</code></pre>
<h3 id="9321-result-column-names">9.3.2.1 Result Column Names</h3>
<p>To specify names for the result columns, place the name followed by colon before the subphrase.</p>
<pre class="highlight"><code class="language-q">q)select c1, res:2*c2 from t
c1 res
------
a  20
b  40
c  60</code></pre>
<p><strong>Notes</strong></p>
<ul>
<li>The colon used to specify a name is <strong>not</strong> assignment; it is simply part of the syntax of the template.</li>
<li>Just as with the use of colon in a variable assignment, the column name is part of the syntactic sugar. It is not a symbol and <strong>cannot</strong> be parameterized. Use functional form if you need this ‚Äì see <a href="#912-functional-forms">¬ß9.12</a>.</li>
<li>Unlike in SQL, columns in the Select phrase do not actually exist until the final result table is returned. Thus a computed column <strong>cannot</strong> be used in other column expressions.</li>
</ul>
<p>If you do not provide a name for a computed column, q determines one.</p>
<ul>
<li>Normally the name is taken from the left-most term in the column expression.</li>
<li>When q cannot determine a name it uses <code>x</code>.</li>
<li>If q‚Äôs chosen name duplicates a previously determined column name, it will suffix it with <code>1</code>, <code>2</code>, etc. to make it unique. Recall that columns are sequenced from left to right.</li>
</ul>
<pre class="highlight"><code class="language-q">q)select c1, c1, 2*c2, c2+c3, string c3 from t
c1 c11 x  c2   c3
--------------------
a  a   20 11.1 "1.1"
b  b   40 22.2 "2.2"
c  c   60 33.3 "3.3"</code></pre>
<h3 id="9322-the-virtual-column-i">9.3.2.2 The Virtual Column <code>i</code></h3>
<p>A virtual column <code>i</code> represents the offset of each record in the table ‚Äì i.e., <code>i</code> is the row number. It is implicitly available in the Select phrase.</p>
<pre class="highlight"><code class="language-q">q)select i, c1 from t
x c1
----
0 a
1 b
2 c</code></pre>
<p>Observe that <code>select</code> does not carry the name <code>i</code> into the result.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>You can name the result column <code>ix</code> to avoid confusion with the always-present virtual column <code>i</code>.</p>
<pre><code class="language-q">
 q)select ix:i, c1 from t
 _
</code></pre>
</div>
<h3 id="9323-select-distinct">9.3.2.3 <code>select distinct</code></h3>
<p>The special form <code>select distinct</code> returns only unique records in the result ‚Äì i.e., it eliminates duplicates.</p>
<pre class="highlight"><code class="language-q">q)select distinct from ([] c1:`a`b`a; c2:10 20 10)
c1 c2
-----
a  10
b  20</code></pre>
<h3 id="9324-select">9.3.2.4 <code>select[]</code></h3>
<p>You can return the first or last <em>n</em> records in a select by using function parameter syntax after <code>select</code>. A positive integer parameter returns the first records, a negative parameter the last.</p>
<pre class="highlight"><code class="language-q">q)select[2] from s where city&lt;&gt;`athens
s | name status city
--| -------------------
s1| smith 20 london
s2| jones 10 paris

q)select[-1] from s where city&lt;&gt;`athens
s | name status city
--| -------------------
s4| clark 20 london</code></pre>
<p>We could achieve the same result using <a href="https://code.kx.com/q/ref/take/" title="Take"><code>#</code></a> after the <code>select</code> (i.e., to its left).</p>
<pre class="highlight"><code class="language-q">q)2#select from s where city&lt;&gt;`athens
_
q)-1#select from s where city&lt;&gt;`athens
_</code></pre>
<p>The difference is that the <code>#</code> construct requires computing the entire result set and then keeping only the desired rows, whereas <code>select[n]</code> only extracts the desired number of rows. The latter will be faster and consume less memory for large tables.</p>
<p>This syntax is extended to <code>select[n m]</code> where <code>n</code> is the starting row number and <code>m</code> is the number of rows.</p>
<pre class="highlight"><code class="language-q">q)select[1 2] from s where city&lt;&gt;`athens
_</code></pre>
<p>One final extension of the syntax specifies a sorting criterion inside the brackets. For ascending sort, place <code>&lt;</code> before a column name and for descending sort use <code>&gt;</code>.</p>
<pre class="highlight"><code class="language-q">q)select[&gt;name] from s where city&lt;&gt;`athens
_
q)select[&lt;city] from s where city&lt;&gt;`athens
_</code></pre>
<p>You can combine the two syntax extensions by separating them with a semicolon.</p>
<pre class="highlight"><code class="language-q">q)select[2; &gt;name] from s where city&lt;&gt;`athens
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">The items inside the brackets must be in this order.</p>
</div>
<h3 id="9325-select-on-nested-columns">9.3.2.5 Select on Nested Columns</h3>
<p>You can use <code>select</code> on tables with nested columns but things become more complicated. The rule of thumb is that you will need iterators‚Ä¶ lots of iterators.</p>
<p>Let‚Äôs take a simple example.</p>
<pre class="highlight"><code class="language-q">q)show tnest:([] c1:`a`b`c; c2:(10 20 30; enlist 40; 50 60))
c1 c2
-----------
a  10 20 30
b  ,40
c  50 60</code></pre>
<p>What can we do with this table? We <strong>cannot</strong> apply an aggregate or uniform operation straight to <code>c2</code> since the fields do not conform.</p>
<pre class="highlight"><code class="language-q">q)select avg c2 from tnest
'length</code></pre>
<p>We <strong>can</strong> apply an aggregate or uniform function to each field of <code>c2</code> in <code>tnest</code>.</p>
<pre class="highlight"><code class="language-q">q)select avg each c2 from tnest
_</code></pre>
<p>Similarly we can use <a href="https://code.kx.com/q/ref/maps/#each">Each</a> to compute a weighted average using two columns.</p>
<pre class="highlight"><code class="language-q">q)update c3:(1.1 2.2 3.3; enlist 4.4; 5.5 6.6) from `tnest
`tnest
q)select wtavg:c2 wavg' c3 from tnest
_</code></pre>
<h3 id="933-filtering-with-where">9.3.3 Filtering with <code>where</code></h3>
<p>The Where phrase controls which records of the input table are actually used in the query. The effect of the Where phrase is to include only the records that meet its criteria.</p>
<h3 id="9331-basic-where">9.3.3.1 Basic where</h3>
<p>The action generalizes the built-in <a href="https://code.kx.com/q/ref/where"><code>where</code></a> function on lists (See <a href="https://code.kx.com/q4m3/3_Lists/#3123-where">¬ß3.12.3</a>). Recall that a table is logically a list of records.</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:`a`b`c; c2:10 20 30; c3:1.1 2.2 3.3)
q)t where t[`c2]&gt;15
c1 c2 c3
---------
b  20 2.2
c  30 3.3
q)select from t where c2&gt;15
_</code></pre>
<p>In fact, you can provide a boolean list to <code>where</code>.</p>
<pre class="highlight"><code class="language-q">q)select from t where 011b
_</code></pre>
<h3 id="9332-the-virtual-column-i-in-where">9.3.3.2 The Virtual Column <code>i</code> in <code>where</code></h3>
<p>The virtual column <code>i</code> is useful for paginating a table. Use <code>within</code>, which returns a boolean indicating whether the left operand is in the closed interval specified in the right operand, to determine the bounds of the page.</p>
<pre class="highlight"><code class="language-q">q)tbig:100#t
q)select from tbig where i within 50 99
_</code></pre>
<p>To use this construct with non-literal values as the endpoints, you <strong>must</strong> use general-list notation, since simple-list notation cannot be used with variables.</p>
<pre class="highlight"><code class="language-q">q)s:50
q)e:99
q)select from tbig where i within (s;e)
_</code></pre>
<h3 id="9333-multiple-where-subphrases">9.3.3.3 Multiple Where Subphrases</h3>
<p>Each Where subphrase is a predicate expression that produces a boolean result vector corresponding to records passing or failing a criterion. The <strong>logical</strong> effect of multiple subphrases is to join them with ‚Äúand‚Äù. Note that the parentheses are necessary in the second query.</p>
<pre class="highlight"><code class="language-q">q)r1:select from t where c2&gt;15,c3&lt;3.0
q)r2:select from t where (c2&gt;15)&amp;c3&lt;3.0
q)r1~r2
1b</code></pre>
<p>However, since the Where subphrases are sequenced from left-to-right, their order affects the actual processing. As each subphrase is applied, only the records it passes are tested in the next subphrase. The net effect is a progressively narrowed sublist of rows to consider. There is often an optimal order that significantly narrows in the first one or few subphrases, which in turn reduces the amount of processing.</p>
<div class="admonition tip">
<p class="admonition-title">Place the most limiting <code>where</code> subphrase first, followed by others in decreasing strictness.</p>
</div>
<p>Consider the following table comprising a million observations of two variables <code>a</code> and <code>b</code> taken every millisecond starting at midnight. On the author‚Äôs laptop, the version of the query that narrows the time interval first executes in under a millisecond whereas the one specifying the variable name first takes 15 milliseconds.</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:00:00:00.000+til 1000000;c2:1000000?`a`b;c3:1000000?100.)
q)\t select from t where c1 within 00:00:01.000 00:00:01.999, c2=`a
0
q)\t select from t where c2=`a, c1 within 00:00:01.000 00:00:01.999
15</code></pre>
<h3 id="9334-nested-columns-in-where">9.3.3.4 Nested Columns in Where</h3>
<p>Nested columns generally require iterators, and the Where phrase is no different. A common mistake made by qbies is, when trying to find a specific string in a column of strings, they forget that strings are not first-class in q.</p>
<pre class="highlight"><code class="language-q">q)t:([] f:1.1 2.2 3.3; s:("abc";enlist "d";"ef"))
q)select from t where s="ef"
'length
=
q)select from t where s~"ef"
f s
---
q)select from t where s~\:"ef"
f s
--------
3.3 "ef"</code></pre>
<p>The first query is in error because it tests atomic equality between a simple list and a nested list. The second query does not achieve the desired result because it asks if the entire column matches the specified string. The final query works because it tests the specified string for match against each string in the column.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>For matching strings, the <a href="https://code.kx.com/q/ref/like/"><code>like</code></a> operator is more efficient. See <a href="https://code.kx.com/q4m3/A_Built-in_Functions/#a45-like">¬ßA.45</a> for a detailed description but we only need the special case that asks if two strings match exactly ‚Äì i.e., no wildcards. The fact that <code>like</code> is pseudo-atomic in the left operand makes it suited for comparing against a column. It is actually faster than the above expression with <code>~\:</code> for large lists.</p>
<pre><code class="language-q">
q)select from t where s like "ef"
_
</code></pre>
</div>
<h3 id="9335-fby-in-where">9.3.3.5 <code>fby</code> in Where</h3>
<p>A common use case in a query is to filter on groups. For example, in the following example using the table <code>p</code> from the distribution samples, we wish to include only the records having the maximum weight in their respective cities. We could start with a correlated subquery.</p>
<pre class="highlight"><code class="language-q">q)select max weight by city from p
city  | weight
------| ------
london| 19
paris | 17
rome  | 17</code></pre>
<p>But you run into the issue of what to do with the other fields in the subquery. Do without aggregation, which loses the information of where the maximum occurs?</p>
<pre class="highlight"><code class="language-q">q)select name, color, max weight by city from p
city  | name           color        weight
------| ----------------------------------
london| `nut`screw`cog `red`red`red 19    
paris | `bolt`cam      `green`blue  17    
rome  | ,`screw        ,`blue       17</code></pre>
<p>Or do you apply other aggregates that will pick values that are uncorrelated with the original?</p>
<pre class="highlight"><code class="language-q">q)select first name, first color, max weight by city from p
city  | name  color weight
------| ------------------
london| nut   red   19    
paris | bolt  green 17    
rome  | screw blue  17</code></pre>
<p>In SQL you would use <code>HAVING</code>, but q is having none of that. Instead use <a href="https://code.kx.com/q/ref/fby"><code>fby</code></a> in the Where phrase. <!-- ‚Äì see <a href="#9335-fby-in-where">¬ß9.3.3.5</a>. FIXME --> Since it returns the value of the aggregate across each group, you simply compare the target column to the <code>fby</code> result to get a boolean vector with <code>1b</code> at precisely the records whose fields match the aggregate on the group.</p>
<p>Used in a Where phrase, <code>fby</code> takes the form</p>
<p>(<em>f<sub>agg</sub></em>;<em>expr<sub>col</sub></em>) <code>fby</code> <em>c</em></p>
<p>The left operand is a two-item list comprising an aggregate function <em>f<sub>agg</sub></em> and a column expression <em>expr<sub>col</sub></em> on which the function will be applied. The right operand <em>c</em> is the column to be grouped.</p>
<p>In our example,</p>
<pre class="highlight"><code class="language-q">q)select from p where weight=(max;weight) fby city
p | name  color weight city  
--| -------------------------
p2| bolt  green 17     paris 
p3| screw blue  17     rome  
p6| cog   red   19     london</code></pre>
<p>Now we include another Where phrase for the desired result.</p>
<pre class="highlight"><code class="language-q">q)select from p where weight=(max;weight) fby city,color=`blue
p | name  color weight city
--| -----------------------
p3| screw blue  17     rome</code></pre>
<p>To group on multiple columns, encapsulate them in an anonymous table in the right operand of <code>fby</code>.</p>
<pre class="highlight"><code class="language-q">q)t:([]sym:`IBM`IBM`MSFT`IBM`MSFT;
    ex:`N`O`N`N`N;
    time:12:10:00 12:30:00 12:45:00 12:50:00 13:30:00;
    price:82.1 81.95 23.45 82.05 23.40)
q)select from t where price=(max;price) fby ([]sym;ex)
sym  ex time     price
----------------------
IBM  N  12:10:00 82.1 
IBM  O  12:30:00 81.95
MSFT N  12:45:00 23.45</code></pre>
<h3 id="934-grouping-and-aggregation">9.3.4 Grouping and Aggregation</h3>
<p>In contrast to SQL, where grouping and aggregation are performed together, in q-sql they are independent. In this section we use the tables defined in the <code>sp.q</code> script included in the distribution.</p>
<pre class="highlight"><code class="language-q">q)p
p | name  color weight city  
--| -------------------------
p1| nut   red   12     london
p2| bolt  green 17     paris 
p3| screw blue  17     rome  
p4| screw red   14     london
p5| cam   blue  12     paris 
p6| cog   red   19     london
q)s
s | name  status city  
--| -------------------
s1| smith 20     london
s2| jones 10     paris 
s3| blake 30     paris 
s4| clark 20     london
s5| adams 30     athens
q)sp
s  p  qty
---------
s1 p1 300
s1 p2 200
s1 p3 400
s1 p4 200
s4 p5 100
s1 p6 100
s2 p1 300
s2 p2 400
s3 p2 200
s4 p2 200
s4 p4 300
s1 p5 400</code></pre>
<h3 id="9341-aggregation-without-grouping">9.3.4.1 Aggregation without Grouping</h3>
<p>When an aggregate function is applied against a column of simple type in the Select phrase, the result is an atom. If all columns in the Select phrase are computed with aggregation and there is no grouping, the result will be a table with a single row ‚Äì e.g., a summary or rollup. While q has many built-in aggregates, you can also define and use your own.</p>
<p>Here we calculate the total and mean order quantity using the built-in aggregates <a href="https://code.kx.com/q/ref/sum/"><code>sum</code></a> and <a href="https://code.kx.com/q/ref/avg/"><code>avg</code></a>.</p>
<pre class="highlight"><code class="language-q">q)select total:sum qty, mean:avg qty from sp
total mean    
--------------
3100  258.3333</code></pre>
<h3 id="9342-grouping-without-aggregation">9.3.4.2 Grouping without Aggregation</h3>
<p>The By phrase groups rows having common values in specified column(s), much like <code>GROUP BY</code> in SQL. The result of a query including a By phrase is a keyed table whose key column(s) are those in the By phrase. This is well-defined because the grouping along like values ensures uniqueness of the keys.</p>
<p>The action of the By phrase is a generalization of the built-in function <a href="https://code.kx.com/q/ref/group/"><code>group</code></a> on lists. (See <a href="https://code.kx.com/q4m3/3_Lists/#3124-group">¬ß3.12.4</a>.) A query that groups without aggregation results in nested columns. One way to think of this is that each group of values is folded into a single field in the result.</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:`a`b`a`b`c; c2:10 20 30 40 50)
q)t[`c2] group t[`c1]
a| 10 30
b| 20 40
c| ,50
q)select c2 by c1 from t
c1| c2
--| -----
a | 10 30
b | 20 40
c | ,50</code></pre>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Grouping without aggregation is the most common way qbies unintentionally create nested columns. Nested columns are slower, more cumbersome to use (they require a heavy dose of iterators) and are usually unnecessary. And you can‚Äôt just cast a nested column to a simple one; you must apply an aggregate or some other operation that flattens a list.</p>
</div>
<p>Observe that <a href="https://code.kx.com/q/ref/ungroup/"><code>ungroup</code></a> can be used to reverse the nested result of grouping without aggregation. It is not quite an inverse since it returns the original records ordered on the by column(s).</p>
<pre class="highlight"><code class="language-q">q)ungroup select c2 by c1 from t
c1 c2
-----
a  10
a  30
b  20
b  40
c  50</code></pre>
<p>There are use cases that group on specified column(s) and want <strong>all</strong> the remaining columns to be nested in the result. For this use <a href="https://code.kx.com/q/ref/xgroup/"><code>xgroup</code></a>, which takes the symbolic column name(s) to be grouped as left operand and a table as right operand. The result is a keyed table that is that same as listing all the non-grouped columns in the equivalent select.</p>
<p>Using the distribution example,</p>
<pre class="highlight"><code class="language-q">q)`p xgroup sp
p | s               qty            
--| -------------------------------
p1| `s$`s1`s2       300 300        
p2| `s$`s1`s2`s3`s4 200 400 200 200
p3| `s$,`s1         ,400           
p4| `s$`s1`s4       200 300        
p5| `s$`s4`s1       100 400        
p6| `s$,`s1         ,100 </code></pre>
<p>Again <code>ungroup</code> is an inverse up to record order.</p>
<pre class="highlight"><code class="language-q">q)ungroup `p xgroup sp
_</code></pre>
<h3 id="9343-grouping-with-aggregation">9.3.4.3 Grouping with Aggregation</h3>
<p>Normally you will group using <code>by</code> together with aggregation in the Select phrase. The effect is to aggregate along the groups, collapsing each group of rows into a single record. The result is a keyed table whose key columns are the grouped column(s).</p>
<pre class="highlight"><code class="language-q">q)select sum c2 by c1 from t
c1| c2
--| --
a | 40
b | 60
c | 50</code></pre>
<p>To group on multiple columns, specify multiple by subphrases, which results in a compound key in the result.</p>
<pre class="highlight"><code class="language-q">q)t:([] desk:`a`b`a`b`a`b; acct:`1`2`3`4`1`4; pnl:1.1 -2.2 3.3 4.4 5.5 -.5)
q)select ct:count desk, sum pnl by desk,acct from t
desk acct| ct pnl 
---------| -------
a    1   | 2  6.6 
a    3   | 1  3.3 
b    2   | 1  -2.2
b    4   | 2  3.9</code></pre>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>In contrast to SQL, every column in the By phrase is automatically included in the key column(s) of the result and should not be duplicated in the Select phrase.</p>
</div>
<p>A By subphrase can be a q expression, meaning that you can group on computed columns. This is very powerful and is not present in SQL. Following is a useful example that averages the observations of our time series in 100 millisecond buckets.</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:00:00:00.000+til 1000000;c2:1000000?`a`b;c3:1000000?100.)
q)select avg c3 by 100 xbar c1, c2 from t
c1           c2| c3      
---------------| --------
00:00:00.000 a | 55.26494
00:00:00.000 b | 41.81758
00:00:00.100 a | 48.88826
00:00:00.100 b | 46.10946</code></pre>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>In an unexpected special case of implicit grouping with aggregation, specifying a By phrase together with empty Select phrase is equivalent to applying <code>last</code> to all columns. A moment‚Äôs thought reveals this is quite useful for financial time series, where you often want the most recent value of a group.</p>
<pre><code class="language-q">
 q)t:([] desk:`a`b`a`b`a`b; acct:`1`2`3`4`1`4; pnl:1.1 -2.2 3.3 4.4 5.5 -.5)
 q)select by desk from t
 desk| acct pnl
 ----| ---------
 a   | 1    5.5
 b   | 4    -0.5 
 </code></pre>
</div>
<h2 id="94-the-exec-template">9.4 The <code>exec</code> Template</h2>
<p>The syntax of the <a href="https://code.kx.com/q/ref/exec/"><code>exec</code></a> template is identical to that of <code>select</code>.</p>
<p><code>exec</code> &lt;<em>p<sub>s</sub></em>&gt; &lt;<code>by</code> <em>p<sub>b</sub></em>&gt; <code>from</code> <em>t<sub>exp</sub></em> &lt;<code>where</code> <em>p<sub>w</sub></em>&gt;</p>
<p>Whereas <code>select</code> always returns a table, the result type of <code>exec</code> depends on the number of columns in its Select phrase. One column yields a list; more than one column yields a dictionary.</p>
<p>When more than one column is specified the Select phrase, the result is a dictionary mapping column names to the column lists produced. The essential difference from <code>select</code> is that the column lists do not have to be rectangular ‚Äì i.e., they are not required to have the same length ‚Äì and the resulting dictionary is not flipped into a table. For example, the following query fails with <code>select</code> because the proposed column dictionary is not rectangular but it succeeds with exec.</p>
<pre class="highlight"><code class="language-q">q)t:([] name:`a`b`c`d`e; state:`NY`FL`OH`NY`HI)
q)select name, distinct state from t
'length
q)exec name, distinct state from t
name | `a`b`c`d`e
state| `NY`FL`OH`HI</code></pre>
<p>A common use of <code>exec</code> is when there is only one column in the aggregate phrase and no By phrase. The result is the computed column list devoid of other structure ‚Äì i.e., not a dictionary or table. This is useful to extract a column dynamically. With t as above,</p>
<pre class="highlight"><code class="language-q">q)select name from t
name
----
a
b
c
d
e
q)exec name from t
`a`b`c`d`e</code></pre>
<p>When using <code>exec</code> to extract a single column of a table, you can place constraints on other columns.</p>
<pre class="highlight"><code class="language-q">q)exec name from t where state in `NY`HI
`a`d`e</code></pre>
<h2 id="95-the-update-template">9.5 The <code>update</code> Template</h2>
<h3 id="951-basic-update">9.5.1 Basic update</h3>
<p>The <code>update</code> template has identical syntax to <code>select</code>.</p>
<p><code>update</code> &lt;<em>p<sub>u</sub></em>&gt; &lt;<code>by</code> <em>p<sub>b</sub></em>&gt; <code>from</code> <em>t<sub>exp</sub></em> &lt;<code>where</code> <em>p<sub>w</sub></em>&gt;</p>
<p>The semantic difference is that colons in the Update phrase <em>p<sub>u</sub></em> identify modified or new columns instead of simply assigning column names. If the left of a colon is a column that exists in the table, that column is updated with the result of the expression to the right of the colon. If the left of a colon is not a column in the table, a new column of that name with the result of the expression is added to the end of the column list. The original table is not affected.</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:`a`b`c; c2:10 20 30)
q)update c1:`x`y`z from t
c1 c2
-----
x  10
y  20
z  30
q)t
_
q)update c3:`x`y`z from t
c1 c2 c3
--------
a  10 x
b  20 y
c  30 z
q)t
_</code></pre>
<p>The implicit naming conventions are the same as in <code>select</code> so you can omit the name and colon for existing columns in many cases. With <code>t</code> as above,</p>
<pre class="highlight"><code class="language-q">q)(update c2:c2+100 from t)~update c2+100 from t
1b</code></pre>
<p>In the examples above, the table was passed by value and so the original was not modified. To modify the table in place, pass it by name.</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:`a`b`c; c2:10 20 30)
q)update c1:`x`y`z from `t
_
q)t
_
q)update c3:`x`y`z from `t
_
q)t
_</code></pre>
<p>Qbies coming from DDL may not immediately appreciate how useful it is that <code>update</code> can add new columns dynamically. For example, you can add a ‚Äúconstant‚Äù column by taking advantage of the fact that scalars are extended to match vectors. This is <strong>not</strong> a default value for the column in subsequent records.</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:`a`b`c; c2:10 20 30)
q)update c3:42 from t
_</code></pre>
<p>Often you will apply <code>update</code> with a Where phrase that limits the scope of the modification.</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:`a`b`c; c2:10 20 30)
q)update c2:c2+100 from t where c1&lt;&gt;`a
c1 c2
------
a  10
b  120
c  130</code></pre>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The actions in the Where phrase and the Update phrase are vector operations on entire column lists. This is the Zen of <code>update</code>.</p>
</div>
<p>If you add a new column in <code>update</code> with a Where phrase, the fields in the non-selected rows will have the null value of the appropriate type.</p>
<pre class="highlight"><code class="language-q">q)update c3:1b from t where c2&gt;15
c1 c2 c3
--------
a  10 0
b  20 1
c  30 1</code></pre>
<p>You can use any q expression to the right of the colon providing the size and type match the targeted location.</p>
<pre class="highlight"><code class="language-q">q)update c2:42 43 from t where c2&gt;15
_
q)update c2:42 43 44 from t where c2&gt;15
'length
q)update c2:42.0 43 from t where c2&gt;15
'type</code></pre>
<h3 id="952-update-by">9.5.2 update-by</h3>
<p>When the By phrase is present, the update operation is performed along groups. This is most useful with aggregate and uniform functions. For an aggregate function, the entire group gets the value of the aggregation on the group.</p>
<pre class="highlight"><code class="language-q">q)update avg weight by city from p
p | name  color weight city  
--| -------------------------
p1| nut   red   15     london
p2| bolt  green 14.5   paris 
p3| screw blue  17     rome  
p4| screw red   15     london
p5| cam   blue  14.5   paris 
p6| cog   red   15     london</code></pre>
<p>A uniform function is applied along the group in place. This can be used to compute cumulative volume of orders, for example.</p>
<pre class="highlight"><code class="language-q">q)update cumqty:sums qty by s from sp
_</code></pre>
<h2 id="96-the-delete-template">9.6 The <code>delete</code> Template</h2>
<p>The final template, <code>delete</code>, allows either rows or columns to be deleted. Its syntax is a simplified form of <code>select</code>, with the restriction that either <em>p<sub>cols</sub></em> or <em>p<sub>w</sub></em> can be present but not both.</p>
<p><code>delete</code> &lt;<em>p<sub>cols</sub></em>&gt; <code>from</code> <em>t<sub>exp</sub></em> &lt;<code>where</code> <em>p<sub>w</sub></em>&gt;</p>
<p>If <em>p<sub>cols</sub></em> is present as a comma-separated list of columns, the result is <em>t<sub>exp</sub></em> with the specified columns removed. If <em>p<sub>w</sub></em> is present, the result is <em>t<sub>exp</sub></em> after records meeting the criteria of <em>p<sub>w</sub></em> are removed. Someone always asks, can you delete rows and column simultaneously? But the rest of us meditating on the Zen of q realize this makes no sense.</p>
<p>When the table is passed by value, the operation is on a copy. When the table is passed by name, the operation is in place. Deleting from a copy,</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:`a`b`c; c2:10 20 30)
q)delete c1 from t
_
q)delete from t where c2&gt;15
_
q)t
_</code></pre>
<p>To delete in place,</p>
<pre class="highlight"><code class="language-q">q)delete from `t where c2=30
_
q)delete c2 from `t
_
q)t
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>When you want to select all but a few columns, it is easier to delete the ones you don‚Äôt want than list all the ones you do.</p>
<pre><code class="language-q">
q)t:([] c1:1 2; c2:`a`b; c3:1.1 2.2; c4:2015.01.01 2015.01.02)
q)(select c1, c2, c4 from t)~delete c3 from t
1b
</code></pre>
</div>
<h2 id="97-sorting">9.7 Sorting</h2>
<p>Recall that tables and keyed tables comprise lists of records and therefore have an inherent order. A table or keyed table can be reordered by sorting on any column(s). In contrast to SQL, there is no equivalent to <code>ORDER BY</code> in the select template. Instead, built-in functions that sort tables are applied after <code>select</code>.</p>
<h3 id="971-xasc">9.7.1 <code>xasc</code></h3>
<p>The binary <a href="https://code.kx.com/q/ref/xasc/"><code>xasc</code></a> takes a scalar, or list of, symbolic column name(s) as its left operand and a table or table name as its right operand. It returns the records of the table sorted ascending on the specified column(s). The sort column list is specified in major-to-minor sort order.</p>
<p>To work on a copy, pass by value.</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:`a`b`c`a; c2:20 10 40 30)
q)`c2 xasc t
c1 c2
-----
b  10
a  20
a  30
c  40
q)`c1`c2 xasc t
c1 c2
-----
a  20
a  30
b  10
c  40
q)t
_</code></pre>
<p>To sort in place, pass by name.</p>
<pre class="highlight"><code class="language-q">q)`c1`c2 xasc `t
_
q)t
_</code></pre>
<h3 id="972-xdesc">9.7.2 <code>xdesc</code></h3>
<p>The binary <a href="https://code.kx.com/q/ref/xdesc/"><code>xdesc</code></a> behaves exactly as <code>xasc</code>, except that the sort is performed in descending order.
</p><pre class="highlight"><code class="language-q">q)t:([] c1:`a`b`c`a; c2:20 10 40 30)
q)`c1`c2 xdesc t
c1 c2
-----
c  40
b  10
a  30
a  20</code></pre>
<h3 id="973-mixed-sort">9.7.3 Mixed Sort</h3>
<p>We point out that <code>xasc</code> and <code>xdesc</code> are stable sorts, meaning that the order of two records having the same sort key value is preserved in the result. This makes it possible to compose ascending and descending sort to obtain mixed sorts. For example, to sort <code>c2</code> descending within <code>c1</code> ascending in <code>t</code> above,</p>
<pre class="highlight"><code class="language-q">q)`c1 xasc `c2 xdesc t
_</code></pre>
<h2 id="98-renaming-and-rearranging-columns">9.8 Renaming and Rearranging Columns</h2>
<p>Since a table is the flip of a column dictionary, its columns are both named and ordered. There are built-in primitives to rename and reorder columns. Their names are unfortunately chosen and their usage may seem awkward at first since they focus on the left-most columns. Nonetheless, they work well in practice.</p>
<p>We use the following table in this section.</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:`a`b`c; c2:10 20 30; c3:1.1 2.2 3.3)</code></pre>
<h3 id="981-xcol">9.8.1 <code>xcol</code></h3>
<p>The binary <a href="https://code.kx.com/q/ref/xcol/"><code>xcol</code></a> takes a scalar, or list of, symbolic column name(s) as its left operand (<em>names</em>) and a table or keyed table (<em>source</em>) as its right operand. The columns in <em>names</em> must appear in <em>source</em>. The result is a table obtained by renaming the left-most columns of source according to <em>names</em>.</p>
<pre class="highlight"><code class="language-q">q)`new1`new2 xcol t
_
q)t
_</code></pre>
<p>There is no pass-by-name version of <code>xcol</code>. To modify the source, reassign it.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>You can use constructs such as the following to rename isolated columns if your table has many columns and the targeted columns area not left-most.</p>
<pre><code class="language-q">
q)@[cols[t]; where cols[t]=`c2; :; `new2] xcol t
_
q)@[cols[t]; where cols[t] in `c1`c3; :; `new1`new3] xcol t
_ 
</code></pre>
</div>
<h3 id="982-xcols">9.8.2 <code>xcols</code></h3>
<p>Now you will see what we mean about the unfortunate naming convention. The binary <a href="https://code.kx.com/q/ref/xcols/"><code>xcols</code></a> takes a scalar, or list of, symbolic column name(s) as its left argument (<em>names</em>) and a table (<em>source</em>) as its right argument. The output is the result of reordering the columns in <em>names</em> so that those in <em>names</em> occur at the beginning ‚Äì i.e., left-most in the display. Columns not specified in <em>names</em> are left in original order at the end ‚Äì i.e., right-most.</p>
<p>Notes:</p>
<ul>
<li>The <em>source</em> operand <strong>cannot</strong> be a keyed table.</li>
<li>There is no pass-by-name version of <code>xcols</code>. To modify the source, you must reassign it.</li>
</ul>
<p>For example,</p>
<pre class="highlight"><code class="language-q">q)`c3 xcols t
_
q)`c3`c2 xcols t
_
q)t
_</code></pre>
<h2 id="99-joins">9.9 Joins</h2>
<p>The essence of relational database design is normalizing data using relations and keys and then reassembling with joins. Normalization eliminates duplicate data, which takes up space and is hard to keep consistent. Joins restore the original flat rectangular form that makes data easy to work with (there‚Äôs a reason spreadsheets are so popular). Simple use cases include a master-detail relation or a lookup table.</p>
<p>In SQL the relational structure with primary and foreign keys is static. It must be defined in a separate language (DDL) before the data can be used. Foreign key/primary key relations must be pre-established in order for joins to take place.</p>
<p>In q, tables are first-class entities in the language. You can define tables and relations statically, but it is easy to create them dynamically. It is even possible to join tables that could have a relation but don‚Äôt.</p>
<p>A join sews back together along a foreign key/primary linkage data that has been factored into normal form. A join can be classified as inner or outer. An <em>inner join</em> pairs <strong>only</strong> records in both operands having matching keys. A <em>left outer</em> Join includes <strong>all</strong> records in the left operand, pairing them with records having matching key in the right operand, should such exist. A <em>right outer</em> Join reverses left and right in this description.</p>
<p>In q there are built-in inner and left outer joins; if you need a right join, reverse the operands. There is no operator for a full outer join but you can construct one; be careful what you wish for with large tables.</p>
<p>Joins can also be classified by how key matching is determined. Most joins are <em>equijoins</em>, meaning that the keys must be equal. In q there are also non-equijoins, called <em>as of</em> joins, in which a key is tested for less-than-or-equal against keys in another table.</p>
<h3 id="991-implicit-join">9.9.1 Implicit Join</h3>
<p>Given a primary key table <em>m</em> with key column(s) <em>k</em> and a table <em>d</em> with a foreign key linking to <em>k</em>, a left join can be expressed in various SQL notations. For example,</p>
<pre class="highlight"><code class="language-sql">m LEFT JOIN d ON m.k = d.k</code></pre>
<p>A <code>SELECT</code> statement for this join refers to columns in the join by using dot notation based on the constituent tables.</p>
<p><code>SELECT</code> d.col<sub>d</sub>, m.col<sub>m</sub> <code>FROM</code> m <code>LEFT JOIN</code> d <code>WHERE</code> m.k <code>=</code> d.k</p>
<p>As we saw in <a href="https://code.kx.com/q4m3/8_Tables/">Chapter 8</a>, a foreign key in q is accomplished with an enumeration over the key column(s) of a keyed table. A left join is implicit in the following query on the detail table.</p>
<p><code>select col</code><sub>d</sub>, <code>k.col</code><sub>m</sub> <code>from d</code></p>
<p>For example, in the <code>sp.q</code> distribution script, the table <code>sp</code> has foreign keys to both <code>s</code> and <code>p</code>. We can extract columns from the left join with <code>s</code> by issuing a query against <code>sp</code> and using dot notation on the foreign key to get columns in <code>s</code>.</p>
<pre class="highlight"><code class="language-q">q)select sname:s.name, qty from sp
_</code></pre>
<p>This generalizes to the situation where <code>d</code> has multiple foreign keys. For example, in the <code>sp.q</code> distribution script, we can select records from the join of <code>sp</code>, <code>s</code> and <code>p</code> from a query against <code>sp</code>.</p>
<pre class="highlight"><code class="language-q">q)select sname:s.name, pname:p.name, qty from sp
_</code></pre>
<p>Implicit joins extend to the situation in which the targeted keyed table itself has a foreign key to another keyed table.</p>
<pre class="highlight"><code class="language-q">q)emaster:([eid:1001 1002 1003 1004 1005] currency:`gbp`eur`eur`gbp`eur)
q)update eid:`emaster$1001 1002 1005 1004 1003 from `s
q)select s.name, qty, s.eid.currency from sp
_</code></pre>
<h3 id="992-ad-hoc-left-join-lj">9.9.2 Ad hoc Left Join (<code>lj</code>)</h3>
<p>To create an ad-hoc left outer join between tables that <strong>could</strong> have a foreign-key relationship, use the binary <code>lj</code>. When the foreign key exists, that linkage is used; otherwise, the linkage is constructed dynamically. The join is 2-3 times faster if the foreign key already exists.</p>
<div class="admonition tip">
<p class="admonition-title">If you intend to perform the join more than a few times, it pays to create the foreign key up front.</p>
</div>
<p>The right operand is a keyed table (<em>target</em>) and the left operand is a table or keyed table (<em>source</em>) having either a foreign key to target or column(s) that match the key column(s) of target in name and type. The result is all the records and columns of <em>source</em> augmented with the records and columns of <em>target</em> along matching keys. For those records in <em>source</em> having no matching key, the augmented columns contain null values.</p>
<p>In the following example we see all the records of <code>t</code> in the result, with null values in the <code>kt</code> column(s) where there is no matching key.</p>
<pre class="highlight"><code class="language-q">q)t:([] k:1 2 3 4; c:10 20 30 40)
q)kt:([k:2 3 4 5]; v:200 300 400 500)
q)t lj kt
k c  v
--------
1 10
2 20 200
3 30 300
4 40 400</code></pre>
<p>Observe that when the source table has a foreign key, an ad-hoc left join is equivalent to listing all columns from both tables in an implicit join.</p>
<pre class="highlight"><code class="language-q">q)kt:([k:1 2 3 4 5]; v1:10 20 30 40 50; v2:1.1 2.2 3.3 4.4 5.5)
q)tf:([] k:`kt$1 2 3 4; c:10 20 30 40)
q)(tf lj kt)~select k,c,k.v1,k.v2 from tf
1b</code></pre>
<div class="admonition tip">
<p class="admonition-title">When the tables source and target have duplicate non-key columns, the operation has <code>upsert</code> semantics.</p>
</div>
<p>That is, the values in the right operand (target) columns prevail over those in the left operand (source). This is different from SQL where the result contains both columns with suffixes to ensure unique names.</p>
<pre class="highlight"><code class="language-q">q)t:([] k:1 2 3 4; v:10 20 30 40)
q)kt:([k:2 3 4 5]; v:200 300 400 500)
q)t lj kt
k v
-----
1 10
2 200
3 300
4 400</code></pre>
<p>You can also use <code>lj</code> with a left operand keyed table.</p>
<pre class="highlight"><code class="language-q">q)kt1:([k:1 2 3 4]; v:10 0N 30 40)
q)kt:([k:2 3 4 5]; v:200 300 400 500)
q)kt1 lj kt
_</code></pre>
<h3 id="993-column-lookup">9.9.3 Column Lookup</h3>
<p>You can perform a column lookup against a keyed table within a query without using a join. The insight is that a keyed table is a dictionary whose key list comprises its key records, so it will perform the lookup provided we put the column in an anonymous table conforming to those key records ‚Äì see <a href="https://code.kx.com/q4m3/8_Tables/#845-retrieving-multiple-records">¬ß8.4.5</a>. Here we demonstrate the case where the lookup column names do not natively match the key columns, so we rename columns to match in the anonymous table.</p>
<pre class="highlight"><code class="language-q">q)t:([] k:1 2 3 4; c:10 20 30 40)
q)kt:([k1:2 3 4 5]; v:2.2 3.3 4.4 5.5)
q)select c, v:kt[([] k1:k); `v] from t
c  v
------
10
20 2.2
30 3.3
40 4.4</code></pre>
<p>Especially for a single column, this is simpler (and more impressive to your colleagues) than the equivalent join.</p>
<pre class="highlight"><code class="language-q">q)select c,v from t lj `k xkey select k:k1,v from kt
c  v
------
10
20 2.2
30 3.3
40 4.4</code></pre>
<p>Here is an example using compound keys and column renaming to match the lookup table.</p>
<pre class="highlight"><code class="language-q">q)t:([] f:`rocky`bullwinkle; l:`squirrel`moose; c:10 20)
q)kt:([fn:`rocky`bullwinkle`fearless; ln:`squirrel`moose`leader] v:1.1 2.2 3.3)
q)select c, v:kt[([] fn:f; ln:l); `v] from t
c  v
------
10 1.1
20 2.2</code></pre>
<h3 id="994-ad-hoc-inner-join-ij">9.9.4 Ad Hoc Inner Join (<code>ij</code>)</h3>
<p>Given a primary key table <em>m</em> with key column(s) <em>k</em> and a table <em>d</em> with a foreign key linking to <em>k</em>, an inner join can be expressed in various SQL notations,</p>
<pre class="highlight"><code class="language-sql">m,d WHERE m.k = d.k

m INNER JOIN d ON m.k = d.k</code></pre>
<p>A <code>SELECT</code> statement for this join refers to columns in the join by using dot notation based on the constituent tables.</p>
<p><code>SELECT</code> d.col<sub>d</sub>, m.col<sub>m</sub> <code>FROM</code> m,d <code>WHERE</code> m.k <code>=</code> d.k</p>
<p>The binary <em>inner-join</em> operator <code>ij</code> performs an inner join between two tables that <strong>could</strong> have a foreign key relationship.</p>
<div class="admonition tip">
<p class="admonition-title">The same performance observations hold as for <code>lj</code>.</p>
</div>
<p>As with <code>lj</code>, the right operand is a keyed table (<em>target</em>) and the left operand is a table or keyed table (<em>source</em>) having column(s) that are either foreign key(s) over <em>target</em> or exactly match the key column(s) of <em>target</em> in name and type. The matching is done via the foreign key or by common column name(s) between <em>source</em> and the key column(s) of <em>target</em> if there is no foreign-key relationship<strong>.</strong> The result contains the columns from source and target joined along common keys.</p>
<p>The following example shows that <code>ij</code> returns just those records with matching keys in both tables.</p>
<pre class="highlight"><code class="language-q">q)t:([] k:1 2 3 4; c:10 20 30 40)
q)kt:([k:2 3 4 5]; v:2.2 3.3 4.4 5.5)
q)t ij kt
k c  v
--------
2 20 2.2
3 30 3.3
4 40 4.4</code></pre>
<p>As with <code>lj</code>, upsert semantics holds for duplicate columns.</p>
<pre class="highlight"><code class="language-q">q)t:([] k:1 2 3 4; v:10 20 30 40)
q)kt:([k:2 3 4 5]; v:200 300 400 500)
q)t ij kt
k v
-----
2 200
3 300
4 400</code></pre>
<p>You can also use <code>ij</code> with a left operand keyed table.</p>
<pre class="highlight"><code class="language-q">q)kt1:([k:1 2 3 4]; v:10 0N 30 40)
q)kt:([k:2 3 4 5]; v:200 300 400 500)
q)kt1 ij kt
_</code></pre>
<h3 id="995-equijoin-ej">9.9.5 Equijoin <code>ej</code></h3>
<p>The triadic <em>equijoin</em> operator <code>ej</code> corresponds to a SQL inner join between tables in the second and third parameters along specified column names in the first parameter. The right operand does not have to be a keyed table. Unlike <code>ij</code>, <strong>all</strong> matching records in the right table appear in the result. As with any join, upsert semantics holds on duplicate columns.</p>
<pre class="highlight"><code class="language-q">q)t1:([] k:1 2 3 4; c:10 20 30 40)
q)t2:([] k:2 2 3 4 5; c:200 222 300 400 500; v:2.2 22.22 3.3 4.4 5.5)
q)t1 ij `k xkey t2
k c   v
---------
2 200 2.2
3 300 3.3
4 400 4.4
q)ej[`k;t1;t2]
k c   v
-----------
2 200 2.2
2 222 22.22
3 300 3.3
4 400 4.4</code></pre>
<h3 id="996-plus-join-pj">9.9.6 Plus Join (<code>pj</code>)</h3>
<p><em>Plus join</em> <code>pj</code> is a left join that replaces upsert semantics for duplicate column names with addition. This is useful when you have two tables with identical schemas having all non-key columns numeric. For example, you have an organizational hierarchy and you want to roll up numeric results.</p>
<p>The operands of <code>pj</code> are the same as for <code>lj</code> with the additional requirement that all non-key columns are numeric. The semantics are that duplicate columns are added along matching keys and missing or null values are treated as zero.</p>
<p>For example,</p>
<pre class="highlight"><code class="language-q">q)t:([] k:`a`b`c; a:100 200 300; b:10. 20. 30.; c:1 2 3)
q)kt:([k:`a`b] a:10 20; b:1.1 2.2)
q)t pj kt
k a   b    c
------------
a 110 11.1 1
b 220 22.2 2
c 300 30 3</code></pre>
<p>Observe that this is the same as,</p>
<pre class="highlight"><code class="language-q">q)kt1:([k:`a`b`c] a:10 20 0; b:1.1 2.2 0.0; c:0 0 0)
q)t pj kt1
k a   b    c
------------
a 110 11.1 1
b 220 22.2 2
c 300 30 3</code></pre>
<h3 id="997-union-join">9.9.7 Union Join</h3>
<p>The equivalent of an ordinary SQL union on tables with matching schemas is simply <code>,</code>. Indeed, it joins two lists of compatible records.</p>
<pre class="highlight"><code class="language-q">q)t1:([] c1:`a`b; c2:1 2)
q)t2:([] c1:`c`d; c2:3 4)
q)t1,t2
c1 c2
-----
a  1
b  2
c  3
d  4</code></pre>
<p><em>Union join</em> <a href="https://code.kx.com/q/ref/uj/"><code>uj</code></a> is more powerful in that it vertically combines <strong>any</strong> two tables, or keyed tables. The records of the right operand are appended to those of the left operand in the following manner. The result table is widened with new columns of the same name and type for the columns of the right operand that do not appear in the left operand. The initial records in the result come from the left operand and have nulls in the new columns. Records from the right operand have their field values under the appropriate columns. An example is worth a thousand words.</p>
<pre class="highlight"><code class="language-q">q)t1:([] c1:`a`b`c; c2: 10 20 30)
q)t2:([] c1:`x`y; c3:8.8 9.9)
q)t1 uj t2
c1 c2 c3 
---------
a  10    
b  20    
c  30    
x     8.8
y     9.9</code></pre>
<p>Continuing the previous example, you can use <code>uj/</code> to combine a list of disparate tables.</p>
<pre class="highlight"><code class="language-q">q)t3:([] c1:`e`f`g; c2:50 60 70; c3:5.5 6.6 7.7)
q)(uj/) (t1; t2; t3)
_</code></pre>
<p>You can also apply <code>uj</code> to keyed tables, where upsert semantics hold on both rows and columns.</p>
<pre class="highlight"><code class="language-q">q)kt1:([k:1 2 3] v1:`a`b`c; v2:10 20 30)
q)kt2:([k:3 4] v2:300 400; v3:3.3 4.4)
q)kt1 uj kt2
k| v1 v2  v3 
-| ----------
1| a  10     
2| b  20     
3| c  300 3.3
4|    400 4.4</code></pre>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The operation of <code>uj</code> is expensive so it should only be used when necessary; in particular, when the tables conform, use <code>,</code> or <code>raze</code>. Be especially cautious when low latency is paramount.</p>
</div>
<h3 id="998-as-of-joins">9.9.8 As-of Joins</h3>
<p>As-of joins are so-named because they most often join tables along time columns to obtain a value in one table that is current as of a time in another table. As-of joins are non-equijoins that match on less-than-or-equal. They are not restricted to time values.</p>
<p>The fundamental as-of join is the triadic function <a href="https://code.kx.com/q/ref/aj/"><code>aj</code></a>. It joins tables along common columns using most recent values. The syntax of <code>aj</code> is,</p>
<p><code>aj</code>[`<em>c<sub>1</sub></em>...`<em>c<sub>n</sub></em>;<em>t<sub>1</sub></em>;<em>t<sub>2</sub></em>]</p>
<p>where <em>`c<sub>1</sub>...`c<sub>n</sub></em> is a simple list of symbol column names common to <em>t<sub>1</sub></em> and <em>t<sub>2</sub></em>, which are the tables to be joined. There is no requirement for any of the join columns to be keys but the join will be faster on keys. The columns of both tables are brought into the result.</p>
<p>The semantics of <code>aj</code> are as follows. The match on all specified columns <strong>except the last</strong> is by equals. Assuming the records are sequenced by <em>c<sub>n</sub></em> in both tables, for a given <em>c<sub>n</sub></em> value in <em>t<sub>1</sub></em>, the match picks the greatest <em>c<sub>n</sub></em> in <em>t<sub>2</sub></em> less than or equal to the given value in <em>t<sub>1</sub></em>. Specifically, if the <em>c<sub>n</sub></em> columns are sequenced temporal values, for each <em>c<sub>n</sub></em> value in <em>t<sub>1</sub></em> the match picks the <em>t<sub>2</sub></em> row whose <em>c<sub>n</sub></em> value is in effect ‚Äúas of‚Äù the time in <em>t<sub>1</sub></em>.</p>
<p>The canonical example for <code>aj</code> is matching trades with quotes. To know if a trade represents best execution, you want to compare the trade price to the current quote ‚Äì i.e., the most recent quote up to and including the time of the trade. When matching the trades and quotes, you clearly want an equijoin on the date and symbol and a non-equijoin on the time.</p>
<pre class="highlight"><code class="language-q">q)show t:([] ti:10:01:01 10:01:03 10:01:04;sym:`msft`ibm`ge;qty:100 200 150)
ti       sym  qty
-----------------
10:01:01 msft 100
10:01:03 ibm  200
10:01:04 ge   150
q)show q:([] ti:10:01:00 10:01:01 10:01:01 10:01:02;sym:`ibm`msft`msft`ibm;px:100 99 101 98)
ti       sym  px 
-----------------
10:01:00 ibm  100
10:01:01 msft 99 
10:01:01 msft 101
10:01:02 ibm  98
q)aj[`sym`ti;t;q]
ti       sym  qty px 
---------------------
10:01:01 msft 100 101
10:01:03 ibm  200 98 
10:01:04 ge   150</code></pre>
<p>It is worth stepping through this example in detail. We begin with the first record in <code>t</code>. We look for the quote records matching <code>`msft</code> as of the trade time 10:01:01. There are two such records, both stamped 10:01:01 but the last one has price 101, which is reflected in the result. Next we look for the last quote record for <code>`ibm</code> as of 10:01.02, which is the quote record stamped 10:00:02 with price 98. Finally there are no quote records matching <code>`ge</code> at 10:01:04.</p>
<p>If you want the time of the matching quote in the result instead of the time of the trade, use <a href="https://code.kx.com/q/ref/aj0/"><code>aj0</code></a>.</p>
<pre class="highlight"><code class="language-q">q)aj0[`sym`ti;t;q]
ti       sym  qty px 
---------------------
10:01:01 msft 100 101
10:01:02 ibm  200 98 
10:01:04 ge   150 </code></pre>
<p>The simpler function <a href="https://code.kx.com/q/ref/asof/"><code>asof</code></a> performs the same match as <code>aj</code> but with a table against a single record. The result picks out the remaining columns in the matched row of the table.</p>
<pre class="highlight"><code class="language-q">q)t:([] ti:10:01:01 10:01:03 10:01:04; sym:`msft`ibm`ge; qty:100 200 150; px:45 160 55)
q)t
_
q)t asof `sym`ti!(`ibm;10:01:03)
qty| 200
px | 160</code></pre>
<p>A list of such dictionary records conforms ‚Äì i.e., is a table ‚Äì and <code>asof</code> matches against each record.</p>
<pre class="highlight"><code class="language-q">q)t asof ([] sym:`msft`ibm; ti:10:01:01 10:01:03)
qty px
-------
100 45
200 160</code></pre>
<p>As-of joins are also useful with non-numeric data. Suppose we have a table containing a history of state changes ‚Äì e.g., employee promotions. An as-of join will determine the state ‚Äúas of‚Äù any point in time.</p>
<pre class="highlight"><code class="language-q">q)promotions:([] name:`nuba`devi`nuba`devi`nuba;
    dt:2000.01.01 2005.02.14 2010.02.01 2012.08.12 2015.11.01;
    title:`associate`analyst`director`cfo`retired)
q)promotions asof `name`dt!(`nuba; 2009.07.04)
title| associate
q)promotions asof `name`dt!(`devi; 2015.12.01)
_
q)events:([] name:`nuba`devi; dt: 2009.07.04 2015.12.01)
q)aj[`name`dt; events; promotions]
_</code></pre>
<h3 id="999-window-join">9.9.9 Window Join</h3>
<p>Window joins are a generalization of as-of joins and are specifically geared for analyzing the relationship between trades and quotes in finance. The idea is that you want to investigate the behavior of quotes in a neighborhood of each trade. For example, to determine how well a trade was executed, you need to examine the range of bid and ask prices that were prevalent around the trade time.</p>
<p>Writing such a query manually would be cumbersome. Instead, q provides the built-in window join <a href="https://code.kx.com/q/ref/wj/"><code>wj</code></a> that computes on an interval around each trade. Specifying the set up takes a bit of work but then all the hard work is done for you.</p>
<p>So that things fit on the page, we use a simple example involving trades for one ticker symbol <code>`aapl</code> and times that are in seconds. The general case is essentially the same. First we create the trades and quotes tables; note that they are required to be unkeyed.</p>
<pre class="highlight"><code class="language-q">q)show t:([]sym:3#`aapl;time:09:30:01 09:30:04 09:30:08;price:100 103 101)
_
q)show q:([] sym:8#`aapl;
    time:09:30:01+(til 5),7 8 9;
    ask:101 103 103 104 104 103 102 100;
    bid:98 99 102 103 103 100 100 99)
_</code></pre>
<p>We construct fixed-width windows of 2 seconds before and one second after each trade time. (There is no requirement that the windows be of uniform width.)</p>
<pre class="highlight"><code class="language-q">q)w:-2 1+\:t `time
q)w
_</code></pre>
<p>For readability we place the names of the sym and time columns in a variable.</p>
<pre class="highlight"><code class="language-q">q)c:`sym`time</code></pre>
<p>The actual form for <code>wj</code> is:</p>
<pre class="highlight"><code class="language-q">wj[w;c;t;(q;(f0;c0);(f1;c1))]</code></pre>
<p>Here <code>w</code> is a list of windows, <code>c</code> is the list of sym and time column names, <code>t</code> is the trades table. The final parameter is a list with the quotes table and a pair of lists, each with an aggregate function and a column name.</p>
<p>To see all the values in each window, pass the identity function <code>::</code> in place of the aggregates. The result is similar to grouping without aggregate in a query and is helpful to see what is happening within each window.</p>
<pre class="highlight"><code class="language-q">q)wj[w;c;t;(q;(::;`ask);(::;`bid))]
sym  time     price ask             bid           
--------------------------------------------------
aapl 09:30:01 100   101 103         98 99         
aapl 09:30:04 103   103 103 104 104 99 102 103 103
aapl 09:30:08 101   104 103 102     103 100 100</code></pre>
<p>Now we apply <code>wj</code> with actual aggregates for the maximum ask and minimum bid over each window. Here you see the results of the aggregate functions run within each window.</p>
<pre class="highlight"><code class="language-q">q)wj[w;c;t;(q;(max;`ask);(min;`bid))]
sym  time     price ask bid
---------------------------
aapl 09:30:01 100   103 98 
aapl 09:30:04 103   104 99 
aapl 09:30:08 101   104 100</code></pre>
<p>As opposed to the aggregates being run over only the quote values within each window, you can also include the quotes that are current at the beginning of the window. This matters if there is no quote precisely at the beginning time of the window. For this case use <a href="https://code.kx.com/q/ref/wj1/"><code>wj1</code></a>, whose syntax is identical to <code>wj</code>.</p>
<pre class="highlight"><code class="language-q">q)wj1[w;c;t;(q;(::;`ask);(::;`bid))]
sym  time     price ask             bid           
--------------------------------------------------
aapl 09:30:01 100   101 103         98 99         
aapl 09:30:04 103   103 103 104 104 99 102 103 103
aapl 09:30:08 101   103 102         100 100</code></pre>
<h2 id="910-parameterized-queries">9.10 Parameterized Queries</h2>
<p>Relational databases have stored procedures, which are database programs incorporating SQL statements. The programming languages are not part of the SQL standard. They vary significantly across vendors but are generally third-generation imperative languages.</p>
<p>This situation forces a programmer to make a choice: learn a proprietary language to place functionality close to the data, or extract the data into an application server to perform calculations. Various multi-tier architectures have evolved to address this problem, but they increase system cost and complexity.</p>
<p>This separation is obviated in kdb+, since q is the stored procedure language and it has the power and performance to process big data. Any q function that operates on a table is effectively a stored procedure. Function parameters can be used to supply specific values for queries.</p>
<p>In particular, the <code>select</code>, <code>exec</code>, <code>update</code> and <code>delete</code> templates can be invoked within a function with parameters to yield a <em>parameterized query</em>.</p>
<div class="admonition important">
<p class="admonition-title">Restrictions</p>
<p>Parameterized queries with templates have restrictions:</p>
<ul>
<li>A column cannot be passed as a parameter since columns are part of the syntactic sugar of the template. They only become symbols under the covers.</li>
<li>Multiple parameters cannot be implicit ‚Äì i.e., they must be declared explicitly. Although this seems to work for a single parameter, we recommend making <strong>all</strong> parameters explicit.</li>
</ul>
</div>
<p>We follow our own advice in the following examples.</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:`a`b`c; c2:10 20 30; c3:1.1 2.2 3.3)
q)select from t where c2&gt;15
_
q)proc:{[sc] select from t where c2&gt;sc}
q)proc 15
_
q)proc2:{[nms;sc] select from t where c1 in nms, c2&gt;sc}
q)proc2[`a`c; 15]
_</code></pre>
<p>You <strong>can</strong> pass a table as a parameter to a template, either by value or by name.</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:`a`b`c; c2:10 20 30; c3:1.1 2.2 3.3)
q)proc3:{[t;nms;delta] update c2+delta from t where c1 in nms}
q)proc3[t;`a`c;100]
_
q)t
_
q)proc3[`t;`a`c;100]
_
q)t
_</code></pre>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>There is no need to restrict stored procs in q to the templates. Any expression that operates on tables can serve.</p>
<pre><code class="language-q">
 q)t:([] c1:`a`b`c; c2:10 20 30; c3:1.1 2.2 3.3)
 q)procf:{[cs] cs#t}
 q)procf `c1`c2
 _ 
</code></pre>
</div>
<p>You can effectively parameterize column names in two ways, only one of which is good practice. First, you can mimic a common technique from SQL in which the query is created dynamically: build the query text in a string and then invoke the interpreter programmatically using <code>value</code>. This is comparatively slow. Worse, it exposes your application to injection attacks, since any q expression that appears inside the text will be executed.</p>
<p>The preferred method is to use the functional form for queries ‚Äì see <a href="#912-functional-forms">¬ß9.12</a> ‚Äì which is fast and secure. In functional form, all columns are referred to by symbolic name, so column names can be passed as symbols. In fact, <strong>any</strong> component of a query can be passed as an argument in functional form.</p>
<h2 id="911-views">9.11 Views</h2>
<p>A SQL view is effectively a query expression whose result set can be used like a table. Views are useful for encapsulating data ‚Äì e.g., hiding columns, or simplifying complex queries.</p>
<p>A q-sql <em>view</em> is a named table expression created as an alias with the double-colon operator <code>::</code>. It is common to use the templates in views but this is not a limitation.</p>
<p>In the following example, contrast <code>u</code>, which is a q variable that is assigned the result of a query, to the view (alias) <code>v</code> that is the query expression itself.</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:`a`b`c; c2:10 20 30)
q)u:select from t where c2&gt;15
q)v::select from t where c2&gt;15
q)u
_
q)v
_
q)update c2:15 from `t where c1=`b
`t
q)u
c1 c2
_
q)v
c1 c2
-----
c  30</code></pre>
<p>Observe that when the underlying table changed, <code>u</code> did not change but the next reference to <code>v</code> does reflect the update.</p>
<p>To find the underlying query of a view, or any alias, apply the function <a href="https://code.kx.com/q/ref/view/"><code>view</code></a> to the symbol alias name.</p>
<pre class="highlight"><code class="language-q">q)view `v
"select from t where c2&gt;15"
q)a:42
q)b::a
q)view `b
_</code></pre>
<p>To list all the views in a namespace, use the function <a href="https://code.kx.com/q/ref/views/"><code>views</code></a> with the context name. For example, to list the views in the root,</p>
<pre class="highlight"><code class="language-q">q)views `.
`b`v</code></pre>
<h2 id="912-functional-forms">9.12 Functional Forms</h2>
<p>In the experience of the author, functional form is the most difficult q topic for most qbies. Among the reasons for this are:</p>
<ul>
<li>The high level of abstraction and generalization</li>
<li>There is nothing like it in SQL or other programming languages</li>
<li>In vintage Arthurian fashion, information density is maximized</li>
</ul>
<p>Full disclosure: functional form is difficult. Along with iterators and generalized application, it completes the Big Three aspects of q that separate q pretenders from contenders. Fortunately there is a cheat that can be helpful in most situations.</p>
<p>The function <a href="https://code.kx.com/q/ref/parse/"><code>parse</code></a> can be applied to a string containing a template query to produce a parse tree whose items (nearly) work in the equivalent functional form. A complication is that the operators are displayed in k form instead of q.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The constraint portion of the result of <code>parse</code> applied to a string containing a q-sql query template generally has an extra level of <code>enlist</code> that should be removed for the corresponding functional form. The console display of the parse tree shows the k form of <code>enlist</code> ‚Äì i.e., <code>,</code> ‚Äì so you will actually see <code>,,</code>.</p>
</div>
<p>The functional forms of the four templates <code>select</code>, <code>exec</code>, <code>update</code> and <code>delete</code> are powerful because they allow all constituents to be parameterized. They can be used for any query but are especially handy for queries that are generated or completed programmatically. The q interpreter parses the syntactic sugar of the templates into their equivalent functional forms, so there is no performance difference.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>We recommend writing table operations in fundamental or template form unless you anticipate needing to parameterize column names. The folks who assume your code will thank you.</p>
</div>
<p>There are two functional forms, one for <code>select</code> and <code>exec</code>, the other for <code>update</code> and <code>delete</code>. The types of the arguments passed determine the overload. The forms are,</p>
<pre class="highlight"><code class="language-q">?[t;c;b;a] / select and exec

![t;c;b;a] / update and delete</code></pre>
<p>where</p>
<ul>
<li><code>t</code> is a table or the name of a table</li>
<li><code>a</code> is a dictionary of aggregates</li>
<li><code>b</code> is a dictionary of groupbys or a flag controlling other aspects of the query</li>
<li><code>c</code> is a list of constraints.</li>
</ul>
<p>The expressions in <code>a</code>, <code>b</code> and <code>c</code> can involve columns of <code>t</code> and also any variables that are in scope. The rules for expression interpretation are:</p>
<ul>
<li>Columns are always represented by their symbolic names</li>
<li>Consequently, any literal symbols, or lists of symbols, appearing in the expressions must be distinguished. This is done by enlisting them. Really.</li>
</ul>
<p>We warned you this wasn‚Äôt going to be easy.</p>
<p>We shall use the following sample tables in our examples.</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:`a`b`a`c`a`b`c; c2:10*1+til 7; c3:1.1*1+til 7)
q)ft:{([] c1:`a`b`a`c`a`b`c; c2:10*1+til 7; c3:1.1*1+til 7)}</code></pre>
<h3 id="9121-functional-select">9.12.1 Functional select</h3>
<p>We begin with the functional form corresponding to the simplest select query, which uses (yet another) <a href="https://code.kx.com/q/basics/funsql/#select">overload of <code>?</code></a>.</p>
<pre class="highlight"><code class="language-q">q)select from t
_
q)?[t; (); 0b; ()]
_
q)?[t; (); 0b; ()]~select from t
1b</code></pre>
<p>In this degenerate functional form,</p>
<ul>
<li>The constraint parameter is the empty list</li>
<li>The by parameter is the special value <code>0b</code> indicating there is no grouping in a select query</li>
<li>The aggregate parameter takes the special value of the general empty list, indicating there is no aggregate phrase</li>
</ul>
<p>Observe that we can pass the table by name and we can also parameterize the table by substituting any q expression that returns a table or keyed table.</p>
<pre class="highlight"><code class="language-q">q)?[`t; (); 0b; ()]
_
q)?[ft[]; (); 0b; ()]
_</code></pre>
<p>Now we add a constraint ‚Äì i.e., a Where phrase. The constraint parameter must be a <strong>list</strong> of q <a href="https://code.kx.com/q/basics/parsetrees/">parse trees</a>, one item for each subphrase in the Where phrase. The parse tree for each subphrase can be obtained by converting the expression fully to prefix form and then transforming each function into a list with it followed by all its arguments. Remember, columns names become symbols and literal symbols get enlisted.</p>
<pre class="highlight"><code class="language-q">q)select from t where c2&gt;35,c1 in `b`c
_
q)?[t; ((&gt;;`c2;35); (in;`c1;enlist `b`c)); 0b; ()]
_</code></pre>
<p>Next we demonstrate aggregation without grouping. The aggregate parameter is a dictionary whose keys are column names and whose value list is a list of parse trees, one for each subphrase of the aggregate phrase. Again, column names are symbols, and literal symbols get enlisted.</p>
<div class="admonition tip">
<p class="admonition-title">While q will assign default columns names in the templates, you must explicitly provide all columns names in functional form.</p>
</div>
<pre class="highlight"><code class="language-q">q)select max c2, c2 wavg c3 from t
_
q)?[t; (); 0b; `maxc2`wtavg!((max;`c2); (wavg;`c2;`c3))]
_</code></pre>
<p>Next we demonstrate grouping without aggregation. As with the aggregate parameter, we construct a dictionary with column names and parse trees of the By subphrases. In this particular example, we demonstrate how to handle the case of grouping on a single column. Recall that a singleton dictionary requires the key and value to be enlisted ‚Äì this enlist is separate from enlisting literal symbols in functional form.</p>
<!-- FIXME Consider recalling the ‚Äòdefault‚Äô aggregation in which only the last value in each group is returned here. -->

<pre class="highlight"><code class="language-q">q)select by c1 from t
_
q)?[t; (); (enlist `c1)!enlist `c1; ()]
_</code></pre>
<p>Finally we put the pieces together. We find code to be more readable if you separately construct the three parameters as variables and pass these in to the functional form.</p>
<pre class="highlight"><code class="language-q">q)select max c2, c2 wavg c3 by c1 from t where c2&gt;35,c1 in `b`c
_
q)c:((&gt;;`c2;35); (in;`c1;enlist `b`c))
q)b:(enlist `c1)!enlist `c1
q)a:`maxc2`wtavg!((max;`c2); (wavg;`c2;`c3))
q)?[t;c;b;a]
_</code></pre>
<p>Now that wasn‚Äôt so bad, was it? OK, maybe it was.</p>
<p>Next we show the functional form for the special case <code>select distinct</code>. In this case set the <em>by</em> parameter to <code>1b</code>.</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:`a`b`a`c`b`c; c2:1 1 1 2 2 2; c3:10 20 30 40 50 60)
q)select distinct c1,c2 from t
_
q)?[t; (); 1b; `c1`c2!`c1`c2]
_</code></pre>
<p>The extended form <code>select[n]</code> adds a fifth parameter to the functional form.</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:`a`b`c; c2:10 20 30)
q)select[2] from t
_
q)?[t;();0b;();2]
_</code></pre>
<p>The extended form <code>select[&gt;<em>c<sub>i</sub></em>]</code> adds two additional parameters to the functional form. The first is the initial value for the comparison and the second is a list with the k form ‚Äì seriously! ‚Äì of the comparison operator for the sort along with the column name for the sort.</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:`a`b`c`a; c2:10 20 30 40)
q)select[&gt;c1] c1,c2 from t
_
q)?[t;();0b;`c1`c2!`c1`c2; 0W; (&gt;:;`c1)]
_</code></pre>
<h3 id="9122-functional-exec">9.12.2 Functional exec</h3>
<p>The functional form for <code>exec</code> is nearly identical to that of <code>select</code>. Slight variations in the parameters indicate which is intended. Since the constraint parameter carries over unchanged, we omit its discussion in this section.</p>
<p>The functional form for <code>exec</code> on a single result column depends on whether you want a list or dictionary to be returned. Assuming there is no grouping, use the empty list for the <em>by</em> parameter. For a list result, specify the aggregate as a parse tree; for a dictionary result, specify a dictionary mapping the result name to its parse tree.</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:`a`b`c`a; c2:10 20 30 40; c3:1.1 2.2 3.3 4.4)
q)exec distinct c1 from t
_
q)?[t; (); (); (distinct; `c1)]
_
q)exec c1:distinct c1 from t
_
q)?[t; (); (); (enlist `c1)!enlist (distinct; `c1)]
_</code></pre>
<p>For <code>exec</code> on multiple columns without grouping, specify the <em>by</em> parameter as the general empty list and the aggregate parameter as a dictionary mapping column names to a list of parse trees.
</p><pre class="highlight"><code class="language-q">q)exec distinct c1, c2 from t
_
q)?[t; (); (); `c1`c2!((distinct; `c1); `c2)]
_</code></pre>
<p>To group on a single column, specify its symbol name in the <em>by</em> parameter.</p>
<pre class="highlight"><code class="language-q">q)exec c2 by c1 from t
_
q)?[t; (); `c1; `c2]
_</code></pre>
<p>More complex grouping in an exec seems to revert to the equivalent select.</p>
<h3 id="9123-functional-update">9.12.3 Functional update</h3>
<p>The syntax of functional form of <code>update</code> is identical to that of <code>select</code> except that <code>!</code> is used in place of <code>?</code>. In the following examples you will need to keep track of the different uses of <code>enlist</code>:</p>
<ul>
<li>making a list of parse trees from a single parse expression</li>
<li>creating singleton dictionaries</li>
<li>distinguishing literal symbols from column names.</li>
</ul>
<pre class="highlight"><code class="language-q">q)t:([] c1:`a`b`c`a`b; c2:10 20 30 40 50)
q)update c2:100 from t where c1=`a
_
q)c:enlist (=;`c1;enlist `a)
q)b:0b
q)a:(enlist `c2)!enlist 100
q)![t;c;b;a]
_
q)update c2:sums c2 by c1 from t
c1 c2
-----
a 10
b 20
c 30
a 50
b 70
q)![`t; (); (enlist `c1)!enlist `c1; (enlist `c2)!enlist(sums; `c2)]
_
q)t
_</code></pre>
<p>Observe that we switched to passing by name in the last functional query.</p>
<h3 id="9124-functional-delete">9.12.4 Functional delete</h3>
<p>The syntax of functional <code>delete</code> is a simplified form of functional update.</p>
<p><code>![t;c;0b;a]</code></p>
<p>where <code>t</code> is a table, or the name of a table, <code>c</code> is a list of parse trees for Where subphrases and <code>a</code> is a <strong>list</strong> of column names. Either <code>c</code> or <code>a</code>, but not both, must be present. If <code>c</code> is present, it specifies which rows are to be deleted. If <code>a</code> is present it is a list of symbol column names to be deleted. </p>
<!-- In the latter case you must specify `c` as an empty list of symbols. -->
<p>In the former case you must specify <code>a</code> as an empty list of symbols.</p>
<p>As before, distinguish the various uses of <code>enlist</code> in the examples.</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:`a`b`c`a`b; c2:10 20 30 40 50)
q)delete from t where c1=`b
_
q)![t;enlist (=;`c1;enlist `b);0b;`symbol$()]
_
q)delete c2 from t
_
q)![`t;();0b;enlist `c2]
`t
q)t
_</code></pre>
<p>Again observe that we switched to call by name in the last query.</p>
<h2 id="913-examples">9.13 Examples</h2>
<p>At this point we know enough about tables to do some damage. You should go back and (re)read <a href="https://code.kx.com/q4m3/1_Q_Shock_and_Awe/">¬ß1. Q Shock and Awe</a>. It will now be straightforward.</p>
<h3 id="9131-the-trades-table">9.13.1 The trades Table</h3>
<p>We shall demonstrate further examples in this section based on the <code>trades</code> table created there. Here we encapsulate the steps in a function so that it can be run for an arbitrary list of tickers and an arbitrary number of rows. On the author‚Äôs two-year-old MacBook Pro, it takes a few seconds to create a table with 10,000,000 rows.</p>
<pre class="highlight"><code class="language-q">mktrades:{[tickers; sz]
  dt:2015.01.01+sz?31;
  tm:sz?24:00:00.000;
  sym:sz?tickers;
  qty:10*1+sz?1000;
  px:90.0+(sz?2001)%100;
  t:([] dt; tm; sym; qty; px);
  t:`dt`tm xasc t;
  t:update px:6*px from t where sym=`goog;
  t:update px:2*px from t where sym=`ibm;
  t}
trades:mktrades[`aapl`goog`ibm; 10000000]</code></pre>
<div class="admonition warning">
<p class="admonition-title">No multiline expressions in session</p>
<p>You can‚Äôt actually define multiline functions in the q session like that. 
But you can in a script. </p>
<p>See <a href="https://code.kx.com/q4m3/13_Commands_and_System_Variables/">¬ß13 Commands and System Variables</a><em>Ed.</em></p>
</div>
<h3 id="9132-the-instrument-table">9.13.2 The instrument Table</h3>
<p>The <code>instr</code> table is a static keyed table containing basic information about the companies whose financial instruments (stocks in our case) are traded. Its schema has fields for the stock symbol, the name of the company and the industry classification of the company.</p>
<pre class="highlight"><code class="language-q">q)instr:([sym:`symbol$()] name:`symbol$(); industry:`symbol$())</code></pre>
<p>We populate <code>instr</code> using <code>upsert</code>.</p>
<pre class="highlight"><code class="language-q">q)`instr upsert (`ibm; `$"International Business Machines"; `$"Computer Services")
`instr
q)`instr upsert (`msft; `$"Microsoft"; `$"Software")
`instr
q)`instr upsert (`goog; `$"Google"; `$"Search")
`instr
q)`instr upsert (`aapl; `$"Apple"; `$"Electronics")
`instr
q)instr
_</code></pre>
<p>Now we make <code>sym</code> a foreign key to trades.</p>
<pre class="highlight"><code class="language-q">q)update `instr$sym from `trades
`trades
q)meta trades
c  | t f a
---| ---------
dt | d s
tm | t
sym| s instr
qty| j
px | f</code></pre>
<h3 id="9133-basic-queries">9.13.3 Basic Queries</h3>
<p>Here we demonstrate basic operations against the trades and instrument tables.</p>
<p>We can count the total number of trades in several ways. The last two versions cause q to do the most work and should be avoided. Observe that q does not carry the name of its own virtual column <code>i</code> to the result of <code>select</code>.</p>
<pre class="highlight"><code class="language-q">q)count trades
_
q)count select from trades
10000000

q)exec count i from trades
10000000
q)select count i from trades
x
-------
10000000</code></pre>
<p>Let‚Äôs count the number of trades for an individual symbol.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>For splayed and partitioned tables, only the <code>select</code> expression works.</p>
<pre><code class="language-q">
q)exec count i from trades where sym=`ibm
_
q)select count i from trades where sym=`ibm
_
</code></pre>
</div>
<p>We can count the number of trades across all symbols. The second version unkeys the result.</p>
<pre class="highlight"><code class="language-q">q)select count i by sym from trades
sym | x
----| -------
aapl| 3333498
goog| 3330409
ibm | 3336093
q)() xkey select count i by sym from trades
_</code></pre>
<p>We find one day's trades for AAPL.</p>
<pre class="highlight"><code class="language-q">q)select from trades where dt=2015.01.15,sym=`aapl
_</code></pre>
<p>We find all lunch-hour trades for GOOG. Note that <code>within</code> includes both endpoints. Also recall that you must use general-list notation if the endpoints are variables.</p>
<pre class="highlight"><code class="language-q">q)select from trades where sym=`goog, tm within 12:00:00 13:00:00
_
q)noon:12:00:00
q)thirteen00:13:00:00
q)select from trades where sym=`goog, tm within (noon;thirteen00)
_</code></pre>
<p>We find the maximum daily price for AAPL. Due to our uniform distribution, it is statistically constant.</p>
<pre class="highlight"><code class="language-q">q)select maxpx:max px by dt from trades where sym=`aapl
dt        | maxpx
----------| -----
2015.01.01| 110
2015.01.02| 110
2015.01.03| 110
2015.01.04| 110
..</code></pre>
<p>We find the minimum and maximum trade price over the trading range for each symbol by company name. We point out that this is actually grouping on a computed column since the foreign key is resolved to the instrument table via an implicit join.</p>
<pre class="highlight"><code class="language-q">q)select lo:min px, hi:max px by sym.name from trades
name                           | lo  hi
-------------------------------| -------
Apple                          | 90  110
Google                         | 540 660
International Business Machines| 180 220</code></pre>
<p>We find the total and average trade volume for specific symbols. Due to our simplistic construction, the volumes are statistically the same.</p>
<pre class="highlight"><code class="language-q">q)select totq:sum qty, avgq:avg qty by sym from trades where sym in `ibm`goog
sym | totq        avgq
----| --------------------
goog| 16670706340 5005.603
ibm | 16702382420 5006.57</code></pre>
<p>We find the high, low and close over one-minute intervals for Google.</p>
<pre class="highlight"><code class="language-q">q)select hi:max px,lo:min px,open:first px, close:last px by dt,tm.minute from trades where sym=`goog
dt         minute| hi     lo     open   close
-----------------| --------------------------
2015.01.01 00:00 | 658.98 540.72 610.98 561.66
2015.01.01 00:01 | 659.4  542.82 594.24 595.86
2015.01.01 00:02 | 652.5  540    625.26 583.5
..</code></pre>
<p>We demonstrate how to use our own functions in queries. Suppose we define a funky average that weights items by their position. Notice that we use intra-line assignment to avoid counting <code>x</code> three times.</p>
<pre class="highlight"><code class="language-q">q)favg:{(sum x*1+til ctx)%ctx*ctx:count x}</code></pre>
<p>Then we can apply <code>favg</code> just as we did the built-in q function <code>avg</code>.</p>
<pre class="highlight"><code class="language-q">q)select favgpx:favg px by sym from trades
sym | favgpx
----| --------
aapl| 49.99748
goog| 300.0155
ibm | 100.0009</code></pre>
<h3 id="9134-meaty-queries">9.13.4 Meaty Queries</h3>
<p>In this section, we demonstrate more interesting q-sql examples against the trades table.</p>
<p>We find volume-weighted average price by day and for 100-millisecond buckets for AAPL. Note that latter takes a few seconds for 10,000,000 trades on the author‚Äôs laptop.</p>
<pre class="highlight"><code class="language-q">q)select vwap:qty wavg px by dt from trades where sym=`ibm
dt        | vwap
----------| --------
2015.01.01| 200.064
2015.01.02| 200.0207
2015.01.03| 200.0109
..
q)select vwap:qty wavg px by dt,100 xbar tm from trades where sym=`ibm
dt         tm          | vwap
-----------------------| ------
2015.01.01 00:00:00.700| 194.8
2015.01.01 00:00:01.300| 200.96
2015.01.01 00:00:03.900| 215.34
..</code></pre>
<p>We use <code>fby</code> to select records attaining the maximum price each day for each sym.</p>
<pre class="highlight"><code class="language-q">q)select from trades where px=(max;px) fby sym
dt         tm           sym  qty  px
-------------------------------------
2015.01.01 00:20:05.835 goog 9750 660
2015.01.01 00:33:19.125 goog 3150 660
2015.01.01 00:42:13.379 goog 8790 660
2015.01.01 00:42:58.623 aapl 6090 110
..</code></pre>
<p>We use <code>favg</code> from the previous section to demonstrate that user functions can appear in any phrase of the query.</p>
<pre class="highlight"><code class="language-q">q)select from trades where px&lt;2*(favg;px) fby sym
dt         tm           sym  qty  px
----------------------------------------
2015.01.01 00:00:00.448 goog 6940 540.18
2015.01.01 00:00:00.602 aapl 540  94.63
2015.01.01 00:00:00.754 ibm  3100 194.8
..</code></pre>
<p>We find the average daily volume and price for all instruments and store the result for the following example.</p>
<pre class="highlight"><code class="language-q">q)show atrades:select avgqty:avg qty, avgpx:avg px by sym, dt from trades
sym  dt        | avgqty   avgpx
---------------| -----------------
aapl 2015.01.01| 4997.978 99.99409
aapl 2015.01.02| 5006.318 100.0012
aapl 2015.01.03| 5002.49  100.0019
aapl 2015.01.04| 5012.752 99.97018
..</code></pre>
<p>We find the days when the average price went up. Note that create our own <code>deltas0</code> to return 0 for the initial item since the behavior of the built-in <a href="https://code.kx.com/q/ref/deltas/"><code>deltas</code></a> doesn‚Äôt work well for this purpose. Observe that the nested result columns scroll off the page.</p>
<pre class="highlight"><code class="language-q">q)deltas0:{first[x] -': x}
q)select dt, avgpx by sym from atrades where 0&lt;deltas0 avgpx
sym | dt
----| ------------------------------------------------------------------
aapl| 2015.01.02 2015.01.03 2015.01.05 2015.01.07 2015.01.08 2015.01.10..
goog| 2015.01.01 2015.01.02 2015.01.03 2015.01.05 2015.01.07 2015.01.00..
ibm | 2015.01.05 2015.01.07 2015.01.08 2015.01.10 2015.01.11 2015.01.13..</code></pre>
<p>To compact the display, take only the first few field values.</p>
<pre class="highlight"><code class="language-q">q)select 2#dt, 2#avgpx by sym from atrades where 0&lt;deltas0 avgpx
sym | dt                    avgpx
----| ---------------------------------------
aapl| 2015.01.02 2015.01.03 100.0012 100.0019
goog| 2015.01.01 2015.01.02 599.8873 600.0021
ibm | 2015.01.05 2015.01.07 200.0634 200.0022</code></pre>
<p>In order to demonstrate operations on nested columns, we denormalize <code>trades</code> into a keyed table with one row and complex columns for each symbol. We can do this either by grouping without aggregation using select or by using <a href="https://code.kx.com/q/ref/xgroup/"><code>xgroup</code></a>. The difference is that <code>xgroup</code> does not automatically sort on the result key column.</p>
<pre class="highlight"><code class="language-q">q)dntrades:select dt,tm,qty,px by sym from trades
q)dntrades~`sym xasc `sym xgroup trades
1b</code></pre>
<p>We display the first two items of each field to make the structure more evident.</p>
<pre class="highlight"><code class="language-q">q)select 2#dt,2#tm,2#qty,2#px by sym from trades
sym | dt                    tm                        qty       px
----| -----------------------------------------------------------------------
aapl| 2015.01.01 2015.01.01 00:00:00.602 00:00:00.840 540 1260  94.63 92.87
goog| 2015.01.01 2015.01.01 00:00:00.448 00:00:01.039 6940 7260 540.18 560.04
ibm | 2015.01.01 2015.01.01 00:00:00.754 00:00:01.377 3100 5150 194.8 200.96</code></pre>
<p>In such a table with compound columns ‚Äì i.e., lists of simple lists of the same type ‚Äì you will need iterators for column operations. Lots of iterators.</p>
<pre class="highlight"><code class="language-q">q)select sym,cnt:count each dt,avgpx:avg each px from dntrades
sym  cnt     avgpx
---------------------
aapl 3333498 99.99694
goog 3330409 600.02
ibm  3336093 200.0041</code></pre>
<p>We can apply our own unary <code>favg</code> function.</p>
<pre class="highlight"><code class="language-q">q)select sym, favgpx:favg each px from dntrades
sym  favgpx
-------------
aapl 49.99748
goog 300.0155
ibm  100.0009</code></pre>
<p>To find the volume-weighted average price by we use the Each iterator <code>'</code> with the binary <a href="https://code.kx.com/q/ref/wavg/#wavg"><code>wavg</code></a>.</p>
<pre class="highlight"><code class="language-q">q)select sym,vwap:qty wavg' px from dntrades
sym  vwap
-------------
aapl 99.99915
goog 600.0493
ibm  200.0061</code></pre>
<p>Note that this iterator generalizes to <em>n</em>-adic functions for any <em>n</em>&gt;1.</p>
<p>We find the profit of the ideal transaction over the month for each symbol. This is the maximum amount of money that could be made with complete foreknowledge of the market. In other words, find the largest profit obtainable by buying at some traded price and selling at the highest subsequently traded price. To solve this, we reverse the perspective. For each traded price, we look at the minimum of prices that preceded it. The largest such difference is our answer. The maximum draw down is dual.</p>
<pre class="highlight"><code class="language-q">q)select max px-mins px by sym from trades
sym | px
----| ---
aapl| 20
goog| 120
ibm | 40
q)select min px-maxs px by sym from trades
sym | px
----| ----
aapl| -20
goog| -120
ibm | -40</code></pre>
<h3 id="9135-excursion-pivot-table">9.13.5 Excursion ‚Äì Pivot Table</h3>
<p>The objective is to pivot a table on a column (or columns) as in Excel. The construct revolves (pun intended) around three columns. The <code>distinct</code> values of the <em>pivot</em> column become the column names in the result. Each field in the <em>value</em> column is placed under the pivot column whose name appears in its original row. The destination row of a value column field is determined by the <em>key</em> column field in its original row. This is a pivot in the sense that the original vertical arrangement is transformed to horizontal and rows transform to columns. As usual, an example is worth a thousand words.</p>
<p>We begin with the simple table.</p>
<pre class="highlight"><code class="language-q">q)show t:([]k:1 2 3 2 3; p:`a1`a2`a1`a3`a2; v:100 200 300 400 500)
k p  v
--------
1 a1 100
2 a2 200
3 a1 300
2 a3 400
3 a2 500</code></pre>
<p>The desired result <code>pvt</code> is as follows. Observe that this is actually a keyed table but it is simple to unkey it with <a href="https://code.kx.com/q/ref/xkey/3xkey"><code>xkey</code></a>.</p>
<pre class="highlight"><code class="language-q">q)pvt
k| a1  a2  a3 
-| -----------
1| 100        
2|     200 400
3| 300 500    </code></pre>
<p>We break the solution into multiple steps, beginning with our sample table and then successively generalizing to handle a wider class of use cases.</p>
<ol>
<li>
<p>Collect the unique values of the pivot column <code>p</code> into a list <code>P</code>.</p>
<pre><code class="language-q">
q)P:exec distinct p from t
</code></pre>
</li>
<li>
<p>Write a query that extracts the key-value pairs for <code>p</code> and <code>v</code> grouped by <code>k</code>.</p>
<pre><code class="language-q">
q)exec p!v by k from t
_
</code></pre>
</li>
<li>
<p>Enhance the previous query to produce a keyed table by rectangularizing the dictionaries by filling missing values using <code>P#</code>. Magic happens. Observe that we need to name the resulting key column explicitly.</p>
<pre><code class="language-q">
q)exec P#p!v by k:k from t
k| a1  a2  a3 
-| -----------
1| 100      <br>
2|     200 400
3| 300 500  <br>
</code></pre>
</li>
<li>
<p>Write the query to extract the unique values of the pivot column in functional form.</p>
<pre><code class="language-q">
q)P:?[t; (); (); (distinct; `p)]
_
</code></pre>
</li>
<li>
<p>Convert the pivot query to functional form.</p>
<pre><code class="language-q">
q)?[t;(); (1#`k)!1#`k; (#;`P;(!;`p;`v))]
_
</code></pre>
</li>
<li>
<p>Place the previous functional forms in a function that takes the table and the column names as parameters and returns the pivot result.</p>
<pre><code class="language-q">
q)dopivot:{[t; kn; pn; vn]
  P:?[t; (); (); (distinct; pn)];
  ?[t;(); (1#kn)!1#kn; (#;`P;(!;pn;vn))]}
q)dopivot[t;`k;`p;`v]
_
</code></pre>
</li>
<li>
<p>Write an expression that converts the fields of the pivot column to valid names when they are not ‚Äì e.g., integers. In general, producing unique, valid names is a non-trivial exercise. Find a solution that (at least) works on <code>tn</code> below.</p>
<pre><code class="language-q">
q)tn:([] k:1 2 3 2 3; p:(`a1;2;`a1;3;2); v:100 200 300 400 500)
q)mkNames:{
  x:(::),x;
  x:1_x:@[x; where not 10h=type each x; string];
  `$@[x; where not any x[;0] within/: ("AZ";"az"); "X_",]}
q)dopivot:{[t; kn; pn; vn]
  t:![t; (); 0b; (1#pn)!enlist (`mkNames; pn)];
  P:?[t; (); (); (distinct; pn)];
  ?[t;(); (1#kn)!1#kn; (#;`P;(!;pn;vn))]}
q)dopivot[tn;`k;`p;`v]
_
</code></pre>
</li>
<li>
<p>Next, we generalize to the case when there are multiple entries in <code>v</code> for a single key value. For example, applied to <code>tr</code> below, our current <code>dopivot</code> misses the 1000 value in <code>v</code>.</p>
<pre><code class="language-q">
q)tr:([]k:1 2 3 2 3 1; p:`a1`a2`a1`a3`a2`a1; v:100 200 300 400 500 1000)
q)dopivot[tr;`k;`p;`v] / misses 1000 value
k| a1  a2  a3
-| -----------
1| 100      <br>
2|     200 400
3| 300 500  <br>
</code></pre>
<p>We would like to apply an aggregate function such as <code>sum</code> to obtain,</p>
<pre><code class="language-q">
k| a1   a2  a3
-| ------------
1| 1100
2|      200 400
3| 300  500
</code></pre>
<p>Modify <code>dopivot</code> to take an aggregate function <code>agg</code> and apply it to <code>v</code> as part of the pivot process. Test it on <code>tr</code> using <code>sum</code>.</p>
<pre><code class="language-q">
q)dopivot:{[t; agg; kn; pn; vn]
  t:![t; (); 0b; (1#pn)!enlist (`mkNames; pn)];
  t:?[t; (); (kn,pn)!kn,pn; (1#vn)!enlist (agg;vn)];
  P:?[t; (); (); (distinct; pn)];
  ?[t; (); (1#kn)!1#kn; (#;`P;(!;pn;vn))]}
q)dopivot[tr;sum;`k;`p;`v]
_
</code></pre>
</li>
<li>
<p>We would like to handle the case of compound keys ‚Äì e.g., <code>k1</code> and <code>k2</code> in <code>tk</code> below.</p>
<pre><code class="language-q">
q)k1:1 2 3 2 3 1 1
q)k2:10 20 30 40 50 60 10
q)p:`a1`a2`a1`a3`a2`a1`a1
q)v:100 200 300 400 500 1000 10000
q)show tk:([]k1:k1; k2:k2; p:p; v:v)
k1 k2 p  v
--------------
1  10 a1 100
2  20 a2 200
3  30 a1 300
2  40 a3 400
3  50 a2 500
1  60 a1 1000
1  10 a1 10000
</code></pre>
<p>Modify <code>dopivot</code> to take a list of key column names and test it on <code>tk</code>.</p>
<pre><code class="language-q">
q)dopivot:{[t; agg; ks; pn; vn]
  ks,:();
  t:![t; (); 0b; (1#pn)!enlist (`mkNames; pn)];
  t:?[t; (); (ks,pn)!ks,pn; (1#vn)!enlist (agg;vn)];
  P:?[t; (); (); (distinct; pn)];
  ?[t;(); ks!ks; (#;`P;(!;pn;vn))]}
q)dopivot[tk;sum;`k1`k2;`p;`v]
_
</code></pre>
</li>
<li>
<p>Modify <code>dopivot</code> to accept a string argument representing a valid Where phrase for the input table and use it to constrain the pivot. Test it against <code>tk</code> with the phrase <code>k1&lt;&gt;2</code>.</p>
<pre><code class="language-q">
q)dopivot:{[t; agg; wh; ks; pn; vn]
  ks,:();
  c:enlist parse wh;
  t:?[t; c; 0b; (cols t)!cols t];
  t:![t; (); 0b; (1#pn)!enlist (`mkNames; pn)];
  t:?[t; (); (ks,pn)!ks,pn; (1#vn)!enlist (agg;vn)];
  P:?[t; (); (); (distinct; pn)];
  ?[t; (); ks!ks; (#;`P;(!;pn;vn))]}
q)dopivot[tk;sum;"k1&lt;&gt;2";`k1`k2;`p;`v]
_
</code></pre>
</li>
<li>
<p>Finally, modify <code>dopivot</code> to accept an empty list in the aggregate or the where parameters. In the former case, use <code>first</code> as the default aggregate; in the latter, perform no constraint. Test against <code>tk</code> with empty list arguments for both.</p>
<pre><code class="language-q">
q)dopivot:{[t; agg; wh; ks; pn; vn]
  ks,:();
  agg:first agg,first;
  c:$[count wh; enlist parse wh; ()];
  t:?[t; c; 0b; (cols t)!cols t];
  t:![t; (); 0b; (1#pn)!enlist (`mkNames; pn)];
  t:?[t; (); (ks,pn)!ks,pn; (1#vn)!enlist (agg;vn)];
  P:?[t; (); (); (distinct; pn)];
  ?[t; (); ks!ks; (#;`P;(!;pn;vn))]}
q)dopivot[tk;();"";`k1`k2;`p;`v]
_
</code></pre>
</li>
</ol>
<p>We test the efficiency of <code>dopivot</code> by applying it to a modestly large table with a million rows of timeseries data. Take that, Excel!</p>
<pre class="highlight"><code class="language-q">q)t:`date xasc ([] date:2015.01.01+1000000?10; sym:1000000?`aapl`ibm`intc; qty:1+1000000?100)
q)dopivot[t; sum; ""; `date; `sym; `qty] / ymmv
date      | aapl    ibm     intc
----------| -----------------------
2015.01.01| 1688672 1666730 1659389
2015.01.02| 1695257 1688088 1679517
2015.01.03| 1656634 1692806 1688195
2015.01.04| 1686011 1708072 1687046
2015.01.05| 1676870 1683170 1699435
2015.01.06| 1673952 1676820 1687553
2015.01.07| 1683041 1680907 1692974
2015.01.08| 1661363 1688660 1675261
2015.01.09| 1692126 1693217 1690017
2015.01.10| 1698429 1699250 1679042</code></pre>
<p>It is an instructive exercise to write <code>unpivot</code>, which takes a pivoted table and reverts the columns back to rows.</p>
                


                
              
              
                


              
            </article>
            
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))for(var set of document.querySelectorAll("[data-tabs]")){var labels=set.querySelectorAll(":scope > label");e:for(var tab of tabs)for(var label of labels)if(label.innerText.trim()===tab){var input=label.previousElementSibling;input.checked=!0;break e}}</script>

          </div>
        </div>
        
          
        
      
                </div>
            </section>
        
            <section class="chapter" id="chapter-15">
                <div class="chapter-header">
                    <h1 class="chapter-title">A. Built-in Functions¬∂</h1>
                    <div class="chapter-meta">
                        <span>üìñ Source: <a href="https://code.kx.com/q4m3/A_Built-in_Functions/">https://code.kx.com/q4m3/A_Built-in_Functions/</a></span>
                        <span>üìù 12284 words</span>
                        
                    </div>
                </div>
                <div class="chapter-content">
                    
        <div class="md-main__inner md-grid">
          
            
              
              
            
            
              
              
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                
                <h1 id="a-built-in-functions">A. Built-in Functions</h1>
<h3 id="a0-overview">A.0 Overview</h3>
<p>The collection of built-in functions in q is rich and powerful. We include here a user guide for those built-ins that were not covered in the main text. For more details, see the <a href="https://code.kx.com/q/ref/">Reference section at code.kx.com</a>.</p>
<h3 id="a1-acos">A.1 <a href="https://code.kx.com/q/ref/acos/"><code>acos</code></a></h3>
<p>The atomic <code>acos</code> is the mathematical inverse of <code>cos</code>. For a float argument between -1 and 1, <code>acos</code> returns the float between 0 and œÄ whose cosine is the argument.</p>
<pre class="highlight"><code class="language-q">q)acos 1
0f
q)acos 1.414213562373095
0n
q)acos -1
3.141593
q)acos 0
1.570796</code></pre>
<h3 id="a2-all">A.2 <a href="https://code.kx.com/q/ref/all"><code>all</code></a></h3>
<p>The aggregate <code>all</code> is <code>(&amp;/)</code>, which applies <code>&amp;</code> cumulatively across a numeric list and returns the boolean result.</p>
<pre class="highlight"><code class="language-q">q)all 100100b
0b
q)all 10 20 30
1b</code></pre>
<h3 id="a3-and">A.3 <a href="https://code.kx.com/q/ref/and"><code>and</code></a></h3>
<p>The function <code>and</code> is the same as <code>&amp;</code> for people who like typing extra characters.</p>
<pre class="highlight"><code class="language-q">q)1b and 0b
0b
q)42 and 43
42</code></pre>
<h3 id="a4-any">A.4 <a href="https://code.kx.com/q/ref/any"><code>any</code></a></h3>
<p>The aggregate <code>any</code> is <code>(|/)</code>, which applies <code>|</code> cumulatively across a numeric list and returns the boolean result.</p>
<pre class="highlight"><code class="language-q">q)any 100100b
1b
q)any null til 10
0b</code></pre>
<h3 id="a5-asc">A.5 <a href="https://code.kx.com/q/ref/asc"><code>asc</code></a></h3>
<p>The uniform function <code>asc</code> returns its argument list of comparables sorted in ascending order with the <code>`s#</code> attribute applied. When evaluated on a dictionary, it reorders the key-value pairs (on a copy) so that the values are sorted.</p>
<pre class="highlight"><code class="language-q">q)asc 3 7 2 8 1 9
`s#1 2 3 7 8 9
q)asc `b`c`a!3 2 1
a| 1
c| 2
b| 3</code></pre>
<h3 id="a6-asin">A.6 <a href="https://code.kx.com/q/ref/asin"><code>asin</code></a></h3>
<p>The atomic <code>asin</code> is the mathematical inverse of <code>sin</code>. For a float argument between -1 and 1, <code>asin</code> returns the float between ‚ÄìœÄ/2 and œÄ/2 whose sine is the argument.</p>
<pre class="highlight"><code class="language-q">q)asin 0
0f
q)asin 1.414213562373095%2
0.7853982
q)asin 1
1.570796
q)asin -1
-1.570796</code></pre>
<h3 id="a7-atan">A.7 <a href="https://code.kx.com/q/ref/atan"><code>atan</code></a></h3>
<p>The atomic <code>atan</code> is the mathematical inverse of <code>tan</code>. For a float argument, <code>atan</code> returns the float between ‚ÄìœÄ/2 and œÄ/2 whose tangent is the argument.</p>
<pre class="highlight"><code class="language-q">q)atan 0
0f
q)atan 1.414213562373095
0.9553166
q)atan 1
0.7853982</code></pre>
<h3 id="a8-attr">A.8 <a href="https://code.kx.com/q/ref/attr"><code>attr</code></a></h3>
<p>The function <code>attr</code> returns any attribute of its argument as a symbol. No attributes is the empty symbol</p>
<pre class="highlight"><code class="language-q">q)attr til 5
`
q)attr asc 30 20 40 10
`s</code></pre>
<h3 id="a9-avg">A.9 <a href="https://code.kx.com/q/ref/avg"><code>avg</code></a></h3>
<p>The aggregate <code>avg</code> returns the float average of a numeric list.</p>
<pre class="highlight"><code class="language-q">q)avg 1+til 1000
500.5</code></pre>
<p>The function <code>avg</code> is equivalent to</p>
<p><code>{sum[x]%count x}</code></p>
<p>It is possible to apply <code>avg</code> to a nested list provided the sublists conform. In this context, the result conforms to the sublists and the average is calculated recursively on the sublists.</p>
<pre class="highlight"><code class="language-q">q)avg (1 2;100 200;1000 2000)
367 734f</code></pre>
<h3 id="a10-avgs">A.10 <a href="https://code.kx.com/q/ref/avgs"><code>avgs</code></a></h3>
<p>The uniform <code>avgs</code> is <code>(avg\)</code>, which computes the running averages of a numeric list.</p>
<pre class="highlight"><code class="language-q">q)avgs 1+til 10
1 1.5 2 2.5 3 3.5 4 4.5 5 5.5</code></pre>
<h3 id="a11-bin">A.11 <a href="https://code.kx.com/q/ref/bin"><code>bin</code></a></h3>
<p>The binary <code>bin</code> takes a simple list of items (<em>target</em>) sorted in strictly increasing order as its first parameter. It is atomic in its second parameter (<em>source</em>). Loosely speaking, the result of <code>bin</code> is the position at which <em>source</em> would fall in <em>target</em>, looking from the left. The type of <em>source</em> must <strong>strictly</strong> match the type of <em>target</em>; no type promotion is performed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>While the items of the first argument <code>bin</code> should be in strictly increasing order for the result to meaningful, this condition is not enforced. The result of <code>bin</code> when the first argument is not strictly increasing is essentially undefined.</p>
</div>
<p>More precisely, the result is -1 if <em>source</em> is less than the first item in <em>target</em>. Otherwise, the result is the index of the last item of <em>target</em> that is less than or equal to <em>source</em>; this is the found index if <em>source</em> is in <em>target</em>. If <em>source</em> is greater than the last item in <em>target</em>, the result is the last index of <em>target</em></p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>For large sorted lists, the binary search performed by <code>bin</code> can be much faster than the linear search performed by <code>?</code>.</p>
</div>
<p>Here are some examples.</p>
<pre class="highlight"><code class="language-q">q)L:1.0+til 50000000
q)L bin 25000000.
24999999
q)L?25000000.
24999999
q)\t L bin 25000000.
0
q)\t L?25000000.
33
q)L bin 25000000.5
24999999
62
q)L?25000000.5
50000000
q)\t L bin 25000000.5
0
q)\t L?25000000.5
63
q)L bin 50000000.5
49999999
q)L?50000000.5
50000000</code></pre>
<h3 id="a12-binr">A.12 <a href="https://code.kx.com/q/ref/binr"><code>binr</code></a></h3>
<p>The binary <code>binr</code> is closely related to <code>bin</code>. Whereas <code>bin</code> looks from the left, <code>binr</code> looks from the right. The result is the index of the first item of the first parameter that is greater than or equal to the second parameter.</p>
<pre class="highlight"><code class="language-q">q)L:1.0+til 50000000
q)L bin 25000000.5
24999999
q)L binr 25000000.5
25000000</code></pre>
<h3 id="a13-rolldeal">A.13 <a href="https://code.kx.com/q/ref/deal">Roll/Deal <code>?</code></a></h3>
<p>The binary operators Roll and Deal generate pseudo-random results.</p>
<p>In the case where the first parameter is a non-negative long and the second parameter is a non-negative numeric value (<em>bound</em>), <code>?</code> returns a list of pseudo-random numbers <strong>with replacement</strong> between 0 and <em>bound</em>, not including <em>bound</em>.</p>
<pre class="highlight"><code class="language-q">q)5?10
2 4 5 4 2
q)5?10
7 8 5 6 4
q)10?100.0
10.24432 86.71096 72.78528 16.27662 68.84756 81.77547 75.20102 10.86824 95.98..
q)10?100.0
64.30982 67.08738 67.89082 41.2317 98.77844 38.67353 72.6781 40.46546 83.5506..</code></pre>
<p>In the case where the first parameter is a negative long and the second parameter is a non-negative long (<em>bound</em>), <code>?</code> returns a list of pseudo-random numbers <strong>without replacement</strong> between 0 and <em>bound</em>, not including <em>bound</em>.</p>
<pre class="highlight"><code class="language-q">q)-5?10
1 8 5 7 0
q)5?10
2 4 5 4 2</code></pre>
<div class="admonition note">
<p class="admonition-title">Zen Moment</p>
<p>The expression <code>‚Äìn?n</code> returns a random permutation of <code>til n</code>.</p>
</div>
<p>In a case where the second parameter is a list (<em>source</em>) and the first parameter is a long (<em>count</em>), <code>?</code> returns a list of <em>count</em> items randomly drawn from <em>source</em>, with replacement for positive <em>count</em> and without replacement for negative <em>count</em>.</p>
<pre class="highlight"><code class="language-q">q)5?`a`b`c`d`e`f
`b`c`f`f`b
q)5?`a`b`c`d`e`f
`e`e`a`e`e
q)-5?`a`b`c`d`e`f
`c`a`d`f`e
q)-5?`a`b`c`d`e`f
`f`a`e`d`c</code></pre>
<p>In a case where the first parameter is a positive long (<em>count</em>) and the second argument is a symbol of the form `<em>n</em> where <em>n</em> is a positive integer no greater than eight, the result is a random list of <em>count</em> symbols, each comprising exactly <em>n</em> characters. The symbols are distinct when <em>count</em> is negative.</p>
<pre class="highlight"><code class="language-q">q)10?`1
`c`d`o`m`h`m`n`e`m`m
q)-10?`1
`h`p`j`n`e`o`a`k`l`i
q)-10?`3
`emb`agl`mho`ndm`gmj`egi`gek`hcc`mmb`kbh</code></pre>
<h3 id="a14-enum-extend">A.14 <a href="https://code.kx.com/q/ref/enum-extend">Enum Extend <code>?</code></a></h3>
<p>Enum Extend <code>?</code> has as first parameter the symbolic name of a (presumably unique) list of symbols (<em>target</em>). It is atomic in the second parameter, which is a symbol (<em>source</em>). The result is the enumeration of <em>source</em> over <em>target</em>, where <em>source</em> is appended to <em>target</em> if it is not already contained therein. As a side effect of the function, symbols from <em>source</em> not in <em>target</em> are appended to <em>target</em>.</p>
<pre class="highlight"><code class="language-q">q)sym:`a`b`c
q)`sym?`a`x`b`y`z
`sym$`a`x`b`y`z
q)sym
`a`b`c`x`y`z</code></pre>
<h3 id="a15-cor">A.15 <a href="https://code.kx.com/q/ref/cor"><code>cor</code></a></h3>
<p>The binary <code>cor</code> takes two numeric lists of the same count and returns the mathematical correlation between the items of the two lists as a float.</p>
<pre class="highlight"><code class="language-q">q)23 -11 35 0 cor 42 21 73 39
0.9070229</code></pre>
<p>The function <code>cor</code> is equivalent to</p>
<p><code>{cov[x;y]%dev[x]*dev y}</code></p>
<h3 id="a16-count">A.16 <a href="https://code.kx.com/q/ref/count"><code>count</code></a></h3>
<p>The aggregate <code>count</code> returns a long representing the number of items in its atom or list parameter. As with any function defined on lists, it also applies to the value list of a dictionary and hence to tables and keyed tables.</p>
<pre class="highlight"><code class="language-q">q)count 42
1
q)count til 100
100
q)count `a`b`c`d!10 20 30 40
4
q)count ([] c1:10 20 30; c2:1.1 2.2 3.3)
3
q)count ([k:10 20] c:`one`two)
2</code></pre>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>You cannot use <code>count</code> to determine whether an entity is an atom or list since atoms and singletons both have count 1. Instead test the sign of the type.
</p><pre><code class="language-q">
q)0&gt;signum type 42
1b
q)0&gt;signum type enlist 42
0b
</code></pre>
</div>
<div class="admonition tip">
<p class="admonition-title">Do you know why they call it <code>count</code>? Because it loves to count! Nyah, ha, ha, ha, ha. Vun, and two, and tree, and ‚Ä¶</p>
</div>
<h3 id="a17-cov">A.17 <a href="https://code.kx.com/q/ref/cov"><code>cov</code></a></h3>
<p>The binary <code>cov</code> takes two numeric lists of the same length and returns a float equal to the mathematical covariance between the items of the two lists. If both arguments are lists, they must have the same count; atoms return <code>0f</code>.</p>
<pre class="highlight"><code class="language-q">q)23 -11 35 0 cov 42 21 73 39
411.25</code></pre>
<p>The function <code>cov</code> is equivalent to,</p>
<p><code>{avg[x*y]-avg[x]*avg y}</code></p>
<h3 id="a18-cross">A.18 <a href="https://code.kx.com/q/ref/cross"><code>cross</code></a></h3>
<p>The binary <code>cross</code> takes atoms or lists as arguments and returns their Cartesian product ‚Äì that is, the set of all pairs drawn from the two arguments.</p>
<pre class="highlight"><code class="language-q">q)1 2 cross `a`b`c
1 `a
1 `b
1 `c
2 `a
2 `b
2 `c</code></pre>
<div class="admonition tip">
<p class="admonition-title">You can also apply <code>cross</code> to dictionaries and tables.</p>
</div>
<p>The function <code>cross</code> is equivalent to,</p>
<p><code>{raze x,\:/:y}</code></p>
<h3 id="a19-cut">A.19 <a href="https://code.kx.com/q/ref/cut"><code>cut</code></a></h3>
<p>The binary function <code>cut</code> can take a list of long (<em>indices</em>) as its first parameter and a list (<em>source</em>) as it right parameter. It returns the list obtained by splitting <em>source</em> at the positions in <em>indices</em>.</p>
<div class="admonition tip">
<p class="admonition-title">If the initial item of indices is not 0, the first sublist split out is dropped.</p>
</div>
<pre class="highlight"><code class="language-q">q)L:10 20 30 40 50 60 70 80 90 100
q)0 2 5 7 cut L
10 20
30 40 50
60 70
80 90 100
q)2 5 7 cut L
30 40 50
60 70
80 90 100</code></pre>
<p>When the first parameter is a non-negative integral atom (<em>width</em>), <em>source</em> is split at indices that are multiples of <em>width</em>.</p>
<pre class="highlight"><code class="language-q">q)2 cut L
10 20
30 40
50 60
70 80
90 100
q)3 cut L
10 20 30
40 50 60
70 80 90
,100</code></pre>
<h3 id="a20-cut-_">A.20 <a href="https://code.kx.com/q/ref/cut">cut <code>_</code></a></h3>
<p>The binary function <code>_</code> has several forms, depending on the types of its parameters. See also <a href="https://code.kx.com/q/ref/drop/">Drop</a> and <a href="https://code.kx.com/q/ref/cut/"><code>cut</code></a>.</p>
<div class="admonition tip">
<p class="admonition-title">When <code>_</code> is used infix, surrounding it with whitespace will avoid it getting mixed up with variable names, since <code>_</code> is a valid q name character.</p>
</div>
<p>When the first parameter is an integral atom (<em>count</em>) and the second parameters is a list (<em>source</em>), the result is <em>source</em> with <em>count</em> items dropped from the head <em>if</em> count is positive and from the tail when <em>count</em> is negative.</p>
<pre class="highlight"><code class="language-q">q)2 _ 10 20 30 40 50 60 70 80 90 100
30 40 50 60 70 80 90 100
q)-2 _ 10 20 30 40 50 60 70 80 90 100
10 20 30 40 50 60 70 80</code></pre>
<p>When the first parameter of <code>_</code> is a list of long (<em>indices</em>) and the second parameter as a list (<em>source</em>) , it returns the list obtained by splitting <em>source</em> at the positions in <em>indices</em>. This is the same behavior as <code>cut</code> for this signature.</p>
<div class="admonition tip">
<p class="admonition-title">If the initial item of indices is not 0, the first sublist split out is dropped.</p>
</div>
<pre class="highlight"><code class="language-q">q)L:10 20 30 40 50 60 70 80 90 100
q)0 2 5 7 _ L
10 20
30 40 50
60 70
80 90 100
q)2 5 7 _ L
30 40 50
60 70
80 90 100</code></pre>
<p>When the second parameter of <code>_</code> is a dictionary (<em>source</em>) and the first parameter is a list of key values whose type matches <em>source</em>, the result is a dictionary obtained by removing the specified key-value pairs from the target. Since tables and keyed tables are dictionaries, <code>_</code> applies to them by extension.</p>
<pre class="highlight"><code class="language-q">q)`a`c _ `a`b`c!10 20 30
b| 20
q)`c1`c2 _ ([] c1:`a`b; c2:10 20; c3:1.1 2.2)
c3
---
1.1
2.2
q)([] k:`a`c) _ ([k:`a`b`c] v:10 20 30)
k| v
-| --
b| 20</code></pre>
<div class="admonition tip">
<p class="admonition-title">The first parameter must be a list, so a single value for the first parameter in this form must be enlisted.</p>
</div>
<pre class="highlight"><code class="language-q">q)(enlist `b) _ `a`b`c!10 20 30
a| 10
c| 30</code></pre>
<p>When the first parameter of <code>_</code> is a list or a dictionary (<em>source</em>) and the second parameter is an atom representing an index or key, the result is obtained by deleting the specified item from (a copy of) <em>source</em>.</p>
<pre class="highlight"><code class="language-q">q)101 102 103 104 105 _ 2
101 102 104 105
q)(`a`b`c!10 20 30) _ `b
a| 10
c| 30
q)([] c1:`a`b; c2:10 20; c3:1.1 2.2) _ 1
c1 c2 c3
---------
a 10 1.1
q)([k:101 102 103] c:`one`two`three) _ 102
k | c
---| -----
101| one
103| three</code></pre>
<h3 id="a21-deltas">A.21 <a href="https://code.kx.com/q/ref/deltas"><code>deltas</code></a></h3>
<p>The uniform <code>deltas</code> is <code>(-':)</code>, which returns the difference of each item in a numeric list with its predecessor.</p>
<pre class="highlight"><code class="language-q">q)deltas 1 2 3 4 5
1 1 1 1 1
q)deltas 96.25 93.25 58.25 73.25 89.50 84.00 84.25
96.25 -3 -35 15 16.25 -5.5 0.25</code></pre>
<p>If you are looking to bound the absolute difference between successive elements, the second example shows that the initial item of the result will be troublesome. In this case, you can use,</p>
<p><code>deltas0:{first[x] ‚Äì': x}</code></p>
<p>In our example above,</p>
<pre class="highlight"><code class="language-q">q)deltas0 96.25 93.25 58.25 73.25 89.50 84.00 84.25
0 -3 -35 15 16.25 -5.5 0.25</code></pre>
<h3 id="a22-desc">A.22 <a href="https://code.kx.com/q/ref/desc"><code>desc</code></a></h3>
<p>The uniform <code>desc</code> returns (a copy of) its argument list of comparables sorted in descending order. When evaluated on a dictionary, it reorders the key-value pairs (on a copy) so that the values are sorted.</p>
<pre class="highlight"><code class="language-q">q)desc 3 7 2 8 1 9
9 8 7 3 2 1
q)desc `b`c`a!2 3 1
c| 3
b| 2
a| 1</code></pre>
<h3 id="a23-dev">A.23 <a href="https://code.kx.com/q/ref/dev"><code>dev</code></a></h3>
<p>The aggregate <code>dev</code> returns the float standard deviation of a numeric list.</p>
<pre class="highlight"><code class="language-q">q)dev 1000?100.
29.40271</code></pre>
<p>The function <code>dev</code> is equivalent to,</p>
<p><code>{sqrt var x}</code></p>
<h3 id="a24-differ">A.24 <a href="https://code.kx.com/q/ref/differ"><code>differ</code></a></h3>
<p>The uniform <code>differ</code> is</p>
<p><code>not (~':)</code></p>
<p>It asks if each item in a list is not identical to its predecessor. The item at index 0 in the result is always <code>1b</code>.</p>
<pre class="highlight"><code class="language-q">q)differ 0 1 1 2 3 2 2 2 4 1 1 3 4 4 4 4 5
11011100110110001b
q)differ "mississippi"
q)differ (1 2; 1 2; 3 4 5)
101b</code></pre>
<p>One use of <code>differ</code> is to locate runs of repeated items in a list.</p>
<pre class="highlight"><code class="language-q">q)L:0 1 1 2 3 2 2 2 4 1 1 3 4 4 4 4 5
q)nd|next nd:not differ L
01100111011011110b</code></pre>
<h3 id="a25-distinct">A.25 <a href="https://code.kx.com/q/ref/distinct"><code>distinct</code></a></h3>
<p>The function <code>distinct</code> returns the unique items in its list argument, in order of first occurrence. Note that it does <strong>not</strong> apply the <code>`u#</code> attribute.</p>
<pre class="highlight"><code class="language-q">q)distinct 1 2 3 2 3 4 6 4 3 5 6
1 2 3 4 6 5</code></pre>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Following is a test for existence of duplicates.
<code>{count[x]=count distinct x}</code></p>
</div>
<p>Since a table is a list of records, <code>distinct</code> effectively removes duplicate rows. All fields‚Äô records must be identical for them to be considered identical.</p>
<pre class="highlight"><code class="language-q">q)distinct ([]a:1 2 3 2 1; b:`washington`adams`jefferson`adams`washington)
a b
------------
1 washington
2 adams
3 jefferson
q)distinct ([]a:1 2 3 2 1; b:`washington`adams`jefferson`adams`wasington)
_</code></pre>
<h3 id="a26-enlist">A.26 <a href="https://code.kx.com/q/ref/enlist"><code>enlist</code></a></h3>
<p>The function <code>enlist</code> returns a list whose items comprise its arguments. The most common use is to create a singleton list from a single argument.</p>
<p>Unlike user-defined functions, the number of arguments to <code>enlist</code> is not restricted to eight.</p>
<pre class="highlight"><code class="language-q">q)enlist 42
,42
q)count enlist 10 20 30
1
q)enlist[1;2;3;4;5;6;7;8;9;10]
1 2 3 4 5 6 7 8 9 10</code></pre>
<h3 id="a27-eval">A.27 <a href="https://code.kx.com/q/ref/eval"><code>eval</code></a></h3>
<p>The unary <code>eval</code> evaluates a list that is a valid q parse tree; it is the same code used in the q interpreter. Such a list can be produced using <code>parse</code> on a string containing a valid q expression, or by hand ‚Äì if you know what you're doing. A full discussion of parse trees is beyond the scope of this tutorial.</p>
<pre class="highlight"><code class="language-q">q)eval parse "a:6*7"
42
q)a
42
q)eval (+;1;(*;6;7))
43</code></pre>
<h3 id="a28-except">A.28 <a href="https://code.kx.com/q/ref/except"><code>except</code></a></h3>
<p>The binary <code>except</code> takes a list (or dictionary) as its first parameter (<em>target</em>) and an atom or list of items (or keys) of the same type as <em>target</em> for its second parameter (<em>source</em>) and returns those items in <em>target</em> that are not specified in <em>source</em>. The returned items are in the order of their first occurrence in <em>target</em>.</p>
<pre class="highlight"><code class="language-q">q)1 2 3 4 3 2 except 2
1 3 4 3
q)string[2015.01.01] except "."
"20150101"
q)(`a`b`c`d!10 20 30 40) except `a`d!10 40
20 30
q)([] c1:`a`b`c`d; c2:10 20 30 40) except ([] c1:`a`d; c2:10 40)
c1 c2
-----
b 20
c 30</code></pre>
<div class="admonition info">
<p class="admonition-title">The result of <code>except</code> is always a list.</p>
</div>
<h3 id="a29-exit">A.29 <a href="https://code.kx.com/q/ref/exit"><code>exit</code></a></h3>
<p>The unary <code>exit</code> takes a long as its parameter (<em>retval</em>) and causes the q process to exit, returning <em>retval</em> to the OS.</p>
<div class="admonition warning">
<p class="admonition-title">There is no prompt for confirmation.</p>
</div>
<h3 id="a30-fill">A.30 <a href="https://code.kx.com/q/ref/fill">Fill <code>^</code></a></h3>
<p>The binary <em>fill</em> <code>^</code> takes a list as its second parameter (<em>target</em>) and an atom of the same type as its first parameter (<em>fillval</em>). It returns (a copy of) <em>target</em> with null values filled with <em>fillval</em>.</p>
<pre class="highlight"><code class="language-q">q)42^1 2 3 0N 5 0N
1 2 3 42 5 42
q)"_"^"Now is the time"
"Now_is_the_time"
q)`NA^`First`Second``Fourth
`First`Second`NA`Fourth</code></pre>
<p><em>Fill</em> is atomic in the second parameter.</p>
<pre class="highlight"><code class="language-q">q)42^(1;0N;(100;200 0N))
1
42
(100;200 42)</code></pre>
<p>Like all functions, <em>fill</em> operates on the values of a dictionary.</p>
<pre class="highlight"><code class="language-q">q)42^`a`b`c`d!100 0N 200 0
a| 100
b| 42
c| 200
d| 0
q)0^([]c1:1.0 2.0 0n; c2:0N 2 0N)
c1 c2
-----
1 0
2 2
0 0</code></pre>
<h3 id="a31-find">A.31 <a href="https://code.kx.com/q/ref/find">Find <code>?</code></a></h3>
<p>The binary operator <code>?</code> Find takes a list (<em>target</em>) as its first parameter and an atom of the same type (<em>source</em>) as its second parameter. It returns the index of the first occurrence of <em>source</em> in <em>target</em> or the count of <em>target</em> if it is not found. It is atomic in the second parameter.</p>
<p>The simplest case is when <em>source</em> is an atom.</p>
<pre class="highlight"><code class="language-q">q)100 99 98 87 96 98?98
2
q)`one`two`three?`four
3
q)"Now is the time"?"the"
7 8 9</code></pre>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The first example demonstrates that Find returns only the index of the first occurrence of source. To find the indices of all occurrences you could use,</p>
<pre><code class="language-q">
q){where x=y}[100 99 98 87 96 98;98]
2 5
</code></pre>
</div>
<p>Find also works on general lists, although if you need this you should probably consider redesigning your program.</p>
<pre class="highlight"><code class="language-q">q)(1 2; 3 4; `a`b)?`a`b
2
q)((0;1 2);3 4;5 6)?5 6
2</code></pre>
<p>Find can also take a dictionary as its first parameter (<em>target</em>) and a dictionary value as its second parameter <code>*value*</code>. It returns the first key that maps to <em>value</em>. It is atomic in the second parameter.</p>
<pre class="highlight"><code class="language-q">q)(`a`b`c`d!10 20 30 10)?10
`a
q)(`a`b`c`d!10 20 30 10)?10 30
`a`c</code></pre>
<p>By extension, find applies to tables and keyed tables.</p>
<pre class="highlight"><code class="language-q">q)([] c1:`a`b`c; c2:10 20 30)?`c1`c2!(`b;20)
1
q)([] c1:`a`b`c; c2:10 20 30)?(`b;20)
1
q)([k:1 2 3] c:100 101 102)?101
k| 2</code></pre>
<div class="admonition note">
<p class="admonition-title">Zen Moment</p>
<p>Viewing a list or dictionary as a mapping, Find is the inverse mapping.</p>
</div>
<h3 id="a32-fills">A.32 <a href="https://code.kx.com/q/ref/fills"><code>fills</code></a></h3>
<p>The uniform <code>fills</code> is <code>^\</code>, which fills forward, meaning that non-null items are filled over succeeding null items.</p>
<pre class="highlight"><code class="language-q">q)fills 1 0N 3 0N 0N 5
1 1 3 3 3 5
q)fills `x``y```z
`x`x`y`y`y`z
q)update fills c2 from ([] `a`b`c`d`e`f; c2:1 0N 3 0N 0N 5)
x c2
----
a 1
b 1
c 3
d 3
e 3
f 5</code></pre>
<p>If you need to fill initial nulls, use the binary form of <code>^\</code>.</p>
<pre class="highlight"><code class="language-q">q)fills 0N 0N 3 0N 5
0N 0N 3 3 5
q)0 ^\ 0N 0N 3 0N 5
0 0 3 3 5</code></pre>
<h3 id="a33-flip">A.33 <a href="https://code.kx.com/q/ref/flip"><code>flip</code></a></h3>
<p>The unary function <code>flip</code> transposes a rectangular list, column dictionary or table (<em>source</em>).</p>
<p>When <em>source</em> is a rectangular list, the items are rearranged, effectively reversing the first two indices in indexing. For example,</p>
<pre class="highlight"><code class="language-q">q)show m:(1 2 3;10 20 30)
1 2 3
10 20 30
q)flip m
1 10
2 20
3 30</code></pre>
<p>When <code>flip</code> converts a column dictionary to a table and vice versa, no data is actually rearranged. Only column indexing is reversed.</p>
<pre class="highlight"><code class="language-q">q)dc:`c1`c2!(`a`b`c;10 20 30)
q)t:([] c1:`a`b`c; c2:10 20 30)
q)dc[`c1;2]~t[2;`c1]</code></pre>
<h3 id="a34-getenv">A.34 <a href="https://code.kx.com/q/ref/getenv"><code>getenv</code></a></h3>
<p>The unary function <code>getenv</code> takes a symbol argument representing the name of an OS environment variable and returns the value <code>if any</code> of that environment variable as a string.</p>
<pre class="highlight"><code class="language-q">q)getenv `SHELL
"/bin/bash"</code></pre>
<h3 id="a35-group">A.35 <a href="https://code.kx.com/q/ref/group"><code>group</code></a></h3>
<p>The unary function <code>group</code> takes a list (<em>source</em>) and returns a dictionary in which each distinct item in <em>source</em> is mapped to the indices of its occurrences in <em>source</em>. The keys of the result are in the order of their first appearance in <em>source</em>.</p>
<pre class="highlight"><code class="language-q">q)group "i miss mississippi"
i| 0 3 8 11 14 17
 | 1 6
m| 2 7
s| 4 5 9 10 12 13
p| 15 16</code></pre>
<h3 id="a36-gtime">A.36 <a href="https://code.kx.com/q/ref/gtime/"><code>gtime</code></a></h3>
<p>The atomic <code>gtime</code> converts local time to UTC time.</p>
<pre class="highlight"><code class="language-q">q).z.P
2015.04.12D12:10:20.685653000
q)gtime .z.P
2015.04.12D22:10:24.861692000
q).z.p
2015.04.12D22:10:28.597654000</code></pre>
<h3 id="a37-iasc">A.37 <a href="https://code.kx.com/q/ref/iasc/"><code>iasc</code></a></h3>
<p>The uniform <code>iasc</code> takes a list or a dictionary (<em>source</em>). Considering <em>source</em> as a mapping, the result of <code>iasc</code> is a list of the indices/keys of source in the order that would sort it ascending. Otherwise put, composing <em>source</em> with the result of <code>iasc</code> sorts in ascending order.</p>
<pre class="highlight"><code class="language-q">q)L:30 70 20 80 10 90
q)iasc L
4 2 0 1 3 5

q)L iasc L
10 20 30 70 80 90

q)d:`c`a`b!30 10 20
q)iasc d
`a`b`c
q)d iasc d
10 20 30</code></pre>
<p>This is useful when you want to use one list to control the order of others ‚Äì e.g., manual sort on the serialized columns of a splayed table (see <a href="https://code.kx.com/q4m3/14_Introduction_to_Kdb%2B/#143-partitioned-tables">¬ß14.3</a>).</p>
<div class="admonition note">
<p class="admonition-title">Zen Moment</p>
<p>The composite <code>iasc iasc</code> provides the list of indices that transforms the sorted entity back to the original.</p>
</div>
<h3 id="a38-identity">A.38 <a href="https://code.kx.com/q/ref/identity/">Identity <code>::</code></a></h3>
<p>The unary operator denoted <code>::</code> is the identity function ‚Äì i.e., it returns its argument.</p>
<pre class="highlight"><code class="language-q">q)::[42]
42
q)(::) `Zaphod
`Zaphod</code></pre>
<p>The identity function <strong>cannot</strong> be used naked with prefix syntax or <code>@</code>. You must either enclose it in parentheses or enclose its argument in square brackets.</p>
<h3 id="a39-idesc">A.39 <a href="https://code.kx.com/q/ref/idesc/"><code>idesc</code></a></h3>
<p>The unary function <code>idesc</code> takes a list or a dictionary (<em>source</em>). Considering <em>source</em> as a mapping, the result of <code>idesc</code> is a list of the indices/keys of source in the order that would sort it descending. Otherwise put, composing <em>source</em> with the result of <code>idesc</code> sorts in descending order.</p>
<pre class="highlight"><code class="language-q">q)L:30 70 20 80 10 90
q)idesc L
5 3 1 0 2 4
q)L idesc L
90 80 70 30 20 10
q)d:`c`a`b!30 10 20
q)idesc d
`c`b`a
q)d idesc d
30 20 10</code></pre>
<p>This is useful when you want to use one list to control the order of others ‚Äì e.g., manual sort on the serialized columns of a splayed table (see <a href="https://code.kx.com/q4m3/14_Introduction_to_Kdb%2B/#142-splayed-tables">¬ß14.2</a>).</p>
<div class="admonition note">
<p class="admonition-title">Zen Moment</p>
<p>The composite <code>idesc idesc</code> provides the list of indices that transforms the sorted entity back to the original.</p>
</div>
<h3 id="a40-in">A.40 <a href="https://code.kx.com/q/ref/in/"><code>in</code></a></h3>
<p>The binary function <code>in</code> is atomic in its first parameter (<em>source</em>) and takes an atom or list second parameter (<em>target</em>). It returns a boolean indicating whether <em>source</em> appears in <em>target</em>. The comparison is strict with regard to type.</p>
<pre class="highlight"><code class="language-q">q)42 in 0 6 7 42 98
1b
q)4 in 42
0b
q)"4" in "42"
1b
q)"cat" in "abcdefg"
110b</code></pre>
<h3 id="a41-inter">A.41 <a href="https://code.kx.com/q/ref/inter/"><code>inter</code></a></h3>
<p>The binary <code>inter</code> returns the items in its first list parameter that occur in its second list parameter.</p>
<pre class="highlight"><code class="language-q">q)1 2 3 4 inter 3 4 5
3 4</code></pre>
<p>Lists differ from sets in that they are ordered and allow duplicates, so <code>inter</code> is not commutative in general.</p>
<pre class="highlight"><code class="language-q">q)1 2 3 1 inter 4 1
1 1
q)4 1 inter 1 2 3 1
,1
q)1 2 3 inter 4 3 2
2 3
q)4 3 2 inter 1 2 3
3 2</code></pre>
<p>You can use <code>inter</code> to find common records in tables having identical schemas.</p>
<pre class="highlight"><code class="language-q">q)t1:([] c1:`a`b`c; c2:10 20 30)
q)t2:([] c1:`c`d; c2:30 40)
q)t1 inter t2
c1 c2
-----
c  30</code></pre>
<h3 id="a42-inv">A.42 <a href="https://code.kx.com/q/ref/inv/"><code>inv</code></a></h3>
<p>The unary <code>inv</code> returns the inverse of a float matrix.</p>
<pre class="highlight"><code class="language-q">q)m:(1.1 2.1 3.1; 2.3 3.4 4.5; 5.6 7.8 9.8)
q)inv m
-8.165138 16.51376 -5
12.20183 -30.18349 10
-5.045872 14.58716 -5</code></pre>
<p>An integer matrix must be cast to float.</p>
<h3 id="a43-join">A.43 <a href="https://code.kx.com/q/ref/join/">Join <code>,</code></a></h3>
<p>The binary operator Join <code>,</code> appends its second parameter to the first. When both operands are either lists or atoms, the result concatenates the second parameter to the first.</p>
<pre class="highlight"><code class="language-q">q)1,2 3 4
1 2 3 4

q)1 2 3,4
1 2 3 4

q)1 2,3 4
1 2 3 4</code></pre>
<p>The result is a general list unless all items are of homogeneous type.</p>
<pre class="highlight"><code class="language-q">q)1 2 3,4.0
1
2
3
4f</code></pre>
<p>When both parameters are dictionaries, the result is the merge of the second parameter into the first using upsert semantics. Otherwise put, assignments in the second parameter prevail over those in the first.</p>
<pre class="highlight"><code class="language-q">q)(`a`b`c!10 20 30),`c`d!300 400
a| 10
b| 20
c| 300
d| 400</code></pre>
<p>By extension, you can use <code>,</code> on tables and keyed tables with identical schemas.</p>
<h3 id="a44-key">A.44 <a href="https://code.kx.com/q/ref/key/"><code>key</code></a></h3>
<p>The <code>key</code> operator vies for the title of most overloaded q operator. Its eponymous action is to return the key of a dictionary, including the special case of the key table portion of a keyed table. It can be applied by value or name.</p>
<pre class="highlight"><code class="language-q">q)key `a`b`c!10 20 30
_
q)kt:([k:`a`b`c] v:10 20 30)
q)key kt
_
q)key `kt
_</code></pre>
<p>A context ‚Äì i.e. the content of a namespace ‚Äì is a dictionary, so <code>key</code> applied to the symbolic name will return the names of its constituents. Observe that contexts below the root all have an initial null name.</p>
<pre class="highlight"><code class="language-q">q)key `.
_
q).jab.a:42
q)key `.jab
_</code></pre>
<p>To list all contexts, apply <code>key</code> to the null symbol.</p>
<pre class="highlight"><code class="language-q">q)key `
`q`Q`h`j`o`jab</code></pre>
<p>Given a <strong>simple</strong> list, <code>key</code> returns the symbolic name of its type.</p>
<pre class="highlight"><code class="language-q">q)key 10 20 30
`long
q)key "so long"
_</code></pre>
<p>Given an enumerated entity, <code>key</code> returns the name of its enumeration domain. This applies to foreign key columns, where it returns the name of the target keyed table.</p>
<pre class="highlight"><code class="language-q">q)sym:`c`b`a
q)key `sym$`a`b`a`c`a
_

q)kt:([k:`a`b`c] v:10 20 30)
q)t:([] k:`kt$`a`b`a`b`a; v: 10 20 30 49 59)
q)key t `k
_</code></pre>
<p>Given an I/O handle corresponding to a directory, <code>key</code> returns a list of the symbolic names of entities in that directory, including hidden files.</p>
<pre class="highlight"><code class="language-q">q)\ls q
"README.txt"
"m32"
"q.k"
"q.q"
"s.k"
"sp.q"
"trade.q"

q)key `:q
`.DS_Store`README.txt`m32`q.k`q.q`s.k`sp.q`trade.q</code></pre>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>An empty directory returns an empty list of type symbol whereas a non-existent directory returns an empty general list.</p>
</div>
<p>This provides a simple test for the existence of a directory.</p>
<pre class="highlight"><code class="language-q">q)\ls q/jab
ls: q/jab: No such file or directory
'os
q)()~key `:q/jab
1b
q)\mkdir q/jab
q)key `:q/jab
`symbol$()</code></pre>
<p>Given an I/O handle corresponding to a file, <code>key</code> returns the symbolic file name if the file exists and the general empty list <code>()</code> if it does not. As above, this provides a test for existence of the file.</p>
<pre class="highlight"><code class="language-q">q)key `:q/trade.q
`:q/trade.q
q)()~key `:q/quote.q
1b</code></pre>
<p>Last, but not least, <code>key</code> also acts as a synonym of <code>til</code>.</p>
<pre class="highlight"><code class="language-q">q)key 10
_</code></pre>
<h3 id="a45-like">A.45 <a href="https://code.kx.com/q/ref/like/"><code>like</code></a></h3>
<p>The binary <code>like</code> performs pattern matching on its first string parameter (<em>source</em>) according to the pattern in its string second parameter (<em>pattern</em>). It returns a boolean result indicating whether <em>pattern</em> is matched. The pattern is expressed as a mix of regular characters and special formatting characters. The special chars are <code>?,</code>*<code>, the pair</code>[<code>and</code>], and a <code>^</code> that is enclosed in square brackets.</p>
<p>The special char <code>?</code> represents an arbitrary single character in the pattern.</p>
<pre class="highlight"><code class="language-q">q)"fan" like "f?n"
1b
q)"fun" like "f?n"
1b
q)"foP" like "f?p"
0b</code></pre>
<p>The special char <code>*</code> represents an arbitrary sequence of characters in the pattern.</p>
<p>As of this writing (Sep 2015), only a single occurrence of <code>*</code> is allowed in the pattern, except that a <code>*</code> can occur at both the beginning and end of the pattern.</p>
<pre class="highlight"><code class="language-q">q)"how" like "h*"
1b

q)"hercules" like "h*"
1b

q)"wealth" like "*h"
1b

q)"flight" like "*h*"
1b

q)"Jones" like "J?ne*"
1b

q)"Joynes" like "J*ne*"
'nyi</code></pre>
<p>The special character pair <code>[</code> and <code>[</code> encloses a sequence of alternatives for a single character match.</p>
<pre class="highlight"><code class="language-q">q)"flap" like "fl[ao]p"
1b

q)"flip" like "fl[ao]p"
0b

q)"459-0609" like "[0-9][0-9][0-9]-0[0-9][0-9][0-9]"
1b

q)"459-0609" like "[0-9][0-9][0-9]-1[0-9][0-9][0-9]"
0b</code></pre>
<p>The special character <code>^</code> is used in conjunction with <code>[</code> and <code>]</code> to indicate that the enclosed sequence of characters is disallowed. For example, to test whether a string ends in a numeric character,</p>
<pre class="highlight"><code class="language-q">q)"M26d" like "*[^0-9]"
1b

q)"Joe999" like "*[^0-9]"
0b</code></pre>
<p>Enclose a special char in square brackets to escape it as a normal char.</p>
<pre class="highlight"><code class="language-q">q)"a_c" like "a[*]"
0b

q)"a*c" like "a[*]c"
1b</code></pre>
<h3 id="a46-lower">A.46 <a href="https://code.kx.com/q/ref/lower/"><code>lower</code></a></h3>
<p>The atomic <code>lower</code> takes a char, string or symbol argument and returns the result of converting all alpha text to lower case.</p>
<pre class="highlight"><code class="language-q">q)lower `A
`a

q)lower "a Bc42De"
"a bc42de"</code></pre>
<h3 id="a47-lsq">A.47 <a href="https://code.kx.com/q/ref/lsq/"><code>lsq</code></a></h3>
<p>The binary matrix function <code>lsq</code> takes float matrix parameters A and B and returns the matrix X that solves the following matrix equation, where ¬∑ is matrix multiplication.</p>
<p>A = X¬∑B</p>
<p>For example,</p>
<pre class="highlight"><code class="language-q">q)A:(1.1 2.2 3.3;4.4 5.5 6.6;7.7 8.8 9.9)
q)B:(1.1 2.1 3.1; 2.3 3.4 4.5; 5.6 7.8 9.8)
q)A lsq B
1.211009 -0.1009174 2.993439e-12
-2.119266 2.926606 -3.996803e-12
-5.449541 5.954128 -1.758593e-11</code></pre>
<p>Observe that <code>lsq</code> is equivalent to,</p>
<pre class="highlight"><code class="language-q">q)A mmu inv B
1.211009 -0.1009174 1.77991e-12
-2.119266 2.926606 -5.81224e-12
-5.449541 5.954128 -1.337952e-11</code></pre>
<p>Integer matrices must be cast to float.</p>
<h3 id="a48-ltime">A.48 <a href="https://code.kx.com/q/ref/ltime/"><code>ltime</code></a></h3>
<p>The atomic <code>ltime</code> converts UTC time to local time.</p>
<pre class="highlight"><code class="language-q">q).z.P
2015.04.12D12:12:42.475837000

q)ltime .z.P
2015.04.12D02:12:45.987860000

q).z.p
2015.04.12D22:12:47.859567000</code></pre>
<h3 id="a49-ltrim">A.49 <a href="https://code.kx.com/q/ref/ltrim/"><code>ltrim</code></a></h3>
<p>The unary <code>ltrim</code> takes a string parameter and returns the result of removing leading blanks.</p>
<pre class="highlight"><code class="language-q">q)ltrim " abc "
"abc " "
q)ltrim " "
""</code></pre>
<p>You can also apply <code>ltrim</code> to a non-blank char but it fails for a blank char.</p>
<pre class="highlight"><code class="language-q">q)ltrim "a"
"a"
q)ltrim " "
k){$[~t&amp;77h&gt;t:@x;.z.s'x;" "=*x;(+/&amp;\" "=x)_x;x]}
'type
_
1b
" "</code></pre>
<h3 id="a50-mavg">A.50 <a href="https://code.kx.com/q/ref/mavg/"><code>mavg</code></a></h3>
<p>The binary <code>mavg</code> takes first parameter a long (<em>length</em>) and returns the <em>length</em>-wise moving average of its numeric list second parameter (<em>source</em>). At each position in <em>source</em>, it computes the average of the <em>length</em> preceding items, or as many as are available up to <em>length</em>, ignoring internal nulls. It is uniform in its second argument.</p>
<p>In the following example, the first item in the result is the average of itself only; the second result item is the average of the first two source items; all other items reflect the average of the item at the position along with its two predecessors.</p>
<pre class="highlight"><code class="language-q">q)3 mavg 10 20 30 40 50
10 15 20 30 40f

q)3 mavg 0N 10 20 30 40 50
0n 10 15 20 30 40</code></pre>
<div class="admonition tip">
<p class="admonition-title">For length 1, the result is the source converted to float.</p>
</div>
<h3 id="a51-max">A.51 <a href="https://code.kx.com/q/ref/max/"><code>max</code></a></h3>
<p>The aggregate <code>max</code> is <code>(|/)</code>, which applies <code>|</code> cumulatively across a list of items of underlying numeric type and returns the final result. It is the same as <code>any</code> on a boolean list.</p>
<pre class="highlight"><code class="language-q">q)max 100100b
1b

q)max 10?2015.01.01
2013.09.09</code></pre>
<h3 id="a52-maxs">A.52 <a href="https://code.kx.com/q/ref/maxs/"><code>maxs</code></a></h3>
<p>The uniform <code>maxs</code> is <code>(|\)</code>, which applies <code>|</code> across a list of comparable items and returns the intermediate results.</p>
<pre class="highlight"><code class="language-q">q)maxs 1 2 5 4 10
1 2 5 5 10

q)maxs "Beeblebrox"
"Beeelllrrx"</code></pre>
<h3 id="a53-mcount">A.53 <a href="https://code.kx.com/q/ref/mcount/"><code>mcount</code></a></h3>
<p>The uniform binary <code>mcount</code> takes as first parameter a long (<em>length</em>) and returns a long equal to the <em>length</em>-wise moving count of its list second parameter (<em>source</em>). At each position in <em>source</em>, it counts the number of non-null preceding items up to <em>length</em>. This function is useful in computing other moving quantities, such as moving average, since it correctly reports the number of predecessors at the head of the list and also ignores internal nulls.</p>
<pre class="highlight"><code class="language-q">q)3 mcount 10 20 30 40 50
1 2 3 3 3i

q)3 mcount 10 20 0N 40 50 60 0N
1 2 2 2 2 3 2i</code></pre>
<h3 id="a54-md5">A.54 <a href="https://code.kx.com/q/ref/md5/"><code>md5</code></a></h3>
<p>The unary function <code>md5</code> computes the MD5 (Message Digest Algorithm 5) hash of a string as a list of 16 bytes.</p>
<pre class="highlight"><code class="language-q">q)md5 "Life the Universe and Everything"
0x0e9a5631e4db880d43808504d05348df</code></pre>
<h3 id="a55-mdev">A.55 <a href="https://code.kx.com/q/ref/mdev/"><code>mdev</code></a></h3>
<p>The uniform binary <code>mdev</code> takes first parameter a long (<em>length</em>) and returns the <em>length</em>-wise moving standard deviation of its numeric list second parameter (<em>source</em>). At each position in <em>source</em>, it computes the standard deviation of the <em>length</em> preceding items, or as many as are available at that position up to <em>length</em>. It excludes internal nulls from the calculation.</p>
<pre class="highlight"><code class="language-q">q)3 mdev 10 20 30 40 50
0 5 8.164966 8.164966 8.164966

q)3 mdev 10 20 30 0N 50
0 5 8.164966 5 10</code></pre>
<h3 id="a56-med">A.56 <a href="https://code.kx.com/q/ref/med/"><code>med</code></a></h3>
<p>The aggregate <code>med</code> returns the float median of a numeric list.</p>
<p>For lists and dictionaries, the result is a float.</p>
<pre class="highlight"><code class="language-q">q)med 1000?1000.
499.1908</code></pre>
<p>The function <code>med</code> is equivalent to,</p>
<pre class="highlight"><code class="language-q">{avg x (iasc x)@floor .5*-1 0+count x,:()}</code></pre>
<h3 id="a57-min">A.57 <a href="https://code.kx.com/q/ref/min/"><code>min</code></a></h3>
<p>The aggregate <code>min</code> is <code>(&amp;/)</code>, which applies <code>&amp;</code> cumulatively across a list of underlying numeric type and returns the final result. It is the same as <code>and</code> for a boolean list.</p>
<pre class="highlight"><code class="language-q">q)min 100?100
2

q)min 100100b
0b</code></pre>
<h3 id="a58-mins">A.58 <a href="https://code.kx.com/q/ref/mins/"><code>mins</code></a></h3>
<p>The uniform <code>mins</code> is <code>(&amp;\)</code>, which computes the cumulative minimums of a list of comparables and returns the intermediate results.</p>
<pre class="highlight"><code class="language-q">q)mins 10 4 5 1 2
10 4 4 1 1

q)mins "the cat"
"theecaa"</code></pre>
<h3 id="a59-mmax">A.59 <a href="https://code.kx.com/q/ref/mmax/"><code>mmax</code></a></h3>
<p>The uniform binary <code>mmax</code> takes as first parameter a long (<em>length</em>) and returns the <em>length</em>-wise moving maximum of its second parameter list of comparables (<em>source</em>). At each position in <em>source</em>, it computes the maximum of the <em>length</em> preceding items, or as many as are available at that position up to <em>length</em>.</p>
<p>In the following example, the first item in the result is the <code>max</code> of itself only; the second result item is the <code>max</code> of the first two source items; all other items reflect the <code>max</code> of the item at the position along with its two predecessors.</p>
<pre class="highlight"><code class="language-q">q)3 mmax 20 10 30 50 40
20 20 30 50 50

q)3 mmax 20 10 30 0N 40
20 20 30 30 40</code></pre>
<h3 id="a60-mmin">A.60 <a href="https://code.kx.com/q/ref/mmin/"><code>mmin</code></a></h3>
<p>The uniform binary <code>mmin</code> takes first parameter a long (<em>length</em>) and returns the <em>length</em>-wise moving minimum of its second parameter list of comparables (<em>source</em>). At each position in <em>source</em>, it computes the minimum of the <em>length</em> preceding items, or as many as are available at that position up to <em>length</em>.</p>
<p>In the following example, the first item in the result is the <code>min</code> of itself only; the second result item is the <code>min</code> of the first two source items; all other items reflect the <code>min</code> of the item at the position along with its two predecessors.</p>
<pre class="highlight"><code class="language-q">q)3 mmin 20 10 30 50 40
20 10 10 10 30</code></pre>
<p>For <em>length</em> less than or equal to 0 the result is <em>source</em>.</p>
<h3 id="a61-mmu">A.61 <a href="https://code.kx.com/q/ref/mmu/"><code>mmu</code></a></h3>
<p>The binary matrix multiplication <code>mmu</code> returns the matrix product of its two float vector or matrix parameters, which must be of the correct shape. It reduces to dot product on vectors. Integer matrices must be cast to float.</p>
<pre class="highlight"><code class="language-q">q)m1:(1.1 2.2 3.3;4.4 5.5 6.6;7.7 8.8 9.9)
q)m1 mmu flip m1
16.94 38.72 60.5
38.72 93.17 147.62
60.5 147.62 234.74

q)m2:`float$(0 0 1; 0 1 0; 1 0 0)
q)m2 mmu m2
1 0 0
0 1 0
0 0 1

q)1 2 3f mmu 1 2 3f
14f</code></pre>
<p>The <code>$</code> operator is overloaded to yield matrix multiplication when its parameters are float vectors or matrices.</p>
<pre class="highlight"><code class="language-q">q)m2 $ m2
1 0 0
0 1 0
0 0 1</code></pre>
<h3 id="a62-msum">A.62 <a href="https://code.kx.com/q/ref/msum/"><code>msum</code></a></h3>
<p>The uniform binary <code>msum</code> takes first parameter a long (<em>length</em>) and returns the <em>length</em>-wise moving sum of its numeric list second parameter (<em>source</em>). At each position in <em>source</em>, it computes the sum of the <em>length</em> preceding items, or as many as are available at that position up to <em>length</em>. It excludes internal nulls from the sum.</p>
<p>In the following example, the first item in the result is the sum of itself only; the second result item is the sum of the first two source items; all other items reflect the sum of the item at the position along with its two predecessors.</p>
<pre class="highlight"><code class="language-q">q)3 msum 10 20 30 40 50
10 30 60 90 120</code></pre>
<h3 id="a63-next">A.63 <a href="https://code.kx.com/q/ref/next/"><code>next</code></a></h3>
<p>The uniform <code>next</code> returns its list parameter shifted one position to the left with a null (or empty) in the last item. Otherwise put, each item in the original is replaced with its successor.</p>
<pre class="highlight"><code class="language-q">q)next 1 2 3 4 5
2 3 4 5 0N

q)next (1 2; 3 4 5; 6 7)
3 4 5
6 7
`long$()</code></pre>
<h3 id="a64-null">A.64 <a href="https://code.kx.com/q/ref/null/"><code>null</code></a></h3>
<p>The atomic function <code>null</code> tests its argument for null value. It is preferred to testing for equality as it works for all types.</p>
<pre class="highlight"><code class="language-q">q)null 42
0b

q)null 0n
1b

q)null "Now is the time"
000100100010000b</code></pre>
<p>A common idiom combines <code>where</code> with <code>null</code> to obtain the positions of the null items in a list.</p>
<pre class="highlight"><code class="language-q">q)where null 1 2 3 0N 5 0N
3 5</code></pre>
<p>Because <code>null</code> is atomic, it picks out null values in all fields.</p>
<pre class="highlight"><code class="language-q">q)null ([] c1:`a``b; c2:0N 20 30)
c1 c2
-----
0 1
1 0
0 0</code></pre>
<p>This can be used to identify null columns.</p>
<pre class="highlight"><code class="language-q">q)where all null ([] c1:`a`b`c; c2:0n 0n 0n; c3:10 0N 30)
,`c2</code></pre>
<h3 id="a65-or">A.65 <a href="https://code.kx.com/q/ref/or/"><code>or</code></a></h3>
<p>The function <code>or</code> is the same as <code>|</code> for people who like typing extra characters.</p>
<pre class="highlight"><code class="language-q">q)1b or 0b
1b

q)42 or 43
43</code></pre>
<h3 id="a66-over">A.66 <a href="https://code.kx.com/q/ref/over/"><code>over</code></a></h3>
<p>The function <code>over</code> is a convenience function that renames the unary form of <code>/</code> for those allergic to k.</p>
<pre class="highlight"><code class="language-q">q){x+2*y} over 2 3 5 7
32

q)(+) over 2 3 5 7
17</code></pre>
<h3 id="a67-parse">A.67 <a href="https://code.kx.com/q/ref/parse/"><code>parse</code></a></h3>
<p>The unary <code>parse</code> returns the q parse tree for a string representing a q expression. Applying <code>eval</code> to the result of <code>parse</code> effectively evaluates the expression. The composition of <code>eval</code> after <code>parse</code> is essentially the q interpreter. A discussion of q <a href="https://code.kx.com/q/basics/parsetrees/">parse trees</a> is beyond the scope of this tutorial.</p>
<pre class="highlight"><code class="language-q">q)parse "7*4+2"
*
7
(+;4;2)
q)eval parse "7*4+2"
42</code></pre>
<p>It is useful to apply <code>parse</code> to a string containing a query template for the purpose of expressing the query in functional form. The result will often include k code but it is usually recognizable and you can use it in functional form.</p>
<div class="admonition tip">
<p class="admonition-title">The constraint portion of the resulting parse tree will contain an extra level of nesting displayed in the k form <code>,,</code>.</p>
</div>
<p>You must remove one level for the functional form.</p>
<pre class="highlight"><code class="language-q">q)t:([]c1:`a`b`c; c2:10 20 30)
q)parse "select c2:2*c2 from t where c1=`c"
?
`t
,,(=;`c1;,`c)
0b
(,`c2)!,(*;2;`c2)
q)?[`t; enlist (=;`c1;enlist `c); 0b; (enlist `c2)!enlist (*;2;`c2)]
c2
--
60</code></pre>
<h3 id="a68-peach">A.68 <a href="https://code.kx.com/q/ref/peach"><code>peach</code></a></h3>
<p>A full discussion of how q handles concurrency and distributed processing is beyond the scope of this text. We provide a description of the essential features in q3.2 as of this writing (Sep 2015) and refer the reader to the <a href="https://code.kx.com/q/basics/peach">KX site</a> for up-to-date details.</p>
<p>Concurrency in q uses two basic constructs: <code>peach</code> and slaves. Slaves can be either threads spawned by the main q process or independent q processes. How many and which type of slaves are declared to the q process at startup. The function <code>peach</code> is a ‚Äúparallel‚Äù version of <code>each</code> that applies a function over a list by distributing the items of the list across slaves. This is q‚Äôs implementation of the ‚Äúmap‚Äù portion of the distributed map-reduce paradigm, which is much-ballyhooed in other environments.</p>
<div class="admonition info">
<p class="admonition-title">If q is not started with slaves, <code>peach</code> reverts to <code>each</code>, meaning function application across the list occurs sequentially in the main q thread.</p>
</div>
<p>Use the <a href="https://code.kx.com/q/basics/cmdline/#-s-slaves">command line parameter <code>-s</code></a> to start a slave-enabled q session. In classic Arthurian fashion, the interpretation of <code>‚Äìs</code> depends on the sign of the integer that follows it. A <strong>positive</strong> integer <em>n</em> indicates that the q process should start with <em>n</em> slave <strong>threads</strong> to be used by <code>peach</code>. A <strong>negative</strong> integer ‚Äì<em>n</em> means that you will provide <em>n</em> independent slave q <strong>processes</strong> for <code>peach</code> to use. The physical implementation of work distribution is different in these two cases, but the logical result is the same.</p>
<h4 id="a681-threads">A.68.1 Threads</h4>
<p>When q is started with <code>-s <em>n</em></code>, the q process automatically spawns <em>n</em> slave threads in addition to the main thread at startup. When you subsequently use <code>peach</code> to apply a function ‚Äì i.e., map it ‚Äì across a list, the application is automatically distributed across the slave threads for you. The result of the application is the same as if you had used <code>each</code> but if q is running on a machine with multiple cores, you should expect a speedup, depending on what the function does, how slave threads are allocated to cores and the load on your machine. For example, on the author‚Äôs laptop that has 4 cores and hyperthreading, we find that the benefit of multiple slaves for evaluating a compute-intensive calculation on a list of 8 items plateaus at 4 slaves.</p>
<pre class="highlight"><code class="language-bash">$ rlwrap q/m32/q -s 2</code></pre>
<pre class="highlight"><code class="language-q">q)\t {sum exp x?1.0} each 8#1000000
134
q)\t {sum exp x?1.0} peach 8#1000000
72</code></pre>
<pre class="highlight"><code class="language-bash">$ rlwrap q/m32/q -s 4</code></pre>
<pre class="highlight"><code class="language-q">q)\t {sum exp x?1.0} each 8#1000000
136
q)\t {sum exp x?1.0} peach 8#1000000
46</code></pre>
<pre class="highlight"><code class="language-bash">$ rlwrap q/m32/q -s 8</code></pre>
<pre class="highlight"><code class="language-q">q)\t {sum exp x?1.0} each 8#1000000
135
q)\t {sum exp x?1.0} peach 8#1000000
43</code></pre>
<p>In order to maintain consistency during concurrent application, the following restriction is placed on function evaluation within slave threads. Code executed in a slave thread <strong>cannot</strong> update global variables ‚Äì i.e., a function can only update local variables.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>If you use a timer on the main thread or other tricks to update globals that are read by slave threads, you are cruising for a bruising. While these updates are locked, there is no notion of a transaction with attendant rollback. It is unlikely that your function executing on the timer is atomic at the hardware level. Should it fail mid-flight, you should expect the workspace would be in an inconsistent state with no built-in recovery mechanism.</p>
</div>
<p>Now we describe how the slave thread execution is implemented. The items in the list are pre-assigned to slaves in a round-robin fashion. For example, if you <code>peach</code> a function on a list with 9 items in a session with 4 slaves: items 0, 4 and 8 will be executed sequentially on slave 0; items 1, 5 and 9 will be executed sequentially on slave 1; items 2 and 6 will be executed sequentially on slave 2; and items 3 and 7 will be executed sequentially on slave 3. The sequential execution within slaves occurs concurrently across slaves.</p>
<p>The slaves use thread-local heaps and the (partial) results of application within each slave are serialized and copied to the main thread where they are deserialized and assembled into the final result. Since there is overhead associated with serialization/deserialization, we have:</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>A function applied with <code>peach</code> should do enough computation to outweigh the serialization overhead. You can estimate the serialization time and space of a q entity with
<code>\ts:100 -9!-8!entity</code></p>
</div>
<p>We collect here observations on execution within a slave. See the <a href="https://code.kx.com/q/basics/peach">KX site</a> for more details.</p>
<ol>
<li>
<p>If the list has a <strong>single</strong> item, <code>peach</code> application occurs in the <strong>main</strong> q thread only.</p>
</li>
<li>
<p>If the function applied with <code>peach</code> performs grouping on a symbol list ‚Äì e.g., a select that groups on a ticker symbol ‚Äì this will be significantly slower in the slave because the optimized algorithm used in the main thread is not available in the slave.</p>
</li>
<li>
<p>In q3.*, a socket can be used from the main thread only. As there is no locking around a socket descriptor, a communication handle shared between threads would result in garbage due to message interleaving.</p>
</li>
<li>
<p>Each slave thread has its own heap, a minimum of 64MB. Executing <code>.Q.gc[]</code> in the main thread triggers garbage collection in the slave threads too. Automatic garbage collection within each thread is only executed for that particular thread, not across all threads.</p>
</li>
<li>
<p>Symbols are internalized in a single memory area accessible to all threads.</p>
</li>
</ol>
<h4 id="a682-distributed-peach">A.68.2 Distributed <code>peach</code></h4>
<p>Starting q with <code>‚Äìs ‚Äì<em>n</em></code> indicates:</p>
<ol>
<li>
<p>In addition to the main q process, you will instantiate <em>n</em> workers, where a worker is an independent q process with an open port</p>
</li>
<li>
<p>You will connect the master q process to each worker</p>
</li>
<li>
<p>You will provide the master process a unique‚Äôd list of open handles to the workers</p>
</li>
</ol>
<p>The list of handles to the workers is obtained from the system variable <code>.z.pd</code> upon each invocation of <code>peach</code>. You can set <code>.z.pd</code> either to an integer list of open handles with the <code>`u#</code> attribute applied, or a function that returns the same.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>You must apply the <code>`u#</code> attribute or you will get the error:</p>
<pre><code class="language-q">
'.z.pd - expected unique vector of int handles
</code></pre>
</div>
<p>In contrast to the situation with slave threads, where the threads are created for you automatically, with distributed <code>peach</code> it is your responsibility to instantiate the separate worker processes and make them available to the main q process. In production environments this may entail meeting security requirements ‚Äì e.g., Kerberos. You can start the workers externally to your main process or you can start them from within the process using <a href="https://code.kx.com/q/ref/system/"><code>system</code></a>.</p>
<p>The workers can be on the same machine as the master process or on any machine on a network so long as it is accessible from the master process. Since they are independent q processes that share no data with the main process, the distributed function is not restricted as to what it can do on the worker. This provides a very flexible framework for distributed computing.</p>
<p>Once you have started the worker processes, you must open a connection to each one, keeping track of the open handles.</p>
<div class="admonition tip">
<p class="admonition-title">You cannot use these handles for other messaging, as <code>peach</code> will close any handle that presents a message not in its expected format.</p>
</div>
<p>You can assign the unique‚Äôd list of the open connections to <a href="https://code.kx.com/q/ref/dotz#zpd-peach-handles"><code>.z.pd</code></a> or you can return such a list from a function that you assign to <code>.z.pd</code>. In contrast to the slave thread implementation, where the assignment to slaves is determined in advance, individual computations are automatically distributed to workers that become free. Thus we get a simple form of dynamic load balancing.</p>
<p>Following is an example that starts four external workers on the same machine from within the master process, wires the workers directly into <code>.z.pd</code> and then uses <code>peach</code> to distribute work to them.</p>
<pre class="highlight"><code class="language-bash">~$q -s -4
..</code></pre>
<pre class="highlight"><code class="language-q">q){system "q -q -p ",string[x]," &amp;"} each 20000+til 4
q).z.pd:`u#hopen each `$"::",/:string 20000+til 4
q)\t {sum exp x?1.0} each 8#1000000
134
q)\t {sum exp x?1.0} peach 8#1000000
46</code></pre>
<p>You can also assign to <code>.z.pd</code> a function that manages the connections. The code below monitors closing connections via <code>.z.pc</code>, which removes the handle of any closed connection from its self-maintained list of active handles. The function assigned to <code>.z.pd</code> checks to see if all expected handles are open and, if not, closes any open handles and then reopens all the specified handles.</p>
<pre class="highlight"><code class="language-q">q)handles:`u#`int$()
q).z.pd:{
 if[0&gt;=n:neg system "s";
 '"must start q with -s -n"];
 if[n&lt;&gt;count handles; hclose each handles;
 `handles set `u#hopen each 20000+til n];
 handles}
q).z.pc:{`handles set `u#handles except x;}</code></pre>
<h3 id="a69-prd">A.69 <a href="https://code.kx.com/q/ref/prd"><code>prd</code></a></h3>
<p>The aggregate <code>prd</code> is <code>(*/)</code>, which applies <code>*</code> cumulatively across a numeric list and returns the final result.</p>
<div class="admonition tip">
<p class="admonition-title">Note the missing ‚Äòo‚Äô in the name.</p>
</div>
<pre class="highlight"><code class="language-q">q)prd 1+til 5

q)prd 1+til 5
120

q)prd 10?100.
2.667807e+13</code></pre>
<p>It is possible to apply <code>prd</code> to a nested list provided the sublists conform. In this case, the result conforms to the sublists and the product is calculated recursively on the sublists.</p>
<pre class="highlight"><code class="language-q">q)prd (1 2; 100 200; 1000 2000)
100000 800000</code></pre>
<h3 id="a70-prds">A.70 <a href="https://code.kx.com/q/ref/prds/"><code>prds</code></a></h3>
<p>The uniform <code>prds</code> is <code>(*\)</code>, which applies <code>*</code> cumulatively across a list of numeric type and returns the intermediate results.</p>
<div class="admonition tip">
<p class="admonition-title">Note the missing ‚Äòo‚Äô in the name.</p>
</div>
<pre class="highlight"><code class="language-q">q)prds 1+til 5
1 2 6 24 120</code></pre>
<h3 id="a71-prev">A.71 <a href="https://code.kx.com/q/ref/prev/"><code>prev</code></a></h3>
<p>The uniform <code>prev</code> returns a list argument shifted one position to the right with a null (or empty) in the first item. Otherwise put, each item in the original is replaced with its predecessor.</p>
<pre class="highlight"><code class="language-q">q)prev 1 2 3 4 5
0N 1 2 3 4

q)prev (1 2; 3 4 5; 6 7)
`long$()
1 2
3 4 5</code></pre>
<h3 id="a72-prior">A.72 <a href="https://code.kx.com/q/ref/prior/"><code>prior</code></a></h3>
<p>The function <code>prior</code> is a convenience function that renames the unary form of <code>':</code> for those allergic to k.</p>
<pre class="highlight"><code class="language-q">q)(-) prior 10 11 12 13 14
10 1 1 1 1</code></pre>
<h3 id="a73-rank">A.73 <a href="https://code.kx.com/q/ref/rank/"><code>rank</code></a></h3>
<p>The uniform <code>rank</code> returns the sort order of each item in a list of comparables.</p>
<pre class="highlight"><code class="language-q">q)rank 50 20 30 10 40
4 1 2 0 3

q)rank `x`a`b`z`c
3 0 1 4 2</code></pre>
<h3 id="a74-ratios">A.74 <a href="https://code.kx.com/q/ref/ratios/"><code>ratios</code></a></h3>
<p>The uniform <code>ratios</code> is <code>(%':)</code>, which applies <code>%</code> across a list of numeric type and returns the intermediate results. That is, it returns the ratio of each item with its predecessor. The initial item in the result is 1.0.</p>
<pre class="highlight"><code class="language-q">q)ratios 10 20 30 40 50
10 2 1.5 1.333333 1.25</code></pre>
<div class="admonition tip">
<p class="admonition-title">If you are looking to bound the relative difference between successive elements, this example shows that the initial item of the result will be troublesome.</p>
</div>
<p>In this case, you can use,</p>
<pre class="highlight"><code class="language-q">ratios1:{first[x] %': x}</code></pre>
<p>For our example above,</p>
<pre class="highlight"><code class="language-q">q)ratios1 10 20 30 40 50
1 2 1.5 1.333333 1.25</code></pre>
<h3 id="a75-raze">A.75 <a href="https://code.kx.com/q/ref/raze/"><code>raze</code></a></h3>
<p>The unary <code>raze</code> is <code>(,/)</code>. It effectively eliminates the top-most level of nesting from a list by concatenating across it.</p>
<pre class="highlight"><code class="language-q">q)raze (1 2 3;3; 4 5)
1 2 3 3 4 5</code></pre>
<p>Observe that <code>raze</code> only removes the top-most level of nesting but you can use <code>each</code> to reach deeper levels.</p>
<pre class="highlight"><code class="language-q">q)raze ((1 2;3 4);(5;(6 7;8 9)))
1 2
3 4
5
(6 7;8 9)
q)raze each ((1 2;3 4);(5;(6 7;8 9)))
1 2 3 4
(5;6 7;8 9)a</code></pre>
<h3 id="a76-reval">A.76 <a href="https://code.kx.com/q/ref/reval/"><code>reval</code></a></h3>
<p>Introduced in q3.3, <code>reval</code> is a version of <code>eval</code> that behaves as if the command line option <code>-b</code> had been set. This means that all updates on the server are blocked for the duration of the evaluation. See <a href="#a27-eval">¬ßA.27</a> and <a href="https://code.kx.com/q4m3/13_Commands_and_System_Variables/#1321-block-database-modification-b">¬ß13.2.1</a>.</p>
<h3 id="a77-reverse">A.77 <a href="https://code.kx.com/q/ref/reverse/"><code>reverse</code></a></h3>
<p>The uniform function <code>reverse</code> inverts the item order of its list argument.</p>
<pre class="highlight"><code class="language-q">q)reverse 1 2 3 4 5
5 4 3 2 1

q)reverse `a`b`c!10 20 30
c| 30
b| 20
a| 10

q)reverse ([] c1:`a`b`c; c2:10 20 30)
c1 c2
-----
c 30
b 20
a 10

q)reverse ([k:`a`b`c] v:10 20 30)
k| v
-| --
c| 30
b| 20
a| 10</code></pre>
<p>For nested entities, the reversal takes place only at the topmost level but you can use <code>each</code> to reach lower levels.</p>
<pre class="highlight"><code class="language-q">q)reverse (1 2 3;"abc";`Four`Score`and`Seven)
`Four`Score`and`Seven
"abc"
1 2 3

q)reverse each (1 2 3;"abc";`Four`Score`and`Seven)
3 2 1
"cba"
`Seven`and`Score`Four</code></pre>
<h3 id="a78-rload">A.78 <a href="https://code.kx.com/q/ref/rload/"><code>rload</code></a></h3>
<p>The function <code>rload</code> is a convenience function that loads a splayed table into a variable with the same name as the splayed directory. The usual way to do this is with <code>get</code>, whose result can be assigned to an arbitrary variable.</p>
<pre class="highlight"><code class="language-q">q)`:db/t/ set ([] c1:10 20 30; c2:1.2 2.2 3.3)
`:db/t/
q)rload `:db/t
`t
q)count t
3

q)t1:get `:db/t
q)count t1
3</code></pre>
<h3 id="a79-rotate">A.79 <a href="https://code.kx.com/q/ref/rotate/"><code>rotate</code></a></h3>
<p>The uniform binary <code>rotate</code> takes as its first parameter a long (<em>length</em>) and returns the result of rotating its second parameter by <em>length</em> positions. The rotation is to the left for positive <em>length</em> and to the right for negative <em>length</em>. For <em>length</em> 0, it returns the source.</p>
<pre class="highlight"><code class="language-q">q)2 rotate 1 2 3 4 5
3 4 5 1 2

q)22 rotate 1 2 3 4 5
3 4 5 1 2</code></pre>
<h3 id="a80-rsave">A.80 <a href="https://code.kx.com/q/ref/rsave/"><code>rsave</code></a></h3>
<p>The function <code>rsave</code> is a convenience function that splays a table variable to a directory with the same name. The preferred way to do this is with <code>set</code>, which allows the directory name to be specified.</p>
<pre class="highlight"><code class="language-q">q)t:([] c1:10 20 30; c2:1.2 2.2 3.3)
q)rsave `:db/t
`:db/t/
q)`:db/t1/ set t
`:db/t1/</code></pre>
<h3 id="a81-rtrim">A.81 <a href="https://code.kx.com/q/ref/rtrim/"><code>rtrim</code></a></h3>
<p>The unary <code>rtrim</code> takes a string argument and returns the result of removing trailing blanks.</p>
<pre class="highlight"><code class="language-q">q)rtrim " abc "
" abc"
q)rtrim " "
""</code></pre>
<p>You can apply <code>rtrim</code> to a non-blank char but it fails for a blank char.</p>
<pre class="highlight"><code class="language-q">q)rtrim "a"
"a"
q)rtrim " "
k){$[~t&amp;77h&gt;t:@x;.z.s'x;" "=*x;(+/&amp;\" "=x)_x;x]}
'type
_
1b
" "</code></pre>
<h3 id="a82-scan">A.82 <a href="https://code.kx.com/q/ref/scan/"><code>scan</code></a></h3>
<p>The function <code>scan</code> is a convenience function that renames the unary form of <code>\</code> for those allergic to k.</p>
<pre class="highlight"><code class="language-q">q){x+2*y} scan 2 3 5 7
2 8 18 32
q)(+) scan 2 3 5 7
2 5 10 17</code></pre>
<h3 id="a83-scov">A.83 <a href="https://code.kx.com/q/ref/scov/"><code>scov</code></a></h3>
<p>The binary <code>scov</code> returns the statistical covariance of its numeric list arguments of the same length.</p>
<pre class="highlight"><code class="language-q">q)2 3 5 7 scov 4 3 0 2
-2.416667</code></pre>
<p>It is equivalent to,</p>
<pre class="highlight"><code class="language-q">{cov[x;y]*count[x]%-1+count x}</code></pre>
<h3 id="a84-sdev">A.84 <a href="https://code.kx.com/q/ref/sdev/"><code>sdev</code></a></h3>
<p>The unary <code>sdev</code> returns the statistical standard deviation of its numeric list argument.</p>
<pre class="highlight"><code class="language-q">q)sdev 10 343 232 55
155.1322</code></pre>
<p>It is equivalent to,</p>
<pre class="highlight"><code class="language-q">{sqrt var[x]*count[x]%-1+count x}</code></pre>
<h3 id="a85-setenv">A.85 <a href="https://code.kx.com/q/ref/setenv/"><code>setenv</code></a></h3>
<p>The binary <code>setenv</code> takes as first parameter a symbol representing the name of an OS environment variable and a string second parameter. It calls the underlying OS to set the named environment variable to the specified string value.</p>
<pre class="highlight"><code class="language-q">q) `FOO setenv "test"
q)getenv `FOO
_</code></pre>
<h3 id="a86-sin">A.86 <a href="https://code.kx.com/q/ref/sin/"><code>sin</code></a></h3>
<p>The atomic <code>sin</code> takes a float and returns its mathematical sine.</p>
<pre class="highlight"><code class="language-q">q)sin 0f
0f

q)pi:3.141592653589793
q)sin pi
1.224647e-16

q)pi%2
1.570796

q)sin pi%4
0.7071068</code></pre>
<h3 id="a87-ss">A.87 <a href="https://code.kx.com/q/ref/ss/"><code>ss</code></a></h3>
<p>The binary <code>ss</code>, for "string search", performs similar pattern matching as <code>like</code> against its first string parameter (<em>source</em>), looking for matches to its string second parameter (<em>pattern)</em>. However, the result of <code>ss</code> is a list containing the position(s) of the matches of the pattern in <em>source</em>.</p>
<pre class="highlight"><code class="language-q">q)ss["Now is the time for all good men to come to";"me"]
13 29 38

q)"fun" ss "f?n"
,0</code></pre>
<p>If no matches are found, an empty list of long is returned.</p>
<pre class="highlight"><code class="language-q">q)ss["ab";"z"]
`long$()</code></pre>
<div class="admonition warning">
<p class="admonition-title">You cannot use <code>*</code> to match with <code>ss</code>.</p>
</div>
<pre class="highlight"><code class="language-q">q)"fun" ss "f*n"
'length</code></pre>
<h3 id="a88-ssr">A.88 <a href="https://code.kx.com/q/ref/ssr/"><code>ssr</code></a></h3>
<p>The triadic <code>ssr</code>, for "string search and replace", extends the capability of <code>ss</code> with replacement. The result is a string based on the first string parameter (<em>source</em>) in which all occurrences of the second string parameter (<em>pattern</em>) are replaced with the third string argument.</p>
<pre class="highlight"><code class="language-q">q)ssr["suffering succotash";"s";"th"]
"thuffering thuccotathh"</code></pre>
<div class="admonition waerning">
<p class="admonition-title">You cannot use <code>*</code> to match with <code>ssr</code>.</p>
</div>
<p>You can use the <code>over</code> iterator with <code>ssr</code> to replace multiple items.</p>
<pre class="highlight"><code class="language-q">q)(ssr/)["results_%div_%dept.csv"; ("%div";"%dept"); ("banking";"m&amp;a")]
"results_banking_m&amp;a.csv"</code></pre>
<h3 id="a89-string">A.89 <a href="https://code.kx.com/q/ref/string/"><code>string</code></a></h3>
<p>The unary <code>string</code> can be applied to any q entity to produce a textual representation. For atoms, lists and functions, the result of <code>string</code> is a list of char that does not contain any q formatting characters. Following are some examples.</p>
<pre class="highlight"><code class="language-q">q)string 42
"42"

q)string 6*7
"42"

q)string 424224242i
"424224242"

q)string `Zaphod
"Zaphod"

q)string {[a] a*a}
"{[a] a*a}"</code></pre>
<p>The first example demonstrates that <code>string</code> is <strong>not</strong> atomic, because the result of applying it to an atom is a <em>list</em> of char.</p>
<p>Although <code>string</code> is not atomic, it is pseudo-atomic, in that it recurses through a list.</p>
<pre class="highlight"><code class="language-q">q)string 42 98
"42"
"98"
q)("42";"98")
"42"
"98"</code></pre>
<p>This accounts for the un-intuitive behavior of <code>string</code> on an actual string.</p>
<pre class="highlight"><code class="language-q">q)string "Beeblebrox"
,"B"
,"e"
,"e"
,"b"
,"l"
,"e"
,"b"
,"r"
,"o"</code></pre>
<p>Considering a list as a mapping, <code>string</code> acts on the range of the mapping. Viewing a dictionary as a generalized list, we conclude that the action of <code>string</code> on a dictionary should also apply to its range.</p>
<pre class="highlight"><code class="language-q">q)string 1 2 3!100 101 102
1| "100"
2| "101"
3| "102"</code></pre>
<p>A table is the flip of a column dictionary, so we expect <code>string</code> to operate on the range of the column dictionary.</p>
<pre class="highlight"><code class="language-q">q)string ([] a:1 2 3; b:`a`b`c)
a    b
---------
,"1" ,"a"
,"2" ,"b"
,"3" ,"c"</code></pre>
<p>Finally, a keyed table is a dictionary, so we expect <code>string</code> to operate on the value table.</p>
<pre class="highlight"><code class="language-q">q)string ([k:1 2 3] c:100 101 102)
k| c
-| -----
1| "100"
2| "101"
3| "102"</code></pre>
<h3 id="a90-sublist">A.90 <a href="https://code.kx.com/q/ref/sublist/"><code>sublist</code></a></h3>
<p>The binary <code>sublist</code> retrieves a sub-list of contiguous items from a list. The first parameter is a simple list of two non-negative integers: the first item is the starting index (<em>start</em>); the second item is the number of items to retrieve (<em>count</em>). The second parameter (<em>target</em>) is a list or dictionary.</p>
<pre class="highlight"><code class="language-q">q)0 3 sublist 10 20 30 40 50
10 20 30
q)0 10 sublist "abcdef"
"abcdef"
q)0 2 sublist `a`b`c!10 20 30
a| 10
b| 20</code></pre>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The construct <code>0 n sublist ‚Ä¶</code> is preferred to <code>n# ‚Ä¶</code> for extracting the first <code>n</code> items from a list since the latter will repeat the initial items if necessary to reach the specified count. This is ignored surprisingly often in practice.</p>
</div>
<h3 id="a91-sum">A.91 <a href="https://code.kx.com/q/ref/sum/"><code>sum</code></a></h3>
<p>The aggregate <code>sum</code> is <code>(+/)</code>, which applies <code>+</code> cumulatively across a numeric list and returns the final result.</p>
<pre class="highlight"><code class="language-q">q)sum 1+til 100
5050

q)sum 100?100.
5387.56</code></pre>
<p>It is possible to apply <code>sum</code> to a nested list provided the sublists conform. In this case, the result conforms to the sublists and the sum is calculated recursively on the sublists.</p>
<pre class="highlight"><code class="language-q">q)sum (1 2;100 200;1000 2000)
1101 2202</code></pre>
<h3 id="a92-sums">A.92 <a href="https://code.kx.com/q/ref/sums/"><code>sums</code></a></h3>
<p>The uniform <code>sums</code> is <code>(+\)</code>, which applies <code>+</code> cumulatively across a list of numeric type and returns the intermediate results.</p>
<pre class="highlight"><code class="language-q">q)sums 1+til 10
1 3 6 10 15 21 28 36 45 55</code></pre>
<h3 id="a93-sv">A.93 <a href="https://code.kx.com/q/ref/sv/"><code>sv</code></a></h3>
<p>The binary <code>sv</code> ‚Äì "scalar from vector" ‚Äì has several forms. It is usually written infix since that is easier to read.</p>
<p>The first form takes a char as its first parameter and a list of strings (<em>source</em>) as its second. It returns a string that is the concatenation of the strings in <em>source</em>, separated by the specified char.</p>
<pre class="highlight"><code class="language-q">q)"," sv ("Now";"is";"the";"time";"")
"Now,is,the,time,"</code></pre>
<p>When <code>sv</code> is used with an empty symbol as its first parameter and a list of symbols as its second (<em>source</em>), the result is a symbol in which the items in <em>source</em> are concatenated with a separating dot. This is useful for q context names.</p>
<pre class="highlight"><code class="language-q">q)` sv `qalib`stat
`qalib.stat</code></pre>
<p>When <code>sv</code> is used with an empty symbol as its first parameter and a symbol second parameter (<em>source</em>) whose first item is a file handle, the result is a symbol in which the items in <em>source</em> are concatenated with a separating <code>/</code>. This is useful for fully qualified path names.</p>
<pre class="highlight"><code class="language-q">q)` sv `:`q`tutorial`draft`3
`:/q/tutorial/draft/3</code></pre>
<p>When <code>sv</code> is used with an empty symbol as its first parameter and a list of strings as the second parameter, it concatenates the strings, inserting a new line character after each.</p>
<pre class="highlight"><code class="language-q">q)` sv ("abc";"de")
"abc\nde\n"</code></pre>
<p>When <code>sv</code> is used with a long first parameter (<em>base</em>) that is greater than 1, together with a second parameter of a simple list of place values expressed in <em>base</em>, the result is a long representing the converted base 10 value.</p>
<pre class="highlight"><code class="language-q">q)2 sv 101010b
42

q)10 sv 1 2 3 4 2
12342

q)256 sv 0x001092
4242</code></pre>
<p>More precisely, the last version of <code>sv</code> evaluates the polynomial,</p>
<p>(d[n-1]*b exp n-1) + ... +d[0]</p>
<p>where <em>d</em> is the list of digits, <em>n</em> is the count of <em>d</em>, and <em>b</em> is the base.</p>
<p>Thus, we find,</p>
<pre class="highlight"><code class="language-q">q)10 sv 1 2 3 11 2
12412

q)-10 sv 2 1 5
195</code></pre>
<h3 id="a94-svar">A.94 <a href="https://code.kx.com/q/ref/svar/"><code>svar</code></a></h3>
<p>The unary <code>svar</code> returns the statistical standard variance of its numeric list argument.</p>
<pre class="highlight"><code class="language-q">q)svar 2 3 5 7
4.916667</code></pre>
<p>It is equivalent to,</p>
<pre class="highlight"><code class="language-q">{var[x]*count[x]%-1+count x}</code></pre>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The <code>svar</code> function was added in version 3.2 meaning that finance apps can no longer use a variable name <code>svar</code> for stress value at risk in this and later versions.</p>
</div>
<h3 id="a95-system">A.95 <a href="https://code.kx.com/q/ref/system/"><code>system</code></a></h3>
<p>The unary <code>system</code> takes a string argument and executes it as a q command, if recognized, or an OS command otherwise. This is convenient to execute q commands programmatically. The normal result of the command becomes the return value of the evaluation.</p>
<p>Do <strong>not</strong> include the initial <code>\</code> as you would when executing the command from the q session prompt.</p>
<pre class="highlight"><code class="language-q">q)system "c"
25 80i
q)system "c 40 400"
q)system "c"
40 400i

q)system "cd /data"
q)system "pwd"
"/data"</code></pre>
<h3 id="a96-takereshape">A.96 <a href="https://code.kx.com/q/ref/take/">Take/Reshape <code>#</code></a></h3>
<p>The binary operator <code>#</code> has several forms.</p>
<p>When the first parameter of <code>#</code> is an integer atom <em>count</em>, it returns <em>count</em> items from the atom or list second parameter (<em>source</em>). The items are extracted from the head when <em>source</em> is positive and from the tail when count is <em>negative</em>. When <em>count</em> is zero, the result is an empty list of the same type as the first item in <em>source</em>. When <em>count</em> is greater than the count of <em>source</em>, items are repeatedly drawn from <em>source</em> as described until <em>count</em> items are obtained.</p>
<div class="admonition info">
<p class="admonition-title">The result of Take is always a list.</p>
</div>
<pre class="highlight"><code class="language-q">q)2#10 20 30 40 50
10 20

q)-3#10 20 30 40 50
30 40 50

q)0#10 20 30 40 50
`long$()

q)3#42
42 42 42

q)10#10 20 30 40 50
10 20 30 40 50 10 20 30 40 50</code></pre>
<p>The idiom <code>0#</code> atom is a common way to create an empty list of the type of atom.</p>
<pre class="highlight"><code class="language-q">q)meta ([] a:0#0; b:0#`)
c| t f a
-| -----
a| j
b| s</code></pre>
<p>Since a dictionary is ordered, take also applies to dictionaries and, by extension, to tables and keyed tables.</p>
<pre class="highlight"><code class="language-q">q)2#`a`b`c!10 20 30
a| 10
b| 20

q)-2#([] c1:`a`b`c; c2:10 20 30)
c1 c2
-----
b 20
c 30

q)2#([k:`a`b`c] v:10 20 30)
k| v
-| --
a| 10
b| 20</code></pre>
<p>Another form of Take has first parameter a list of keys and the second parameter a dictionary. The result is the sub-dictionary for these keys.</p>
<pre class="highlight"><code class="language-q">q)`a`c#`a`b`c!10 20 30
a| 10
c| 30</code></pre>
<p>Since a table is a column dictionary this form also applies to a table with a list of column names.</p>
<pre class="highlight"><code class="language-q">q)`c1`c2#([] c1:`a`b`c; c2:10 20 30; c3:1.1 2.2 3.3)
c1 c2
-----
a 10
b 20
c 30</code></pre>
<p>Using an anonymous table is a nifty way to generate a list of keys for takes with a keyed table.</p>
<pre class="highlight"><code class="language-q">q)([] k:`a`c)#([k:`a`b`c] v:10 20 30)
k| v
-| --
a| 10
c| 30</code></pre>
<p>Another form of Take has first parameter a list (<em>r</em>; <em>c</em>) of two non-negative integers and second parameter a list or atom (<em>source</em>). The result is a nested list with <em>r</em> items, each having <em>c</em> items, drawn sequentially from the beginning of <em>source</em>, repeatedly if necessary. Otherwise put, the result is an <em>r</em> by <em>c</em> array obtained by reshaping <em>source</em>.</p>
<pre class="highlight"><code class="language-q">q)2 3#10 20 30 40 50
10 20 30
40 50 10</code></pre>
<p>If in the previous form either <em>r</em> or <em>c</em> is null, the result is a nested list obtained by reshaping the second parameter into the specified number of rows or columns. This is generally a ragged array.</p>
<pre class="highlight"><code class="language-q">q)2 0N#10 20 30 40 50
10 20 30
40 50
q)0N 3#10 20 30 40 50
10 20 30
40 5</code></pre>
<h3 id="a97-tan">A.97 <a href="https://code.kx.com/q/ref/tan/"><code>tan</code></a></h3>
<p>The atomic <code>tan</code> takes a float and returns its mathematical tangent.</p>
<pre class="highlight"><code class="language-q">q)tan 0
0f

q)pi:3.141592653589793
q)tan pi
-1.224647e-16

q)tan pi%2
1.633124e+16

q)tan pi%4
1f

q)tan pi%8
0.4142136</code></pre>
<p>The function <code>tan</code> is equivalent to</p>
<pre class="highlight"><code class="language-q">(sin x)%cos x</code></pre>
<h3 id="a98-til">A.98 <a href="https://code.kx.com/q/ref/til/"><code>til</code></a></h3>
<p>The unary <code>til</code> takes a non-negative long parameter (<em>n</em>) and returns a list of <em>n</em> consecutive longs starting with 0.</p>
<div class="admonition tip">
<p class="admonition-title">The argument is not included in the result.</p>
</div>
<pre class="highlight"><code class="language-q">q)til 4
0 1 2 3
q)count til 1000000
1000000</code></pre>
<p>The result of <code>til</code> is always a list.</p>
<pre class="highlight"><code class="language-q">q)til 0
`long$()
q)til 1
,0</code></pre>
<p>To generate other regular numeric sequences, perform vector operations on the result of <code>til</code>.</p>
<pre class="highlight"><code class="language-q">q)1+til 10
1 2 3 4 5 6 7 8 9 10
q)2*til 10
0 2 4 6 8 10 12 14 16 18
q)1+2*til 10
1 3 5 7 9 11 13 15 17 19
q).5*til 10
0 0.5 1 1.5 2 2.5 3 3.5 4 4.5
q)2015.01.01+til 5
2015.01.01 2015.01.02 2015.01.03 2015.01.04 2015.01.05</code></pre>
<h3 id="a99-trim">A.99 <a href="https://code.kx.com/q/ref/trim/"><code>trim</code></a></h3>
<p>The unary <code>trim</code> takes a string argument and returns the result of removing leading and trailing blanks.</p>
<pre class="highlight"><code class="language-q">q)trim " abc "
"abc"</code></pre>
<p>The function <code>trim</code> is equivalent to,</p>
<pre class="highlight"><code class="language-q">{ltrim rtrim x}</code></pre>
<h3 id="a100-ungroup">A.100 <a href="https://code.kx.com/q/ref/ungroup/"><code>ungroup</code></a></h3>
<p>The unary <code>ungroup</code> flattens tables with nested columns that are the result of a select query that groups without aggregation, or of <code>xgroup</code>. Of course you can also apply it to tables with nested columns of the same form that are otherwise generated.</p>
<p>The action of <code>ungroup</code> expands each key group, resulting in one row for each item in the nested columns. The fields in a result row are drawn from corresponding positions across the nested columns.</p>
<p>We use the distribution example.</p>
<pre class="highlight"><code class="language-q">q)\l sp.q
+`p`city!(`p$`p1`p2`p3`p4`p5`p6`p1`p2;`london`london`london`london`london`lon..
(`s#+(,`color)!,`s#`blue`green`red)!+(,`qty)!,900 1000 1200
+`s`p`qty!(`s$`s1`s1`s1`s2`s3`s4;`p$`p1`p4`p6`p2`p2`p4;300 200 100 400 200 300)

q)sp
s  p  qty
---------
s1 p1 300
s1 p2 200
s1 p3 400
s1 p4 200
s4 p5 100
s1 p6 100
s2 p1 300
s2 p2 400
s3 p2 200

q)select s, qty by p from sp
p | s               qty
--| -------------------------------
p1| `s$`s1`s2       300 300
p2| `s$`s1`s2`s3`s4 200 400 200 200
p3| `s$,`s1         ,400
p4| `s$`s1`s4       200 300
p5| `s$`s4`s1       100 400
p6| `s$,`s1         ,100

q)ungroup select s, qty by p from sp
p  s  qty
---------
p1 s1 300
p1 s2 300
p2 s1 200
p2 s2 400
p2 s3 200
p2 s4 200
p3 s1 400
p4 s1 200
p4 s4 300
p5 s4 100
p5 s1 400
p6 s1 100

q)`p xgroup sp
p | s               qty
--| -------------------------------
p1| `s$`s1`s2       300 300
p2| `s$`s1`s2`s3`s4 200 400 200 200
p3| `s$,`s1         ,400
p4| `s$`s1`s4       200 300
p5| `s$`s4`s1       100 400
p6| `s$,`s1         ,100

q)ungroup `p xgroup sp
p  s  qty
---------
p1 s1 300
p1 s2 300
p2 s1 200
p2 s2 400
p2 s3 200
p2 s4 200
p3 s1 400
p4 s1 200
p4 s4 300
p5 s4 100
p5 s1 400
p6 s1 100</code></pre>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Observe that <code>ungroup</code> is not quite the inverse of a grouping operation. Since grouping sorts on the keys, a subsequent <code>ungroup</code> returns the original records sorted by the grouped column(s).</p>
</div>
<h3 id="a101-union">A.101 <a href="https://code.kx.com/q/ref/union/"><code>union</code></a></h3>
<p>The binary <code>union</code> returns the set theoretic union of its two list parameters. The result has the distinct items of the two parameters in order of their first appearance.</p>
<pre class="highlight"><code class="language-q">q)1 1 2 3 union 2 2 3 4
1 2 3 4
q)"a good time" union "was had by all"
"a godtimewshbyl"</code></pre>
<p>Since a table is a list of records, <code>union</code> can be used to perform the analogue of SQL <code>UNION</code> for tables having the same schemas.</p>
<pre class="highlight"><code class="language-q">q)([] c1:`a`b`c; c2:10 20 30) union ([] c1:`c`d; c2:300 400)
c1 c2
------
a  10
b  20
c  30
c  300
d  400</code></pre>
<div class="admonition tip">
<p class="admonition-title">Use <code>uj</code> for tables that do not have matching schemas ‚Äì see <a href="https://code.kx.com/q4m3/9_Queries_q-sql/#997-union-join">¬ß9.9.7</a>.</p>
</div>
<h3 id="a102-upper">A.102 <a href="https://code.kx.com/q/ref/upper"><code>upper</code></a></h3>
<p>The atomic <code>upper</code> takes a char, string or symbol argument and returns the result of converting any alpha characters to upper case.</p>
<pre class="highlight"><code class="language-q">q)upper `a
`A

q)upper `a`b
`A`B

q)upper "a Bc42De"
"A BC42DE"</code></pre>
<h3 id="a103-value">A.103 <a href="https://code.kx.com/q/ref/value/"><code>value</code></a></h3>
<p>The function <code>value</code> also vies for the title as the most overloaded q operator.</p>
<div class="admonition tip">
<p class="admonition-title">The functions <code>value</code> and <code>get</code> are identical. Conventionally <code>get</code> is used with file I/O.</p>
</div>
<p>When <code>value</code> is applied to a symbolic variable name, it returns the associated value.</p>
<pre class="highlight"><code class="language-q">q)a:42
q)value `a
42</code></pre>
<p>When applied to a dictionary, <code>value</code> returns the values of the dictionary. This includes the special case of the value table of a keyed table.</p>
<pre class="highlight"><code class="language-q">q)value `a`b`c!10 20 30
10 20 30

q)kt:([k:`a`b`c] v:10 20 30)
q)value kt
_</code></pre>
<p>A common idiom uses <code>value</code> to extract the columns lists from a table.</p>
<pre class="highlight"><code class="language-q">q)value flip ([] c1:`a`b`c; c2:10 20 30)
a b c
10 20 30</code></pre>
<p>When <code>value</code> is applied to an enumerated value, it de-enumerates it. This is handy when switching between kdb+ databases having different sym domains.</p>
<pre class="highlight"><code class="language-q">q)sym:()
q)ev:`sym?`a`x`b`y`a`c`b
q)ev
`sym$`a`x`b`y`a`c`b
q)value ev
`a`x`b`y`a`c`b</code></pre>
<p>Given a function, <code>value</code> returns the following list,</p>
<p>(bytecode;parms;locals;(context;globals);constants[0];...;constants[n];defn)</p>
<pre class="highlight"><code class="language-q">q)f:{[a;b]d::neg c:a*b+42;c+e}
q)value f
0xa0794178430316220b048100028276410004
`a`b
,`c
``d`e
42
"{[a;b]d::neg c:a*b+42;c+e}"q)sym:()</code></pre>
<p>Given an alias (aka ‚Äúview‚Äù), <code>value</code> returns the list</p>
<p>(cached value;parse tree;dependencies;definition)</p>
<p>When the evaluation of the expression in the alias is as yet deferred, the cached value is&nbsp;<code>::</code>.</p>
<pre class="highlight"><code class="language-q">q)a:42
q)b::a+1            / evaluation is deferred
q)value `.[`b]      / inspect global context
::
(+;`a;1)
,`a
"a+1"

q)b                 / force evaluation
43
q)value `.[`b]
43
(+;`a;1)
,`a
"a+1"</code></pre>
<p>Given a projection, <code>value</code> returns a list containing the function body followed by the supplied arguments.</p>
<pre class="highlight"><code class="language-q">q)f:{x+y+z}
q)value f[2;3;]
{x+y+z}
2
3
::
q)value +[2]
_</code></pre>
<p>Given a function that is the result of applying a k iterator, <code>value</code> returns the argument to the iterator, viewing the latter as a higher-order function.</p>
<pre class="highlight"><code class="language-q">q)value (+/)
+
q)value (+')
+
q)f:{x+y}
q)value (f')
{x+y}</code></pre>
<p>The final and most powerful form of <code>value</code> is that it is the q interpreter itself. It will evaluate a string as if it had been typed at the console.</p>
<pre class="highlight"><code class="language-q">q)value "6*7"
42
q)value "{x*x} til 10"
0 1 4 9 16 25 36 49 64 81</code></pre>
<p>It will also evaluate a parse tree ‚Äì i.e., a (potentially) nested list of functions followed by arguments. If the function is specified by name, that name is resolved first.</p>
<pre class="highlight"><code class="language-q">q)value (*; 6; 7)
42
q)f:{x*y}
q)value (`f; 6; 7)
42</code></pre>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This use of the <code>value</code> function is a powerful feature that allows q code to be written and executed on the fly. This can expose your program to potential attack unless done very carefully. If abused, it can quickly lead to unmaintainable code. (The spellchecker suggests "unmentionable" instead of "unmaintainable." How did it know?)</p>
</div>
<h3 id="a104-var">A.104 <a href="https://code.kx.com/q/ref/var/"><code>var</code></a></h3>
<p>The aggregate <code>var</code> takes a numeric list and returns the mathematical variance of the items as a float.</p>
<pre class="highlight"><code class="language-q">q)var 42 45 37 38
13.66667</code></pre>
<p>The function <code>var</code> is equivalent to</p>
<pre class="highlight"><code class="language-q">{(avg[x*x]) - (avg[x])*(avg[x])}</code></pre>
<h3 id="a105-vs">A.105 <a href="https://code.kx.com/q/ref/vs/"><code>vs</code></a></h3>
<p>The binary <code>vs</code> ‚Äì ‚Äùvector from scalar‚Äù ‚Äì has several versions. It is usually written infix for ease of reading.</p>
<p>The first form takes a char as its first parameter and a string (<em>source</em>) as its second parameter. It returns a list of strings containing the tokens of <em>source</em> as delimited by the specified char.</p>
<pre class="highlight"><code class="language-q">q)" " vs "Now is the time "
"Now"
"is"
"the"
"time"
""</code></pre>
<div class="admonition tip">
<p class="admonition-title">You probably want to trim the input in the above example.</p>
</div>
<p>When <code>vs</code> is used with an empty symbol as its first parameter and a symbol second parameter (<em>source</em>) containing dots, it returns a simple symbol list obtained by splitting <em>source</em> along the dots.</p>
<pre class="highlight"><code class="language-q">q)` vs `qalib.stat
`qalib`stat</code></pre>
<p>When <code>vs</code> is used with an empty symbol as its first parameter and a symbol representing a fully qualified file name as the second parameter, it returns a simple list of symbols in which the first item is the path and the second item is the file name. Note that in this usage, <code>vs</code> is not quite the inverse of <code>sv</code>.</p>
<pre class="highlight"><code class="language-q">q)` vs `qalib.stat
`qalib`stat</code></pre>
<p>When <code>vs</code> is used with a null of binary type as the first parameter and an value of integer type as the second parameter (<em>source</em>), it returns a simple list whose items comprise the digits of the corresponding binary representation of <em>source</em>.</p>
<pre class="highlight"><code class="language-q">q)0x00 vs 4242
0x0000000000001092

q)10h$0x00 vs 8151631268726338926j
"q is fun"

q)0b vs 42
0000000000000000000000000000000000000000000000000000000000101010b</code></pre>
<p>The <code>0b</code> version can be used to display the internal representation of special values.</p>
<pre class="highlight"><code class="language-q">q)0b vs 0W
0111111111111111111111111111111111111111111111111111111111111111b
q)0b vs -0W
1000000000000000000000000000000000000000000000000000000000000001b</code></pre>
<h3 id="a106-wavg">A.106 <a href="https://code.kx.com/q/ref/wavg/"><code>wavg</code></a></h3>
<p>The binary <code>wavg</code> takes two numeric lists of the same count and returns the float average of the items in the second parameter, weighted by the items of the first.</p>
<pre class="highlight"><code class="language-q">q)1 2 3 4 wavg 500 400 300 200
300f</code></pre>
<p>The function <code>wavg</code> is equivalent to,</p>
<pre class="highlight"><code class="language-q">{(sum x*y)%sum x}</code></pre>
<p>It is possible to apply <code>wavg</code> to a nested list provided all sublists of both parameters conform. In this context, the result conforms to the sublists and the weighted average is calculated recursively across the sublists.</p>
<pre class="highlight"><code class="language-q">q)(1 2;3 4) wavg (500 400; 300 200)
350 266.6667</code></pre>
<h3 id="a107-where">A.107 <a href="https://code.kx.com/q/ref/where/"><code>where</code></a></h3>
<p>The unary <code>where</code> has two forms.</p>
<p>The first form returns the indices of <code>1b</code> in a boolean list, or the keys associated to <code>1b</code> in a dictionary with boolean values.</p>
<pre class="highlight"><code class="language-q">q)where 101010b
0 2 4
q)where `a`b`c`d`e`f!101010b
`a`c`e</code></pre>
<p>This is useful when the boolean mapping is the result of a predicate.</p>
<pre class="highlight"><code class="language-q">q)where ","="First, second, third"
5 13

q)@[L; where L=","; :; "\t"]
"First\t second\t third"

q)where null `a`b`c`d`e`f!1 0n 3 4 0n 6
`b`e</code></pre>
<p>When the argument of <code>where</code> is a list of non-negative long (<em>c</em>), the result is a list obtained by catenating <em>c</em>[<em>i</em>] copies of <em>i</em>, for each item in <em>c</em>.</p>
<pre class="highlight"><code class="language-q">q)where 2 1 3
0 0 1 2 2 2
q)where 2 1 0 3 2
0 0 1 3 3 3 4 4
q)where 4#1
0 1 2 3</code></pre>
<div class="admonition note">
<p class="admonition-title">Zen Moment</p>
<p>The second form of <code>where</code> generalizes the form on a boolean list.</p>
</div>
<h3 id="a108-within">A.108 <a href="https://code.kx.com/q/ref/within/"><code>within</code></a></h3>
<p>The binary <code>within</code> is atomic in its first parameter (<em>source</em>) and takes a second parameter that is a list (<em>b</em>;<em>e</em>) that are comparable. It returns a boolean representing whether <em>source</em> is greater than or equal to <em>b</em> and less than or equal to <em>e</em>. It will do type promotion on arguments.</p>
<pre class="highlight"><code class="language-q">q)3 within 2 5
1b

q)(til 7)within 2 5
0011110b

q)"c" within "az"
1b

q)2015.03.14 within 2015.02.01 2015
1b

q)`ab within `a`b
1b

q)100 within "aj"
1b</code></pre>
<div class="admonition tip">
<p class="admonition-title">Ensure the items in the second argument are in increasing order or you will get no matches.</p>
</div>
<h3 id="a109-wsum">A.109 <a href="https://code.kx.com/q/ref/wsum/"><code>wsum</code></a></h3>
<p>The binary <code>wsum</code> takes two numeric lists of the same count and returns the float sum of the items of second parameter weighted by the items of the first.</p>
<pre class="highlight"><code class="language-q">q)1 2 3 4 wsum 500 400 300 200
3000f</code></pre>
<p>The function <code>wsum</code> is equivalent to,</p>
<pre class="highlight"><code class="language-q">{sum x*y}</code></pre>
<p>It is possible to apply <code>wsum</code> to a nested list provided all sublists of both arguments conform. In this case, the result conforms to the sublists and the weighted sum is calculated recursively across the sublists.</p>
<pre class="highlight"><code class="language-q">q)(1 2;3 4) wsum (500 400;300 200)
1400 1600</code></pre>
<h3 id="a110-xbar">A.110 <a href="https://code.kx.com/q/ref/xbar/"><code>xbar</code></a></h3>
<p>The uniform binary <code>xbar</code> takes first parameter a non-negative numeric atom (<em>width</em>) and returns the largest integral multiple of <em>width</em> that is less than or equal to its second parameter. Visually, the result is the left endpoint of the band of width <em>width</em> that contains the second parameter. Since <code>xbar</code> is atomic in the second parameter, this is an effective way to bin the items in a numeric list.</p>
<pre class="highlight"><code class="language-q">q)1 xbar 0 .5 1 1.5 2 2.5 3 3.5
0 0 1 1 2 2 3 3f

q)1.5 xbar 0 .5 1 1.5 2 2.5 3 3.5
0 0 0 1.5 1.5 1.5 3 3

q)2 xbar 0 .5 1 1.5 2 2.5 3 3.5
0 0 0 0 2 2 2 2f</code></pre>
<p>Since a q month is actually the count of months since the millennium, you can use <code>xbar</code> to determine quarters. Recall that a month is equal to the first day of the month.</p>
<pre class="highlight"><code class="language-q">q)`date$3 xbar `month$2015.11.19 / beginning of that quarter
2015.10.01
q)`date$3+3 xbar `month$2015.11.19 / beginning of next quarter
_
q)-1+`date$3+3 xbar `month$2015.11.19 / end of that quarter
_</code></pre>
<h3 id="a111-xprev">A.111 <a href="https://code.kx.com/q/ref/xprev/"><code>xprev</code></a></h3>
<p>The binary <code>xprev</code> takes a long as its first parameter (<em>shift</em>) and shifts the list in its second parameter by <em>shift</em> positions. When <em>shift</em> is 0 or positive, the shift is forward; otherwise it is backward. The beginning ‚Äì respectively end ‚Äì of the list is filled with <em>shift</em> null (or empty) items.</p>
<pre class="highlight"><code class="language-q">q)2 xprev 10 20 30 40 50
0N 0N 10 20 30

q)-2 xprev 10 20 30 40 50
30 40 50 0N 0N

q)2 xprev (1 2 3; 4 5; enlist 6; 7 8)
`long$()
`long$()
1 2 3
4 5</code></pre>
<h3 id="a112-xrank">A.112 <a href="https://code.kx.com/q/ref/xrank/"><code>xrank</code></a></h3>
<p>The binary <code>xrank</code> has first parameter a positive long (<em>n</em>) and is uniform in its second parameter (<em>source</em>). It returns a list of long containing the <em>n</em>-quantile into which each item of <em>source</em> falls, considering <em>source</em> as a distribution. For example, choosing <em>n</em> to be 4 returns quartiles and 100 yields percentiles.</p>
<pre class="highlight"><code class="language-q">q)4 xrank 30 10 40 20 90
1 0 2 0 3

q)100 xrank 200?1000.
35 14 30 96 19 68 39 21 91 73 27 79 30 66 27 79 75 8 99 84 84 77 ..</code></pre>
                


                
              
              
                


              
            </article>
            
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))for(var set of document.querySelectorAll("[data-tabs]")){var labels=set.querySelectorAll(":scope > label");e:for(var tab of tabs)for(var label of labels)if(label.innerText.trim()===tab){var input=label.previousElementSibling;input.checked=!0;break e}}</script>

          </div>
        </div>
        
          
        
      
                </div>
            </section>
        
            <section class="chapter" id="chapter-16">
                <div class="chapter-header">
                    <h1 class="chapter-title">B. Error Messages¬∂</h1>
                    <div class="chapter-meta">
                        <span>üìñ Source: <a href="https://code.kx.com/q4m3/B_Error_Messages/">https://code.kx.com/q4m3/B_Error_Messages/</a></span>
                        <span>üìù 350 words</span>
                        
                    </div>
                </div>
                <div class="chapter-content">
                    
        <div class="md-main__inner md-grid">
          
            
              
              
            
            
              
              
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                
                <h1 id="b-error-messages">B. Error Messages</h1>
<p><span class="twemoji"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path d="M542.22 32.05c-54.8 3.11-163.72 14.43-230.96 55.59-4.64 2.84-7.27 7.89-7.27 13.17v363.87c0 11.55 12.63 18.85 23.28 13.49 69.18-34.82 169.23-44.32 218.7-46.92 16.89-.89 30.02-14.43 30.02-30.66V62.75c.01-17.71-15.35-31.74-33.77-30.7zM264.73 87.64C197.5 46.48 88.58 35.17 33.78 32.05 15.36 31.01 0 45.04 0 62.75V400.6c0 16.24 13.13 29.78 30.02 30.66 49.49 2.6 149.59 12.11 218.77 46.95 10.62 5.35 23.21-1.94 23.21-13.46V100.63c0-5.29-2.62-10.14-7.27-12.99z"></path></svg></span>
<a href="https://code.kx.com/q/basics/errors/">Errors</a></p>
<h2 id="b1-runtime-errors">B.1 Runtime Errors</h2>
<table>
<thead>
<tr>
<th>Error</th>
<th>Example</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Access</td>
<td></td>
<td>Attempt to read files above directory, run system commands or failed usr/pwd</td>
</tr>
<tr>
<td>Assign</td>
<td><code>cos:12</code></td>
<td>Attempt to reuse a reserved word</td>
</tr>
<tr>
<td>Conn</td>
<td></td>
<td>Too many incoming connections (1022 max)</td>
</tr>
<tr>
<td>Domain</td>
<td><code>til -1</code></td>
<td>Argument out of domain</td>
</tr>
<tr>
<td>Glim</td>
<td></td>
<td>As of q3.2 there is no limit on number of <code>`g#</code> attributes</td>
</tr>
<tr>
<td>Length</td>
<td><code style="white-space: nowrap">(til 2)+til 3</code></td>
<td>Incompatible list lengths</td>
</tr>
<tr>
<td>limit</td>
<td></td>
<td>Attempt to create list longer than allowable maximum (2 billion in q2.*) or trying to serialize an object &gt; 2GB in any version.</td>
</tr>
<tr>
<td>loop</td>
<td><code>a::b::a</code></td>
<td>Circular reference loop</td>
</tr>
<tr>
<td>mismatch</td>
<td></td>
<td>Columns cannot be aligned for operation</td>
</tr>
<tr>
<td>mlim</td>
<td></td>
<td>More than 999 nested columns in splayed table</td>
</tr>
<tr>
<td>nyi</td>
<td></td>
<td>Not yet implemented</td>
</tr>
<tr>
<td>os</td>
<td></td>
<td>Operating system error</td>
</tr>
<tr>
<td>pl</td>
<td></td>
<td>peach can't handle parallel lambda's (2.3 only)</td>
</tr>
<tr>
<td>Q7</td>
<td></td>
<td>Unimplemented op on file nested array</td>
</tr>
<tr>
<td>rank</td>
<td><code>+[2;3;4]</code></td>
<td>Invalid rank or valence</td>
</tr>
<tr>
<td>s-fail</td>
<td><code>`s#3 2</code></td>
<td>Invalid attribute setting</td>
</tr>
<tr>
<td>splay</td>
<td></td>
<td>Unimplimented op on splayed table</td>
</tr>
<tr>
<td>stack</td>
<td></td>
<td>Exhausted stack space</td>
</tr>
<tr>
<td>stop</td>
<td></td>
<td>User interrupt(ctrl-c) or time limit (-T)</td>
</tr>
<tr>
<td>stype</td>
<td><code>'42</code></td>
<td>Invalid type used to signal</td>
</tr>
<tr>
<td>type</td>
<td><code>til 4.2</code></td>
<td>Wrong type</td>
</tr>
<tr>
<td>value</td>
<td></td>
<td>Missing value</td>
</tr>
<tr>
<td>vd1</td>
<td></td>
<td>Attempted multithread update</td>
</tr>
<tr>
<td>wsfull</td>
<td></td>
<td>malloc failed. ran out of swap (or addressability on 32bit). or hit <code>-w</code> limit</td>
</tr>
<tr>
<td>xxx</td>
<td><code>'xxx</code></td>
<td><em>xxx</em> undefined</td>
</tr>
</tbody>
</table>
<h2 id="b2-parse-errors">B.2 Parse Errors</h2>
<table>
    <thead markdown="0">
        <tr><th>Error</th><th>Example</th><th>Description</th></tr>
    </thead>
    <tbody>
        <tr>
            <td>(<br>)<br>[<br>]<br>{<br>}<br>"</td>
            <td>
            </td><td>Unpaired item</td>
        </tr>
        <tr>
            <td>branch</td>
            <td>
            </td><td>A branch (if; do; while; \$[.;.;.]) more than 255 byte codes away</td>
        </tr>
        <tr>
            <td>char</td>
            <td>
            </td><td>Invalid character</td>
        </tr>
        <tr>
            <td>constants</td>
            <td>
            </td><td>Too many constants (96 max)</td>
        </tr>
        <tr>
            <td>globals</td>
            <td>
            </td><td>Too many global variables (255 max)</td>
        </tr>
        <tr>
            <td>locals</td>
            <td>
            </td><td>Too many local variables (24 max)</td>
        </tr>
        <tr>
            <td>params</td>
            <td>
            </td><td>Too many parameters (8 max)</td>
        </tr>
    </tbody>
</table>

<h2 id="b3-system-errors">B.3 System Errors</h2>
<table>
    <thead>
        <tr><th>Error</th><th>Examples</th><th>Description</th></tr>
    </thead>
    <tbody>
        <tr>
            <td><em>xxx:yyy</em></td>
            <td>
            </td><td>
                <em>xxx</em> is a kdb+ message<br>
                <em>yyy</em> is the OS message<br>
                <em>xxx</em> can be<br>
                addr<br>
                close<br>
                conn<br>
                p (from -p)<br>
                snd<br>
                rcv<br>
                <em>filename</em> (invalid)
            </td>
        </tr>
    </tbody>
</table>

<h2 id="b4-license-errors">B.4 License Errors</h2>
<table>
<thead>
<tr>
<th>Error</th>
<th>Example</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>cores</td>
<td></td>
<td>Exceeded number of licensed cores</td>
</tr>
<tr>
<td>exp</td>
<td></td>
<td>Expiry date passed</td>
</tr>
<tr>
<td>host</td>
<td></td>
<td>Unlicensed host</td>
</tr>
<tr>
<td>k4.lic</td>
<td></td>
<td>k4.lic file not found, check QHOME/QLIC</td>
</tr>
<tr>
<td>os</td>
<td></td>
<td>Unlicensed OS</td>
</tr>
<tr>
<td>srv</td>
<td></td>
<td>Attempt to use client-only license in server mod</td>
</tr>
<tr>
<td>upd</td>
<td></td>
<td>Attempt to use version of kdb+ more recent than update date</td>
</tr>
<tr>
<td>user</td>
<td></td>
<td>Unlicensed user</td>
</tr>
<tr>
<td>wha</td>
<td></td>
<td>Invalid system date</td>
</tr>
</tbody>
</table>
                


                
              
              
                


              
            </article>
            
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))for(var set of document.querySelectorAll("[data-tabs]")){var labels=set.querySelectorAll(":scope > label");e:for(var tab of tabs)for(var label of labels)if(label.innerText.trim()===tab){var input=label.previousElementSibling;input.checked=!0;break e}}</script>

          </div>
        </div>
        
          
        
      
                </div>
            </section>
        
            <section class="chapter" id="chapter-17">
                <div class="chapter-header">
                    <h1 class="chapter-title">Q for Mortals v3.1¬∂</h1>
                    <div class="chapter-meta">
                        <span>üìñ Source: <a href="https://code.kx.com/q4m3/colophon/">https://code.kx.com/q4m3/colophon/</a></span>
                        <span>üìù 130 words</span>
                        
                    </div>
                </div>
                <div class="chapter-content">
                    
        <div class="md-main__inner md-grid">
          
            
              
              
            
            
              
              
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                
                <h1 id="q-for-mortals-v31">Q for Mortals v3.1</h1>
<p>¬©2015 Jeffry A. Borror / q4m LLC</p>
<p>Published by q4m LLC</p>
<p>6 Lounsbery Road, Bedford Corners, New York 10549, USA</p>
<p>All rights reserved. No part of this book may be reproduced in any form, or by any means, without permission in writing from the author. </p>
<p>The author and the publisher of this book have used their best efforts in preparing this book, including development, research and testing of the examples given herein. The author and the publisher make no warranty of any kind, express or implied, with regard to the documentation or programs contained in this book. </p>
<p>This HTML edition is maintained by <a href="mailto:librarian@kx.com">librarian@kx.com</a> ‚Äì&nbsp;please contact with any corrections. </p>
                


                
              
              
                


              
            </article>
            
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))for(var set of document.querySelectorAll("[data-tabs]")){var labels=set.querySelectorAll(":scope > label");e:for(var tab of tabs)for(var label of labels)if(label.innerText.trim()===tab){var input=label.previousElementSibling;input.checked=!0;break e}}</script>

          </div>
        </div>
        
          
        
      
                </div>
            </section>
        
            <section class="chapter" id="chapter-18">
                <div class="chapter-header">
                    <h1 class="chapter-title">Preface¬∂</h1>
                    <div class="chapter-meta">
                        <span>üìñ Source: <a href="https://code.kx.com/q4m3/preface/">https://code.kx.com/q4m3/preface/</a></span>
                        <span>üìù 407 words</span>
                        
                    </div>
                </div>
                <div class="chapter-content">
                    
        <div class="md-main__inner md-grid">
          
            
              
              
            
            
              
              
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                
                <h1 id="preface">Preface</h1>
<p>This text represents a complete rewrite of <em>Q for Mortals</em>. Although the Table of Contents may look familiar, very little of the original text survived. This version targets all the features of q3.2, as well as correcting both errors of omission and commission in the original. All code snippets have been copied from the q3.2 console but they should work unchanged in q3.3. Please send corrections, additions and constructive suggestions to <a href="mailto:q4mortals@gmail.com">q4mortals@gmail.com</a>.</p>
<p>A significant improvement in this version is that the author was learning q while writing the original, but he actually knows some q now. One thing that hasn‚Äôt changed is the author‚Äôs philosophy: You can only be young once but you can be immature your entire life.</p>
<p>Numerous people have been instrumental in shepherding this to print. First and foremost, the folks at First Derivatives and KX. Of course, there would be no q gods or mortals without Arthur Whitney‚Äôs brilliant invention of q and kdb+. Janet Lustgarten has been supportive of the effort from day one. Abby Gruen served as the midwife during the book‚Äôs birth. Charles Skelton kept me honest. Simon Garland patiently answered my innumerable na√Øve q questions. Brian Conlon and Victoria Shanks invited me to announce the book at KX meetups.</p>
<p>Many colleagues suffered through early drafts of the text. My go-to proofreaders were Jose Cambronero, Kevin Ching, Simon Garland, Fermin Reig and Mike Rosenberg. They persevered through my horrendous typing and Word‚Äôs inability to spell-check the document ‚Äì  invariably insisting it was in French ‚Äì over countless drafts. They also made valuable suggestions regarding content and presentation. To the others who are unnamed I am nonetheless grateful. All remaining errors are mine alone.</p>
<p>Thanks to Omar for patience and support as I spent weekends and vacations tethered to my MacBook. And thanks to Nuba and Devi for providing necessary distractions.</p>
<div class="admonition note">
<p class="admonition-title">Version 3.1</p>
<p>Since <em>Q for Mortals Version 3</em> went to press we have revised the terminology used in <a href="https://code.kx.com/">code.kx.com</a> in order to follow common usage more closely. <em>Monadic</em> and <em>dyadic</em> are now respectively <em>unary</em> and <em>binary</em>; <em>verbs</em> are now <em>operators</em> and <em>keywords</em>; and <em>adverbs</em> are <em>iterators</em>.</p>
<p>This HTML edition is published by KX, by permission of the author. 
It has been updated to follow KX‚Äôs revision of terminology, and linked to the online <a href="https://code.kx.com/q/ref/">Reference</a>.</p>
<p>Please advise <a href="mailto:librarian@kx.com">librarian@kx.com</a> of any errors in this edition.</p>
</div>
                


                
              
              
                


              
            </article>
            
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))for(var set of document.querySelectorAll("[data-tabs]")){var labels=set.querySelectorAll(":scope > label");e:for(var tab of tabs)for(var label of labels)if(label.innerText.trim()===tab){var input=label.previousElementSibling;input.checked=!0;break e}}</script>

          </div>
        </div>
        
          
        
      
                </div>
            </section>
        
            <section class="chapter" id="chapter-19">
                <div class="chapter-header">
                    <h1 class="chapter-title">Preface¬∂</h1>
                    <div class="chapter-meta">
                        <span>üìñ Source: <a href="https://code.kx.com/q4m3/preface/">https://code.kx.com/q4m3/preface/</a></span>
                        <span>üìù 407 words</span>
                        
                    </div>
                </div>
                <div class="chapter-content">
                    
        <div class="md-main__inner md-grid">
          
            
              
              
            
            
              
              
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                
                <h1 id="preface">Preface</h1>
<p>This text represents a complete rewrite of <em>Q for Mortals</em>. Although the Table of Contents may look familiar, very little of the original text survived. This version targets all the features of q3.2, as well as correcting both errors of omission and commission in the original. All code snippets have been copied from the q3.2 console but they should work unchanged in q3.3. Please send corrections, additions and constructive suggestions to <a href="mailto:q4mortals@gmail.com">q4mortals@gmail.com</a>.</p>
<p>A significant improvement in this version is that the author was learning q while writing the original, but he actually knows some q now. One thing that hasn‚Äôt changed is the author‚Äôs philosophy: You can only be young once but you can be immature your entire life.</p>
<p>Numerous people have been instrumental in shepherding this to print. First and foremost, the folks at First Derivatives and KX. Of course, there would be no q gods or mortals without Arthur Whitney‚Äôs brilliant invention of q and kdb+. Janet Lustgarten has been supportive of the effort from day one. Abby Gruen served as the midwife during the book‚Äôs birth. Charles Skelton kept me honest. Simon Garland patiently answered my innumerable na√Øve q questions. Brian Conlon and Victoria Shanks invited me to announce the book at KX meetups.</p>
<p>Many colleagues suffered through early drafts of the text. My go-to proofreaders were Jose Cambronero, Kevin Ching, Simon Garland, Fermin Reig and Mike Rosenberg. They persevered through my horrendous typing and Word‚Äôs inability to spell-check the document ‚Äì  invariably insisting it was in French ‚Äì over countless drafts. They also made valuable suggestions regarding content and presentation. To the others who are unnamed I am nonetheless grateful. All remaining errors are mine alone.</p>
<p>Thanks to Omar for patience and support as I spent weekends and vacations tethered to my MacBook. And thanks to Nuba and Devi for providing necessary distractions.</p>
<div class="admonition note">
<p class="admonition-title">Version 3.1</p>
<p>Since <em>Q for Mortals Version 3</em> went to press we have revised the terminology used in <a href="https://code.kx.com/">code.kx.com</a> in order to follow common usage more closely. <em>Monadic</em> and <em>dyadic</em> are now respectively <em>unary</em> and <em>binary</em>; <em>verbs</em> are now <em>operators</em> and <em>keywords</em>; and <em>adverbs</em> are <em>iterators</em>.</p>
<p>This HTML edition is published by KX, by permission of the author. 
It has been updated to follow KX‚Äôs revision of terminology, and linked to the online <a href="https://code.kx.com/q/ref/">Reference</a>.</p>
<p>Please advise <a href="mailto:librarian@kx.com">librarian@kx.com</a> of any errors in this edition.</p>
</div>
                


                
              
              
                


              
            </article>
            
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))for(var set of document.querySelectorAll("[data-tabs]")){var labels=set.querySelectorAll(":scope > label");e:for(var tab of tabs)for(var label of labels)if(label.innerText.trim()===tab){var input=label.previousElementSibling;input.checked=!0;break e}}</script>

          </div>
        </div>
        
          
        
      
                </div>
            </section>
        
    </main>
    
    <footer style="text-align: center; padding: 40px 0; border-top: 1px solid var(--border-color); margin-top: 60px;">
        <p><strong>Q for Mortals - Complete Book</strong></p>
        <p>This document was automatically generated from the Q for Mortals website.</p>
        <p>Original content: <a href="https://code.kx.com/q4m3/">https://code.kx.com/q4m3/</a></p>
        <p>Generated on: 2025-07-13T09:00:42.083Z</p>
    </footer>
</body>
</html>